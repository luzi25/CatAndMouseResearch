<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumon Research</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Scriptorama+Tradeshow+JF&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Mono', 'Lucida Console', monospace;
            background: #101827;
            color: #7FE9E1;
            min-height: 100vh;
            overflow-x: hidden;
            text-transform: uppercase;
            position: relative;
            cursor: default;
        }
        
        /* Mouse cursor rules */
        button, input[type="number"], input[type="text"], input[type="file"], .btn, .file-input-custom {
            cursor: pointer !important;
        }
        
        input[type="range"], input[type="checkbox"], .collapsible-title {
            cursor: pointer !important;
        }

        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .crt-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 1px,
                rgba(127, 233, 225, 0.08) 1px,
                rgba(127, 233, 225, 0.08) 2px,
                transparent 2px,
                transparent 4px
            );
            opacity: var(--crt-scanlines, 0.8);
            animation: crt-scanlines 0.1s linear infinite;
        }

        .crt-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 1px,
                    rgba(127, 233, 225, 0.02) 1px,
                    rgba(127, 233, 225, 0.02) 2px
                ),
                radial-gradient(
                    ellipse 120% 100% at center,
                    transparent 65%,
                    rgba(0, 0, 0, 0.4) 100%
                );
            opacity: var(--crt-pixels, 0.3);
        }

        @keyframes crt-scanlines {
            0% { transform: translateY(0px); }
            100% { transform: translateY(4px); }
        }

        @keyframes crt-flicker {
            0% { opacity: 1; }
            50% { opacity: 0.98; }
            100% { opacity: 1; }
        }



        .crt-screen {
            filter: 
                contrast(1.1) 
                brightness(1.05) 
                saturate(1.2);
        }

        .crt-screen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .crt-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .crt-screen * {
            text-shadow: 
                0 0 1px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.4)),
                0 0 2px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.2)),
                0 0 3px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.1));
        }

        .crt-screen .grid {
            text-shadow: 
                0 0 1px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.6)),
                0 0 2px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.3)),
                0 0 3px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.2));
        }

        .container {
            display: flex;
            min-height: 100vh;
            background: #101827;
            position: relative;
            overflow: hidden;
        }

        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: transparent;
            padding: 1rem 2rem;
            z-index: 1000;
        }

        .header h1 {
            font-family: 'Scriptorama Tradeshow JF', 'Space Mono', 'Lucida Console', monospace;
            font-size: 4rem;
            font-weight: 600;
            color: #7FE9E1;
            text-align: center;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .main-content {
            display: flex;
            width: 100%;
            margin-top: 165px;
            min-height: calc(100vh - 165px);
        }

        .control-center {
            width: 15%;
            background: #101827;
            padding: 1rem;
            overflow-y: auto;
            position: relative;
        }

        .draggable-panel {
            cursor: move;
            user-select: none;
            position: relative;
        }

        .draggable-panel:hover {
            opacity: 0.9;
        }

        .draggable-panel.dragging {
            z-index: 1000;
            position: fixed;
            background: #101827;
            border: 1px solid #7FE9E1;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(127, 233, 225, 0.3);
        }

        .simulation-view {
            width: 70%;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: stretch;
            background: #101827;
            min-height: calc(100vh - 80px);
            position: relative;
        }

        .analytics-panel {
            width: 15%;
            background: #101827;
            padding: 1rem;
            overflow-y: auto;
        }

        .section-title {
            font-size: 1.6rem;
            font-weight: 700;
            color: #7FE9E1;
            margin-bottom: 0.7rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #4B566A;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .collapsible-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #7FE9E1;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border: 1px solid #4B566A;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            background: #101827;
            transition: all 0.2s;
            user-select: none;
            position: relative;
        }

        .collapsible-title:hover {
            background: #4B566A;
            box-shadow: 0 0 5px rgba(127, 233, 225, 0.3);
        }

        .collapsible-title::after {
            content: '▼';
            position: absolute;
            right: 0.5rem;
            transition: transform 0.2s;
        }

        .collapsible-title.collapsed::after {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }

        .collapsible-content:not(.collapsed) {
            max-height: 90vh;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        /* Specific constraint for Settings dropdown to prevent footer movement */
        #settingsContent:not(.collapsed) {
            max-height: 40vh;
            overflow-y: auto;
            overflow-x: hidden;
            /* Hide scrollbar for WebKit browsers */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        /* Hide settings section by default (shown only with Ctrl+M) */
        .settings-section-hidden {
            display: none !important;
        }
        
        /* Hide scrollbar for WebKit browsers */
        #settingsContent:not(.collapsed)::-webkit-scrollbar {
            display: none;
        }
        
        /* Specific constraint for Typography section to prevent page overflow */
        #typographyContent:not(.collapsed) {
            max-height: 40vh;
            overflow-y: auto;
            overflow-x: hidden;
            /* Hide scrollbar for WebKit browsers */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        /* Hide scrollbar for WebKit browsers */
        #typographyContent:not(.collapsed)::-webkit-scrollbar {
            display: none;
        }

        #layoutContent:not(.collapsed) {
            max-height: 40vh;
            overflow-y: auto;
        }

        #layoutContent:not(.collapsed)::-webkit-scrollbar {
            display: none;
        }

        /* Enhanced slider value displays */
        .speed-display {
            transition: transform 0.15s ease, color 0.15s ease;
        }

        /* Help popup styles - matching welcome page */
        .help-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10001;
            display: none;
        }

        .help-popup-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70%;
            height: 100%;
            background: #101827;
            color: #7FE9E1;
            padding: 1rem;
            padding-top: 4rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
        }

        .help-popup-content h3 {
            color: #7FE9E1;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .help-param {
            margin-bottom: 1.5rem;
            width: 100%;
            text-align: left;
            line-height: 1.4;
            font-size: 0.9rem;
        }

        .help-param h4 {
            color: #7FE9E1;
            margin-bottom: 0.4rem;
            font-size: 1.1rem;
        }

        .help-param .param-range {
            font-size: 0.85rem;
            color: #a0e7e0;
            font-style: italic;
            margin-bottom: 0.5rem;
        }

        .help-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: none;
        }

        .help-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: #7FE9E1;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10002;
        }

        .help-close-btn:hover {
            color: #ffffff;
            background: rgba(127, 233, 225, 0.2);
            border-radius: 50%;
        }

        .help-clickable {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .help-clickable:hover {
            color: #ffffff;
        }

        /* Button row layout */
        .button-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .button-row .btn {
            flex: 1;
            min-width: fit-content;
            font-size: 0.8rem;
            padding: 0.4rem 0.6rem;
            text-align: center;
        }

        .legend .scramble-char {
            display: inline-block;
            min-width: 1ch;
            text-align: center;
            font-family: 'Consolas', 'Courier New', monospace;
        }

        .inline-editable {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 2px;
            transition: background-color 0.2s;
        }

        .inline-editable:hover {
            background: rgba(127, 233, 225, 0.1);
        }

        .inline-editable.editing {
            background: rgba(127, 233, 225, 0.2) !important;
            outline: 1px solid #7FE9E1 !important;
        }

        .param-group {
            margin-bottom: 0.7rem;
        }

        .param-item {
            margin-bottom: 0.4rem;
        }
        
        /* Compact settings sections */
        .settings-section-compact .param-item {
            margin-bottom: 0.2rem;
        }
        
        .settings-section-compact .param-item label {
            font-size: 0.7rem;
            margin-bottom: 0.1rem;
        }
        
        .settings-section-compact .speed-display {
            font-size: 0.6rem;
        }

        .param-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.4rem;
            font-size: 0.85rem;
        }
        
        /* Ensure consistent spacing between all parameter elements */
        .param-group > .param-item:last-child,
        .param-group > .param-row:last-child {
            margin-bottom: 0;
        }
        
        /* Ensure consistent spacing in analytics panels */
        .analytics-panel .stat-row:last-child {
            margin-bottom: 0;
        }
        
        /* Ensure consistent spacing within bordered sections */
        div[style*="border-top"] .stat-row:last-child {
            margin-bottom: 0;
        }

        .param-label {
            color: #4B566A;
            text-transform: uppercase;
            font-weight: 500;
        }

        .param-value {
            font-weight: 600;
            color: #7FE9E1;
        }

        .param-item label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            color: #7FE9E1;
            margin-bottom: 0.2rem;
            text-transform: uppercase;
        }

        .param-item input[type="number"] {
            width: 100%;
            padding: 0.3rem;
            border: 1px solid #4B566A;
            border-radius: 2px;
            font-size: 0.7rem;
            background: #101827;
            color: #7FE9E1;
        }
        
        .param-item input[type="range"] {
            width: 100%;
            padding: 0.3rem;
            border: none;
            border-radius: 2px;
            font-size: 0.7rem;
            background: transparent;
            color: #7FE9E1;
        }

        .param-item input[type="number"]:focus {
            outline: none;
            border-color: #7FE9E1;
            box-shadow: 0 0 5px rgba(127, 233, 225, 0.3);
        }
        
        .param-item input[type="range"]:focus {
            outline: none;
            box-shadow: 0 0 5px rgba(127, 233, 225, 0.3);
        }

        .param-item input[type="number"]:disabled,
        .param-item input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Remove number input arrows */
        .param-row input[type="number"]::-webkit-outer-spin-button,
        .param-row input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .param-row input[type="number"] {
            -moz-appearance: textfield;
        }

        .param-row input[type="number"]:focus {
            outline: 1px solid #7FE9E1;
            background: rgba(127, 233, 225, 0.1);
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .checkbox-item input[type="checkbox"],
        .param-row input[type="checkbox"] {
            margin-right: 0.5rem;
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #7FE9E1;
            border-radius: 2px;
            background: transparent;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        .checkbox-item input[type="checkbox"]:checked,
        .param-row input[type="checkbox"]:checked {
            background: #7FE9E1;
            border-color: #7FE9E1;
        }

        .checkbox-item input[type="checkbox"]:checked::after,
        .param-row input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            top: -1px;
            left: 2px;
            color: #101827;
            font-size: 12px;
            font-weight: bold;
        }

        .checkbox-item input[type="checkbox"]:hover,
        .param-row input[type="checkbox"]:hover {
            border-color: #7FE9E1;
            box-shadow: 0 0 8px rgba(127, 233, 225, 0.4);
            transform: scale(1.05);
        }

        /* Custom Slider Styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: #4B566A;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        input[type="range"]:hover {
            background: #5A6478;
            box-shadow: 0 0 10px rgba(127, 233, 225, 0.2);
        }

        /* Webkit Slider Thumb - Hidden */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 0;
            height: 0;
            background: transparent;
            cursor: pointer;
        }

        /* Firefox Slider Thumb - Hidden */
        input[type="range"]::-moz-range-thumb {
            width: 0;
            height: 0;
            background: transparent;
            border: none;
            cursor: pointer;
        }

        /* Firefox Slider Track */
        input[type="range"]::-moz-range-track {
            height: 4px;
            background: #4B566A;
            border-radius: 2px;
            border: none;
        }

        /* Active slider track fill */
        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: linear-gradient(to right, #7FE9E1 0%, #7FE9E1 var(--range-progress, 0%), #4B566A var(--range-progress, 0%), #4B566A 100%);
            border-radius: 2px;
        }

        .checkbox-item label {
            font-size: 0.9rem;
            color: #7FE9E1;
            margin: 0;
            text-transform: uppercase;
        }

        .btn {
            width: 100%;
            padding: 0.5rem;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 0.2rem;
        }

        /* Prevent animations on page load */
        .no-animations * {
            transition: none !important;
            animation: none !important;
        }

        /* Authentic CRT Monitor Screen Curvature */
        .crt-monitor-curve {
            border-radius: 20px 20px 25px 25px;
            overflow: hidden;
            box-shadow: 
                inset 0 0 0 2px rgba(127, 233, 225, 0.1),
                inset 0 0 30px rgba(0,0,0,0.2),
                0 0 20px rgba(0,0,0,0.3);
            transform-style: preserve-3d;
        }
        
        /* Fisheye lens distortion overlay */
        .crt-fisheye-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            background: 
                radial-gradient(ellipse 85% 90% at center, 
                    rgba(255,255,255,0.02) 0%, 
                    transparent 20%, 
                    transparent 70%, 
                    rgba(0,0,0,0.05) 85%, 
                    rgba(0,0,0,0.15) 95%, 
                    rgba(0,0,0,0.4) 100%
                );
            border-radius: 30px;
            mix-blend-mode: overlay;
        }
        
        /* Screen glass reflection effect */
        .crt-glass-reflection {
            position: fixed;
            top: 5%;
            left: 15%;
            width: 30%;
            height: 40%;
            pointer-events: none;
            z-index: 1001;
            background: 
                linear-gradient(135deg, 
                    rgba(255,255,255,0.1) 0%, 
                    rgba(255,255,255,0.05) 30%, 
                    transparent 70%
                );
            border-radius: 50% 20% 80% 40%;
            opacity: 0.3;
            mix-blend-mode: screen;
        }
        
        /* CRT Screen bezel shadow */
        .crt-bezel-shadow {
            position: fixed;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            pointer-events: none;
            z-index: 998;
            background: 
                radial-gradient(ellipse 100% 100% at center, 
                    transparent 75%, 
                    rgba(0,0,0,0.3) 90%, 
                    rgba(0,0,0,0.8) 100%
                );
            border-radius: 40px;
        }

        .btn-primary {
            background: #4B566A;
            color: #7FE9E1;
            border: 1px solid #7FE9E1;
            text-transform: uppercase;
        }

        .btn-primary:hover {
            background: #7FE9E1;
            color: #101827;
            box-shadow: 0 0 10px rgba(127, 233, 225, 0.5);
        }

        .btn-secondary {
            background: #101827;
            color: #7FE9E1;
            border: 1px solid #4B566A;
            text-transform: uppercase;
        }

        .btn-secondary:hover {
            background: #4B566A;
            border-color: #7FE9E1;
        }

        .btn-danger {
            background: #101827;
            color: #7FE9E1;
            border: 1px solid #7FE9E1;
            text-transform: uppercase;
        }

        .btn-danger:hover {
            background: #7FE9E1;
            color: #101827;
        }

        .grid-container {
            background: #101827;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .grid {
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 1.6rem;
            line-height: 1.3rem;
            letter-spacing: 0.4rem;
            color: #7FE9E1;
            white-space: pre;
            background: #101827;
            padding: 0;
            margin: 0;
            border: none;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            padding-top: 4.1rem;
            font-weight: normal;
        }

        .footer-container {
            position: absolute;
            bottom: 7rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        .legend {
            font-size: 1rem;
            color: #7FE9E1;
            text-align: center;
            padding: 0.5rem;
            background: #101827;
            text-transform: uppercase;
            white-space: nowrap;
            overflow: hidden;
            min-width: max-content;
            letter-spacing: normal;
            word-spacing: normal;
        }

        .chart-container {
            width: 100%;
            height: 500px;
            display: none;
            position: relative;
        }
        
        .chart-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: #101827;
            border: 2px solid #7FE9E1;
            color: #7FE9E1;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .chart-close-btn:hover {
            background: #7FE9E1;
            color: #101827;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.4rem;
            font-size: 0.85rem;
        }

        .stat-label {
            color: #4B566A;
            text-transform: uppercase;
        }

        .stat-value {
            font-weight: 600;
            color: #7FE9E1;
        }

        .file-input {
            display: none;
        }

        .file-input-custom {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #4B566A;
            border-radius: 2px;
            font-size: 0.7rem;
            margin-bottom: 0.2rem;
            background: #101827;
            color: #7FE9E1;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            user-select: none;
        }

        .file-input-custom:hover {
            border-color: #7FE9E1;
            background: rgba(127, 233, 225, 0.1);
            box-shadow: 0 0 5px rgba(127, 233, 225, 0.3);
        }

        .file-input-custom.has-file {
            color: #7FE9E1;
            background: rgba(127, 233, 225, 0.05);
        }

        .speed-display {
            text-align: center;
            font-size: 0.8rem;
            color: #4B566A;
            margin-top: 0.2rem;
            text-transform: uppercase;
        }

        .cat { color: #7FE9E1; }
        .mouse { color: #7FE9E1; }
        .obstacle { color: #7FE9E1; }
        .cat-vision { color: #7FE9E1; }
        .mouse-vision { color: #7FE9E1; }
    </style>
</head>
<body>
    <div class="crt-overlay"></div>
    
    <!-- CRT Monitor Effects -->
    <div class="crt-fisheye-overlay" id="crtFisheyeOverlay"></div>
    <div class="crt-glass-reflection" id="crtGlassReflection"></div>
    <div class="crt-bezel-shadow" id="crtBezelShadow"></div>
    
    <!-- CRT Shader Canvas -->
    <canvas id="crtCanvas" style="position: fixed; top: 0; left: 0; pointer-events: none; z-index: 1001; mix-blend-mode: overlay;"></canvas>
    
    <header class="header">
        <h1>LUMON RESEARCH</h1>
    </header>

    <div class="container crt-screen">
        <div class="main-content">
            <!-- Left Column: Control Center -->
            <div class="control-center draggable-panel" id="controlPanel">
                <h3 class="section-title">Control Center</h3>
                
                <div class="param-group">
                    <h4 style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Simulation Parameters</h4>
                    
                    <div class="param-row">
                        <span class="param-label">Episode Count:</span>
                        <span class="param-value inline-editable" data-type="number" data-min="1" data-max="10000" data-input-id="episodeCount" data-callback="updateNumericValue">1000</span>
                    </div>
                    <input type="number" id="episodeCount" value="1000" min="1" max="10000" style="display: none;">
                    
                    <div class="param-row">
                        <span class="param-label">Step Count:</span>
                        <span class="param-value inline-editable" data-type="number" data-min="10" data-max="1000" data-input-id="stepCount" data-callback="updateNumericValue">200</span>
                    </div>
                    <input type="number" id="stepCount" value="200" min="10" max="1000" style="display: none;">
                    
                    <div class="param-row">
                        <span class="param-label">Cat Vision:</span>
                        <span class="param-value inline-editable" data-type="number" data-min="1" data-max="15" data-input-id="predatorVision" data-callback="updateNumericValue">8</span>
                    </div>
                    <input type="number" id="predatorVision" value="8" min="1" max="15" style="display: none;">
                    
                    <div class="param-row">
                        <span class="param-label">Mouse Vision:</span>
                        <span class="param-value inline-editable" data-type="number" data-min="1" data-max="15" data-input-id="preyVision" data-callback="updateNumericValue">6</span>
                    </div>
                    <input type="number" id="preyVision" value="6" min="1" max="15" style="display: none;">
                    
                    <div class="param-row">
                        <span class="param-label">Obstacle Count:</span>
                        <span class="param-value inline-editable" data-type="number" data-min="0" data-max="50" data-input-id="obstacleCount" data-callback="updateNumericValue">10</span>
                    </div>
                    <input type="number" id="obstacleCount" value="10" min="0" max="50" style="display: none;">
                    
                    <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #4B566A;">
                        <div class="collapsible-title collapsed" id="learningParametersToggle" style="font-size: 0.9rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Learning Parameters</div>
                        <div class="collapsible-content collapsed" id="learningParametersContent">
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h5 style="font-size: 0.8rem; color: #7FE9E1; margin-bottom: 0.3rem; text-transform: uppercase;">Cat (Predator)</h5>
                            
                            <div class="param-item">
                                <label for="catLearningRateSlider" id="catLearningRateLabel">Learning Rate: 0.11</label>
                                <input type="range" id="catLearningRateSlider" min="0.01" max="0.5" step="0.01" value="0.11">
                                <div class="speed-display" id="catLearningRateDisplay">0.11</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catEpsilonSlider" id="catEpsilonLabel">Exploration Rate: 0.35</label>
                                <input type="range" id="catEpsilonSlider" min="0.05" max="0.8" step="0.05" value="0.35">
                                <div class="speed-display" id="catEpsilonDisplay">0.35</div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h5 style="font-size: 0.8rem; color: #7FE9E1; margin-bottom: 0.3rem; text-transform: uppercase;">Mouse (Prey)</h5>
                            
                            <div class="param-item">
                                <label for="mouseLearningRateSlider" id="mouseLearningRateLabel">Learning Rate: 0.12</label>
                                <input type="range" id="mouseLearningRateSlider" min="0.01" max="0.5" step="0.01" value="0.12">
                                <div class="speed-display" id="mouseLearningRateDisplay">0.12</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseEpsilonSlider" id="mouseEpsilonLabel">Exploration Rate: 0.25</label>
                                <input type="range" id="mouseEpsilonSlider" min="0.05" max="0.8" step="0.05" value="0.25">
                                <div class="speed-display" id="mouseEpsilonDisplay">0.25</div>
                            </div>
                        </div>
                        
                        <div style="border-top: 1px solid #4B566A; padding-top: 0.5rem;">
                            <h5 style="font-size: 0.8rem; color: #7FE9E1; margin-bottom: 0.3rem; text-transform: uppercase;">Shared Parameters</h5>
                            
                            <div class="param-item">
                                <label for="discountFactorSlider" id="discountFactorLabel">Discount Factor: 0.95</label>
                                <input type="range" id="discountFactorSlider" min="0.1" max="0.99" step="0.05" value="0.95">
                                <div class="speed-display" id="discountFactorDisplay">0.95</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="epsilonDecaySlider" id="epsilonDecayLabel">Exploration Decay: 0.995</label>
                                <input type="range" id="epsilonDecaySlider" min="0.990" max="0.999" step="0.001" value="0.995">
                                <div class="speed-display" id="epsilonDecayDisplay">0.995</div>
                            </div>
                        </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 1rem;">
                        <div class="collapsible-title collapsed" id="rewardsToggle" style="font-size: 0.9rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Reward Parameters</div>
                        <div class="collapsible-content collapsed" id="rewardsContent">
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h5 style="font-size: 0.8rem; color: #7FE9E1; margin-bottom: 0.3rem; text-transform: uppercase;">Cat (Predator) Rewards</h5>
                            
                            <div class="param-item">
                                <label for="catWinSlider" id="catWinLabel">Win Bonus: +500</label>
                                <input type="range" id="catWinSlider" min="100" max="1000" step="50" value="500">
                                <div class="speed-display" id="catWinDisplay">500</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catHuntingSlider" id="catHuntingLabel">Hunting (Visible): +8</label>
                                <input type="range" id="catHuntingSlider" min="1" max="20" step="1" value="8">
                                <div class="speed-display" id="catHuntingDisplay">8</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catExplorationSlider" id="catExplorationLabel">Exploration: +2</label>
                                <input type="range" id="catExplorationSlider" min="0" max="10" step="0.5" value="2">
                                <div class="speed-display" id="catExplorationDisplay">2</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catRetreatingSlider" id="catRetreatingLabel">Retreating: -1</label>
                                <input type="range" id="catRetreatingSlider" min="-10" max="0" step="0.1" value="-1">
                                <div class="speed-display" id="catRetreatingDisplay">-1</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catStandingStillSlider" id="catStandingStillLabel">Standing Still: -0.1</label>
                                <input type="range" id="catStandingStillSlider" min="-1" max="0" step="0.01" value="-0.1">
                                <div class="speed-display" id="catStandingStillDisplay">-0.1</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catFailureSlider" id="catFailureLabel">Failure Penalty: -200</label>
                                <input type="range" id="catFailureSlider" min="-500" max="0" step="10" value="-200">
                                <div class="speed-display" id="catFailureDisplay">-200</div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h5 style="font-size: 0.8rem; color: #7FE9E1; margin-bottom: 0.3rem; text-transform: uppercase;">Mouse (Prey) Rewards</h5>
                            
                            <div class="param-item">
                                <label for="mouseSurvivalSlider" id="mouseSurvivalLabel">Survival Bonus: +500</label>
                                <input type="range" id="mouseSurvivalSlider" min="100" max="1000" step="50" value="500">
                                <div class="speed-display" id="mouseSurvivalDisplay">500</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseCaughtSlider" id="mouseCaughtLabel">Caught Penalty: -500</label>
                                <input type="range" id="mouseCaughtSlider" min="-1000" max="-100" step="50" value="-500">
                                <div class="speed-display" id="mouseCaughtDisplay">-500</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseStrategicEscapeSlider" id="mouseStrategicEscapeLabel">Strategic Escape: +4</label>
                                <input type="range" id="mouseStrategicEscapeSlider" min="1" max="10" step="0.5" value="4">
                                <div class="speed-display" id="mouseStrategicEscapeDisplay">4</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseBlindEscapeSlider" id="mouseBlindEscapeLabel">Blind Escape: +2</label>
                                <input type="range" id="mouseBlindEscapeSlider" min="0" max="10" step="0.5" value="2">
                                <div class="speed-display" id="mouseBlindEscapeDisplay">2</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseApproachingDangerSlider" id="mouseApproachingDangerLabel">Approaching Danger: -2</label>
                                <input type="range" id="mouseApproachingDangerSlider" min="-10" max="0" step="0.1" value="-2">
                                <div class="speed-display" id="mouseApproachingDangerDisplay">-2</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseStandingStillVisibleSlider" id="mouseStandingStillVisibleLabel">Standing Still (Visible): -0.5</label>
                                <input type="range" id="mouseStandingStillVisibleSlider" min="-2" max="0" step="0.1" value="-0.5">
                                <div class="speed-display" id="mouseStandingStillVisibleDisplay">-0.5</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseMovingTowardDangerSlider" id="mouseMovingTowardDangerLabel">Moving Toward Danger: -0.5</label>
                                <input type="range" id="mouseMovingTowardDangerSlider" min="-2" max="0" step="0.1" value="-0.5">
                                <div class="speed-display" id="mouseMovingTowardDangerDisplay">-0.5</div>
                            </div>
                        </div>
                        
                        <div style="font-style: italic; color: #7FE9E1; font-size: 0.7rem; text-align: center; margin-top: 0.5rem;">
                            Real-time reward tuning for balanced competitive gameplay
                        </div>
                        </div>
                    </div>
                </div>

                <div class="param-group">
                    <div class="collapsible-title collapsed" id="displayControlsToggle" style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Display Controls</div>
                    <div class="collapsible-content collapsed" id="displayControlsContent">
                    
                    <div class="param-row">
                        <span class="param-label">Toggle Render:</span>
                        <input type="checkbox" id="toggleRender" checked style="margin: 0;">
                    </div>
                    
                    <div class="param-row">
                        <span class="param-label">Toggle Vision:</span>
                        <input type="checkbox" id="toggleVision" checked style="margin: 0;">
                    </div>
                    
                    <div class="param-row">
                        <span class="param-label">Cone Vision:</span>
                        <input type="checkbox" id="toggleConeVision" style="margin: 0;">
                    </div>
                    
                    <div class="param-item">
                        <label for="visionAngle">Vision Cone Angle</label>
                        <input type="range" id="visionAngle" min="30" max="180" step="15" value="90">
                        <div class="speed-display" id="visionAngleDisplay">90°</div>
                    </div>
                    
                    
                    <div class="param-item">
                        <label for="simulationSpeed">Simulation Speed</label>
                        <input type="range" id="simulationSpeed" min="1" max="5000" step="10" value="100">
                        <div class="speed-display" id="speedDisplay">100ms</div>
                    </div>
                    </div>
                </div>


                <div class="param-group">
                    <h4 style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Actions</h4>
                    
                    <div class="button-row">
                        <button class="btn btn-primary" id="startTraining">Start</button>
                        <button class="btn btn-danger" id="stopTraining">Stop</button>
                        <button class="btn btn-secondary" id="continueTraining">Continue</button>
                    </div>
                </div>

                <div class="param-group">
                    <h4 style="font-size: 1.1rem; margin-bottom: 0.3rem; color: #7FE9E1; text-transform: uppercase;">Persistence</h4>
                    
                    <div class="button-row">
                        <button class="btn btn-secondary" id="downloadTraining">Download</button>
                        <button class="btn btn-secondary" id="uploadTrainingButton">Upload</button>
                    </div>
                    <input type="file" id="uploadTraining" class="file-input" accept=".json" style="display: none;">
                </div>
            </div>

            <!-- Middle Column: Simulation View -->
            <div class="simulation-view">
                <!-- Welcome Screen -->
                <div id="welcomeScreen" style="width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: flex-start; align-items: flex-start; padding: 0.8rem; padding-top: 4rem; color: #7FE9E1; overflow-y: auto;">
                    <div style="width: 100%; text-align: left; line-height: 1.2; font-size: 0.75rem;">
                        <div style="margin-bottom: 0.8rem;">
                            <h3 style="color: #7FE9E1; margin-bottom: 0.2rem; font-size: 0.9rem;">The Game</h3>
                            <p style="margin-bottom: 0.3rem;">Watch AI agents learn through reinforcement learning! A <strong>Cat (C)</strong> hunts a <strong>Mouse (M)</strong> in a grid with <strong>Obstacles (O)</strong>. Both agents use Q-Learning to develop strategies - the cat learns to hunt efficiently while the mouse learns to escape.</p>
                        </div>
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h3 style="color: #7FE9E1; margin-bottom: 0.2rem; font-size: 0.9rem;">Control Center & Learning Parameters</h3>
                            <p style="margin-bottom: 0.2rem;"><strong>Simulation Parameters:</strong> Episodes, steps, vision ranges, obstacles</p>
                            <p style="margin-bottom: 0.2rem;"><strong><span class="help-clickable" id="welcomeHelpTrigger">Learning Parameters:</span></strong> Learning Rate, Exploration Rate, Discount Factor, Exploration Decay</p>
                            <p style="margin-bottom: 0.3rem;"><strong>Real-time Tuning:</strong> Adjust parameters during training to see immediate effects</p>
                        </div>
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h3 style="color: #7FE9E1; margin-bottom: 0.2rem; font-size: 0.9rem;">Reward System</h3>
                            <p style="margin-bottom: 0.3rem;">The AI agents learn through a balanced reward system optimized for competitive gameplay:</p>
                            <div style="margin-left: 0.5rem;">
                                <p style="margin-bottom: 0.15rem;"><strong>Cat (Predator):</strong></p>
                                <p style="margin-bottom: 0.1rem; margin-left: 0.5rem; font-size: 0.7rem;" id="welcomeCatRewards">• Win: +500 | Failure: -200 | Hunting: +8 | Exploration: +2</p>
                                <p style="margin-bottom: 0.15rem; margin-left: 0.5rem; font-size: 0.7rem;" id="welcomeCatPenalties">• Retreating: -1 | Standing still: -0.1</p>
                                <p style="margin-bottom: 0.15rem;"><strong>Mouse (Prey):</strong></p>
                                <p style="margin-bottom: 0.1rem; margin-left: 0.5rem; font-size: 0.7rem;" id="welcomeMouseRewards">• Survival: +500 | Caught: -500 | Strategic escape: +4 | Blind escape: +2</p>
                                <p style="margin-bottom: 0.3rem; margin-left: 0.5rem; font-size: 0.7rem;" id="welcomeMousePenalties">• Approaching danger: -2 | Moving toward danger: -0.5 | Standing still (visible): -0.5</p>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h3 style="color: #7FE9E1; margin-bottom: 0.2rem; font-size: 0.9rem;">Actions</h3>
                            <p style="margin-bottom: 0.2rem;"><strong>Start:</strong> Begin training with current settings</p>
                            <p style="margin-bottom: 0.2rem;"><strong>Stop:</strong> Pause training (can be resumed)</p>
                            <p style="margin-bottom: 0.3rem;"><strong>Continue:</strong> Resume paused training</p>
                        </div>
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h3 style="color: #7FE9E1; margin-bottom: 0.2rem; font-size: 0.9rem;">Training Persistence</h3>
                            <p style="margin-bottom: 0.3rem;">Save and restore complete AI training sessions with full state preservation:</p>
                            <div style="margin-left: 0.5rem;">
                                <p style="margin-bottom: 0.15rem;"><strong>Download Training:</strong> Exports Q-tables, episode history, win statistics, environment configuration, and character mappings</p>
                                <p style="margin-bottom: 0.15rem;"><strong>Upload Training:</strong> Automatically switches Start button to Continue and restores exact game environment</p>
                                <p style="margin-bottom: 0.15rem;"><strong>Smart Button States:</strong> Interface adapts based on loaded training data</p>
                                <p style="margin-bottom: 0.3rem;"><strong>Environment Preservation:</strong> Obstacle layouts, spawn points, and custom characters maintained</p>
                            </div>
                        </div>
                        
                    </div>
                </div>
                
                <!-- Simulation Grid (Hidden Initially) -->
                <div id="gridView" style="width: 100%; height: 100%; display: none; flex-direction: column;">
                    <div class="grid-container">
                        <pre class="grid" id="gameGrid"></pre>
                    </div>
                </div>
                
                <!-- Separate Footer/Legend -->
                <div class="footer-container">
                    <div class="legend" id="gridLegend">
                        <span class="cat">C: CAT</span> | 
                        <span class="mouse">M: MOUSE</span> | 
                        <span class="obstacle">O: OBSTACLE</span> | 
                        <span class="cat-vision">?: CAT VISION</span> | 
                        <span class="mouse-vision">!: MOUSE VISION</span>
                    </div>
                </div>
                
                <div class="chart-container" id="chartContainer">
                    <button class="chart-close-btn" id="chartCloseBtn">×</button>
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>

            <!-- Right Column: Analytics Panel -->
            <div class="analytics-panel draggable-panel" id="analyticsPanel">
                <h3 class="section-title">Analytics Panel</h3>
                
                <div class="stat-row">
                    <span class="stat-label">Episode:</span>
                    <span class="stat-value" id="currentEpisode">0</span>
                </div>
                
                <div class="stat-row">
                    <span class="stat-label">Step:</span>
                    <span class="stat-value" id="currentStep">0</span>
                </div>
                
                <div class="stat-row">
                    <span class="stat-label">Cat Wins:</span>
                    <span class="stat-value" id="catWins">0</span>
                </div>
                
                <div class="stat-row">
                    <span class="stat-label">Mouse Wins:</span>
                    <span class="stat-value" id="mouseWins">0</span>
                </div>

                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #4B566A;">
                    <div class="stat-row">
                        <span class="stat-label">Cat Win Rate:</span>
                        <span class="stat-value" id="catWinRate">0%</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Mouse Win Rate:</span>
                        <span class="stat-value" id="mouseWinRate">0%</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Avg Steps:</span>
                        <span class="stat-value" id="avgSteps">0</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Training Status:</span>
                        <span class="stat-value" id="trainingStatus">Ready</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Cat Score:</span>
                        <span class="stat-value" id="currentCatScore">0</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Mouse Score:</span>
                        <span class="stat-value" id="currentMouseScore">0</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Obstacles:</span>
                        <span class="stat-value" id="obstacleCountDisplay">0</span>
                    </div>
                </div>
                
                <!-- Settings -->
                <div class="settings-section-hidden" id="settingsSection" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #4B566A;">
                    <div class="collapsible-title collapsed" id="settingsToggle">Settings</div>
                    <div class="collapsible-content collapsed" id="settingsContent">
                        
                        <!-- Grid Font Controls -->
                        <div style="margin-bottom: 1rem;">
                            <h4 style="font-size: 0.8rem; margin-bottom: 0.5rem; color: #7FE9E1;">GRID FONT</h4>
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Font Size:</span>
                                    <span class="param-value inline-editable" data-type="number" data-min="0.5" data-max="3" data-input-id="fontSize" data-callback="updateNumericValue">1.6</span>rem
                                </div>
                                <input type="range" id="fontSize" min="0.5" max="3" step="0.1" value="1.6" style="display: none;">
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Horizontal Spacing:</span>
                                    <span class="param-value inline-editable" data-type="number" data-min="-0.5" data-max="1" data-input-id="horizontalSpacing" data-callback="updateNumericValue">0.4</span>rem
                                </div>
                                <input type="range" id="horizontalSpacing" min="-0.5" max="1" step="0.1" value="0.4" style="display: none;">
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Vertical Spacing:</span>
                                    <span class="param-value inline-editable" data-type="number" data-min="0.5" data-max="2" data-input-id="verticalSpacing" data-callback="updateNumericValue">1.3</span>rem
                                </div>
                                <input type="range" id="verticalSpacing" min="0.5" max="2" step="0.1" value="1.3" style="display: none;">
                            </div>
                        </div>

                        <!-- CRT Effects -->
                        <div style="margin-bottom: 1rem;">
                            <h4 style="font-size: 0.8rem; margin-bottom: 0.5rem; color: #7FE9E1;">CRT EFFECTS</h4>
                            <div class="checkbox-item">
                                <input type="checkbox" id="crtEnabled" checked>
                                <label for="crtEnabled">Enable</label>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtGlow">Phosphor Glow</label>
                                <input type="range" id="crtGlow" min="0" max="3" step="0.1" value="0.7">
                                <div class="speed-display" id="glowDisplay">0.7</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtScanlines">Scanlines</label>
                                <input type="range" id="crtScanlines" min="0" max="1" step="0.1" value="0.9">
                                <div class="speed-display" id="scanlinesDisplay">0.9</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtWarp">Fisheye Lens</label>
                                <input type="range" id="crtWarp" min="0" max="5" step="0.1" value="0">
                                <div class="speed-display" id="warpDisplay">0</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtChromaticAberration">Chromatic Aberration</label>
                                <input type="range" id="crtChromaticAberration" min="0" max="10" step="0.5" value="8">
                                <div class="speed-display" id="chromaticDisplay">8</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtDistortion">Wave Distortion</label>
                                <input type="range" id="crtDistortion" min="0" max="10" step="0.5" value="7.5">
                                <div class="speed-display" id="distortionDisplay">7.5</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtVignette">Vignette</label>
                                <input type="range" id="crtVignette" min="0" max="10" step="0.5" value="3.5">
                                <div class="speed-display" id="vignetteDisplay">3.5</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtContrast">Contrast</label>
                                <input type="range" id="crtContrast" min="0.5" max="2" step="0.1" value="0.9">
                                <div class="speed-display" id="contrastDisplay">0.9</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtBrightness">Brightness</label>
                                <input type="range" id="crtBrightness" min="0.3" max="1.5" step="0.05" value="1.05">
                                <div class="speed-display" id="brightnessDisplay">1.05</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtSaturation">Saturation</label>
                                <input type="range" id="crtSaturation" min="0" max="2" step="0.1" value="1.1">
                                <div class="speed-display" id="saturationDisplay">1.1</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtFlicker">Screen Flicker</label>
                                <input type="range" id="crtFlicker" min="0" max="1" step="0.05" value="0.8">
                                <div class="speed-display" id="flickerDisplay">0.8</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtNoise">Static Noise</label>
                                <input type="range" id="crtNoise" min="0" max="1" step="0.05" value="0.7">
                                <div class="speed-display" id="noiseDisplay">0.7</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtPixels">Pixel Grid</label>
                                <input type="range" id="crtPixels" min="0" max="1" step="0.1" value="0">
                                <div class="speed-display" id="pixelsDisplay">0</div>
                            </div>
                        </div>
                        
                        <!-- Text Pressure -->
                        <div style="margin-bottom: 1rem;">
                            <h4 style="font-size: 0.8rem; margin-bottom: 0.5rem; color: #7FE9E1;">TEXT PRESSURE</h4>
                            <div class="checkbox-item">
                                <input type="checkbox" id="textPressureEnabled" checked>
                                <label for="textPressureEnabled">Enable</label>
                            </div>
                            
                            <div class="param-item">
                                <label for="textPressureRange">Effect Range</label>
                                <input type="range" id="textPressureRange" min="50" max="500" value="111">
                                <div class="speed-display" id="rangeDisplay">111px</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="textPressureSmoothing">Smoothing</label>
                                <input type="range" id="textPressureSmoothing" min="5" max="30" value="30">
                                <div class="speed-display" id="smoothingDisplay">30</div>
                            </div>
                        </div>
                            
                            <div class="param-item">
                                <label for="textPressureMinWeight">Min Font Weight</label>
                                <input type="range" id="textPressureMinWeight" min="1" max="1500" step="1" value="1">
                                <div class="speed-display" id="minWeightDisplay">1</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="textPressureMaxWeight">Max Font Weight</label>
                                <input type="range" id="textPressureMaxWeight" min="1" max="1500" step="1" value="1500">
                                <div class="speed-display" id="maxWeightDisplay">1500</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="textPressureMinOpacity">Min Opacity</label>
                                <input type="range" id="textPressureMinOpacity" min="0" max="1" step="0.1" value="0.8">
                                <div class="speed-display" id="minOpacityDisplay">0.8</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="textPressureMaxOpacity">Max Opacity</label>
                                <input type="range" id="textPressureMaxOpacity" min="0.5" max="1" step="0.1" value="1">
                                <div class="speed-display" id="maxOpacityDisplay">1</div>
                            </div>
                            
                            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #4B566A;">
                                <h4 style="font-size: 1.1rem; margin-bottom: 0.3rem; color: #7FE9E1; text-transform: uppercase;">Text Effects</h4>
                                
                                <div class="checkbox-item">
                                    <input type="checkbox" id="textPressureBold" checked>
                                    <label for="textPressureBold">Bold Weight Effect</label>
                                </div>
                                
                                <div class="checkbox-item">
                                    <input type="checkbox" id="textPressureItalic">
                                    <label for="textPressureItalic">Italic Effect</label>
                                </div>
                                
                                <div class="checkbox-item">
                                    <input type="checkbox" id="textPressureStrike">
                                    <label for="textPressureStrike">Strikethrough Effect</label>
                                </div>
                                
                                <div class="checkbox-item">
                                    <input type="checkbox" id="textPressureUnderline">
                                    <label for="textPressureUnderline">Underline Effect</label>
                                </div>
                                
                                <div class="checkbox-item">
                                    <input type="checkbox" id="textPressureScale" checked>
                                    <label for="textPressureScale">Scale Effect</label>
                                </div>
                            </div>
                            
                            <div style="margin-top: 0.5rem;">
                                <div class="param-item">
                                    <label for="textPressureScaleMin">Min Scale</label>
                                    <input type="range" id="textPressureScaleMin" min="0.5" max="1" step="0.1" value="0.7">
                                    <div class="speed-display" id="scaleMinDisplay">0.7</div>
                                </div>
                                
                                <div class="param-item">
                                    <label for="textPressureScaleMax">Max Scale</label>
                                    <input type="range" id="textPressureScaleMax" min="1" max="3" step="0.1" value="1.3">
                                    <div class="speed-display" id="scaleMaxDisplay">1.3</div>
                                </div>
                            </div>
                            </div>
                        
                        <!-- Layout Positioning -->
                        <div class="settings-section-hidden" style="margin-bottom: 1rem;">
                            <div class="collapsible-title collapsed" id="layoutToggle" style="font-size: 0.8rem; margin-bottom: 0.5rem; color: #7FE9E1; cursor: pointer;">LAYOUT POSITIONING</div>
                            <div class="collapsible-content collapsed" id="layoutContent">
                            
                            <div class="param-item">
                                <label for="headerVerticalPos">Header Position</label>
                                <input type="range" id="headerVerticalPos" min="-50" max="100" step="5" value="40">
                                <div class="speed-display" id="headerPosDisplay">40px</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="leftPanelVerticalPos">Left Panel Position</label>
                                <input type="range" id="leftPanelVerticalPos" min="-100" max="200" step="5" value="165">
                                <div class="speed-display" id="leftPanelPosDisplay">165px</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="rightPanelVerticalPos">Right Panel Position</label>
                                <input type="range" id="rightPanelVerticalPos" min="-100" max="200" step="5" value="165">
                                <div class="speed-display" id="rightPanelPosDisplay">165px</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="centerPanelVerticalPos">Center Panel Position</label>
                                <input type="range" id="centerPanelVerticalPos" min="-100" max="200" step="5" value="-25">
                                <div class="speed-display" id="centerPanelPosDisplay">-25px</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="footerVerticalPos">Footer Position</label>
                                <input type="range" id="footerVerticalPos" min="0" max="10" step="1" value="7">
                                <div class="speed-display" id="footerPosDisplay">7rem</div>
                            </div>
                            
                            </div>
                        </div>
                        
                        </div>
                        
                        
                        <!-- Typography Controls -->
                        <div class="settings-section-compact settings-section-hidden" style="margin-bottom: 0.5rem;">
                            <div class="collapsible-title collapsed" id="typographyToggle" style="font-size: 0.7rem; margin-bottom: 0.3rem; color: #7FE9E1; cursor: pointer;">TYPOGRAPHY</div>
                            <div class="collapsible-content collapsed" id="typographyContent">
                            
                            <div class="param-item">
                                <label for="showValueDisplays">Show Value Displays</label>
                                <input type="checkbox" id="showValueDisplays" class="custom-checkbox">
                            </div>
                            
                            <div class="param-item">
                                <label for="gridCharSize">Grid Character Size</label>
                                <input type="range" id="gridCharSize" min="0.5" max="3" step="0.1" value="1.6">
                                <div class="speed-display" id="gridCharDisplay">1.6rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="headerTitleSize">Main Header</label>
                                <input type="range" id="headerTitleSize" min="2" max="6" step="0.1" value="5.7">
                                <div class="speed-display" id="headerTitleDisplay">5.7rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="sectionTitleSize">Section Titles</label>
                                <input type="range" id="sectionTitleSize" min="1" max="3" step="0.1" value="1.4">
                                <div class="speed-display" id="sectionTitleDisplay">1.4rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="collapsibleTitleSize">Collapsible Titles</label>
                                <input type="range" id="collapsibleTitleSize" min="0.8" max="2" step="0.1" value="0.9">
                                <div class="speed-display" id="collapsibleTitleDisplay">0.9rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="subsectionSize">Subsection Headers</label>
                                <input type="range" id="subsectionSize" min="0.6" max="1.5" step="0.1" value="1">
                                <div class="speed-display" id="subsectionDisplay">1rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="paramLabelSize">Parameter Labels</label>
                                <input type="range" id="paramLabelSize" min="0.5" max="1.2" step="0.1" value="0.7">
                                <div class="speed-display" id="paramLabelDisplay">0.7rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="paramRowSize">Parameter Rows</label>
                                <input type="range" id="paramRowSize" min="0.5" max="1.2" step="0.1" value="0.8">
                                <div class="speed-display" id="paramRowDisplay">0.8rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="buttonSize">Buttons</label>
                                <input type="range" id="buttonSize" min="0.5" max="1.2" step="0.1" value="0.7">
                                <div class="speed-display" id="buttonDisplay">0.7rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="statsSize">Stats/Analytics</label>
                                <input type="range" id="statsSize" min="0.5" max="1.2" step="0.1" value="0.8">
                                <div class="speed-display" id="statsDisplay">0.8rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="speedDisplaySize">Value Displays</label>
                                <input type="range" id="speedDisplaySize" min="0.4" max="1" step="0.1" value="0.8">
                                <div class="speed-display" id="speedDisplayDisplay">0.8rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="legendSize">Game Legend/Footer</label>
                                <input type="range" id="legendSize" min="0.6" max="1.5" step="0.1" value="0.9">
                                <div class="speed-display" id="legendDisplay">0.9rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="numberInputSize">Number Inputs</label>
                                <input type="range" id="numberInputSize" min="0.4" max="1" step="0.1" value="0.8">
                                <div class="speed-display" id="numberInputDisplay">0.8rem</div>
                            </div>
                            
                            </div>
                        </div>

                        <!-- Character Customization -->
                        <div class="settings-section-compact settings-section-hidden" style="margin-bottom: 0.5rem;">
                            <div class="collapsible-title collapsed" id="charactersToggle" style="font-size: 0.7rem; margin-bottom: 0.3rem; color: #7FE9E1; cursor: pointer;">CHARACTERS</div>
                            <div class="collapsible-content collapsed" id="charactersContent">
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Empty Space Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="empty" data-callback="updateCharacterValue">·</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Empty Space Font Size:</span>
                                    <span class="param-value inline-editable" data-type="number" data-min="0.5" data-max="2.0" data-input-id="emptyCharSize" data-callback="updateNumericValue">1.6</span>x
                                </div>
                                <input type="range" id="emptyCharSize" min="0.5" max="2.0" step="0.1" value="1.6" style="display: none;">
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Cat Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="cat" data-callback="updateCharacterValue">C</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Mouse Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="mouse" data-callback="updateCharacterValue">M</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Obstacle Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="obstacle" data-callback="updateCharacterValue">O</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Cat Vision Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="unknown" data-callback="updateCharacterValue">?</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Mouse Vision Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="unknown" data-callback="updateCharacterValue">?</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Vision Collision Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="error" data-callback="updateCharacterValue">!</span>
                                </div>
                            </div>
                            
                            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #4B566A;">
                                <button class="btn btn-secondary" id="resetTypography">Reset to Defaults</button>
                            </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class LumonResearch {
            constructor() {
                this.gridWidth = 64;
                this.gridHeight = 32;
                this.grid = [];
                this.catPos = { x: 0, y: 0 };
                this.mousePos = { x: 0, y: 0 };
                this.obstacles = [];
                this.isTraining = false;
                this.isPaused = false;
                this.currentEpisode = 0;
                this.currentStep = 0;
                this.catWins = 0;
                this.mouseWins = 0;
                this.totalSteps = 0;
                this.episodeData = [];
                this.currentCatScore = 0;
                this.currentMouseScore = 0;
                
                // Generate obstacles once for entire training session
                this.generatePersistentObstacles();
                this.originalObstacles = JSON.parse(JSON.stringify(this.obstacles)); // Deep copy
                this.performanceChart = null;
                
                // Q-learning parameters
                this.catQTable = {};
                this.mouseQTable = {};
                
                // Individual learning parameters for cat and mouse
                this.catLearningRate = 0.11;
                this.mouseLearningRate = 0.12;
                this.catEpsilon = 0.35;
                this.mouseEpsilon = 0.25;
                this.catInitialEpsilon = 0.35;
                this.mouseInitialEpsilon = 0.25;
                
                // Shared parameters
                this.discountFactor = 0.95;
                this.minEpsilon = 0.05;
                this.epsilonDecay = 0.995;
                
                // Dynamic rotation for cone vision
                this.catRotation = 0;   // Current cat facing direction
                this.mouseRotation = 180; // Current mouse facing direction
                
                // User-configurable reward values
                this.rewards = {
                    catWin: 500,
                    catHunting: 8,
                    catExploration: 2,
                    catRetreating: -1,
                    catStandingStill: -0.1,
                    catFailure: -200,
                    mouseSurvival: 500,
                    mouseCaught: -500,
                    mouseStrategicEscape: 4,
                    mouseBlindEscape: 2,
                    mouseApproachingDanger: -2,
                    mouseStandingStillVisible: -0.5,
                    mouseMovingTowardDanger: -0.5
                };
                
                this.initializeEventListeners();
                this.initializeGrid();
                this.updateSpeedDisplay();
                this.updateVisionAngleDisplay();
                this.updateCatRotationDisplay();
                this.updateMouseRotationDisplay();
                this.updateCatLearningRate();
                this.updateCatEpsilon();
                this.updateMouseLearningRate();
                this.updateMouseEpsilon();
                this.updateWelcomeRewardDisplay(); // Initialize welcome page reward display
                this.updateButtonStates(); // Initialize button states
                this.updateCRTEffect(); // Initialize CRT effect
            }

            initializeEventListeners() {
                document.getElementById('startTraining').addEventListener('click', () => this.startTraining());
                document.getElementById('stopTraining').addEventListener('click', () => this.stopTraining());
                document.getElementById('continueTraining').addEventListener('click', () => this.continueTraining());
                document.getElementById('downloadTraining').addEventListener('click', () => this.downloadTraining());
                document.getElementById('uploadTrainingButton').addEventListener('click', () => this.triggerUpload());
                document.getElementById('simulationSpeed').addEventListener('input', () => this.updateSpeedDisplay());
                
                // Cone Vision Controls  
                document.getElementById('visionAngle').addEventListener('input', () => this.updateVisionAngleDisplay());
                
                // Individual Learning Parameter Controls
                document.getElementById('catLearningRateSlider').addEventListener('input', () => this.updateCatLearningRate());
                document.getElementById('catEpsilonSlider').addEventListener('input', () => this.updateCatEpsilon());
                document.getElementById('mouseLearningRateSlider').addEventListener('input', () => this.updateMouseLearningRate());
                document.getElementById('mouseEpsilonSlider').addEventListener('input', () => this.updateMouseEpsilon());
                
                // Reward Parameter Controls
                document.getElementById('catWinSlider').addEventListener('input', () => this.updateRewardParameter('catWin'));
                document.getElementById('catHuntingSlider').addEventListener('input', () => this.updateRewardParameter('catHunting'));
                document.getElementById('catExplorationSlider').addEventListener('input', () => this.updateRewardParameter('catExploration'));
                document.getElementById('catRetreatingSlider').addEventListener('input', () => this.updateRewardParameter('catRetreating'));
                document.getElementById('catStandingStillSlider').addEventListener('input', () => this.updateRewardParameter('catStandingStill'));
                document.getElementById('catFailureSlider').addEventListener('input', () => this.updateRewardParameter('catFailure'));
                document.getElementById('mouseSurvivalSlider').addEventListener('input', () => this.updateRewardParameter('mouseSurvival'));
                document.getElementById('mouseCaughtSlider').addEventListener('input', () => this.updateRewardParameter('mouseCaught'));
                document.getElementById('mouseStrategicEscapeSlider').addEventListener('input', () => this.updateRewardParameter('mouseStrategicEscape'));
                document.getElementById('mouseBlindEscapeSlider').addEventListener('input', () => this.updateRewardParameter('mouseBlindEscape'));
                document.getElementById('mouseApproachingDangerSlider').addEventListener('input', () => this.updateRewardParameter('mouseApproachingDanger'));
                document.getElementById('mouseStandingStillVisibleSlider').addEventListener('input', () => this.updateRewardParameter('mouseStandingStillVisible'));
                document.getElementById('mouseMovingTowardDangerSlider').addEventListener('input', () => this.updateRewardParameter('mouseMovingTowardDanger'));
                
                // Keyboard shortcut for settings (Ctrl+M)
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.key === 'm') {
                        e.preventDefault();
                        this.toggleSettingsVisibility();
                    }
                });
                document.getElementById('fontSize').addEventListener('input', () => this.updateFontSize());
                document.getElementById('horizontalSpacing').addEventListener('input', () => this.updateHorizontalSpacing());
                document.getElementById('verticalSpacing').addEventListener('input', () => this.updateVerticalSpacing());
                
                // CRT Controls
                const crtElements = [
                    'crtScanlines', 'crtGlow', 'crtPixels', 'crtContrast', 
                    'crtBrightness', 'crtSaturation', 'crtFlicker', 'crtNoise', 'crtWarp', 
                    'crtChromaticAberration', 'crtDistortion', 'crtVignette'
                ];
                crtElements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => this.updateCRTEffect());
                    }
                });
                
                const crtEnabled = document.getElementById('crtEnabled');
                if (crtEnabled) {
                    crtEnabled.addEventListener('change', () => this.updateCRTEffect());
                }
                
                // Text Pressure Controls
                document.getElementById('textPressureEnabled').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureRange').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureSmoothing').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureMinWeight').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureMaxWeight').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureMinOpacity').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureMaxOpacity').addEventListener('input', () => this.updateTextPressureSettings());
                
                // Text Effects Controls
                document.getElementById('textPressureBold').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureItalic').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureStrike').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureUnderline').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureScale').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureScaleMin').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureScaleMax').addEventListener('input', () => this.updateTextPressureSettings());
                
                // File upload handling - automatically load when file is selected
                document.getElementById('uploadTraining').addEventListener('change', (e) => {
                    const uploadButton = document.getElementById('uploadTrainingButton');
                    if (e.target.files.length > 0) {
                        uploadButton.textContent = 'Loading...';
                        this.uploadFile = e.target.files[0];
                        this.loadTraining(); // Automatically load the selected file
                    } else {
                        // Reset button if no file selected
                        uploadButton.textContent = 'Upload';
                        uploadButton.style.opacity = '1';
                    }
                });
                
                // Collapsible section handlers
                this.initializeCollapsibleSections();
                
                // Typography Controls
                this.initializeTypographyControls();
                
                // Initialize draggable panels
                this.initializeDraggablePanels();
                
                // Initialize custom slider progress
                this.initializeSliderProgress();
                
                // Initialize character customization
                this.initializeCharacterCustomization();
                
                // Initialize layout positioning
                this.initializeLayoutPositioning();
                
                // Initialize learning parameters
                this.initializeLearningParameters();
                
                // Initialize help popup
                this.initializeHelpPopup();
                
                // Initialize scramble text effect for footer
                this.initializeScrambleText();
                
                // Initialize inline editing
                this.initializeInlineEditing();
                
                // Chart close button
                document.getElementById('chartCloseBtn').addEventListener('click', () => {
                    document.getElementById('chartContainer').style.display = 'none';
                    if (this.isTraining && !this.isPaused) {
                        document.getElementById('gridView').style.display = 'flex';
                    } else {
                        document.getElementById('welcomeScreen').style.display = 'flex';
                    }
                });
            }

            initializeCollapsibleSections() {
                const accordionSections = [
                    { toggle: 'settingsToggle', content: 'settingsContent' },
                    { toggle: 'typographyToggle', content: 'typographyContent' },
                    { toggle: 'charactersToggle', content: 'charactersContent' },
                    { toggle: 'layoutToggle', content: 'layoutContent' },
                    { toggle: 'learningParametersToggle', content: 'learningParametersContent' },
                    { toggle: 'displayControlsToggle', content: 'displayControlsContent' },
                    { toggle: 'rewardsToggle', content: 'rewardsContent' }
                ];

                // Initialize accordion sections (only one open at a time)
                accordionSections.forEach(section => {
                    const toggle = document.getElementById(section.toggle);
                    const content = document.getElementById(section.content);
                    
                    if (toggle && content) {
                        // Use different height constraints based on section
                        const maxViewportHeight = section.content === 'settingsContent' ? 
                            window.innerHeight * 0.4 : window.innerHeight * 0.4;
                        const contentHeight = Math.min(content.scrollHeight, maxViewportHeight);
                        content.style.maxHeight = content.classList.contains('collapsed') ? '0px' : contentHeight + 'px';
                        
                        toggle.addEventListener('click', () => {
                            const isCollapsed = content.classList.contains('collapsed');
                            
                            if (isCollapsed) {
                                // Close all other accordion sections first
                                accordionSections.forEach(otherSection => {
                                    if (otherSection.toggle !== section.toggle) {
                                        const otherToggle = document.getElementById(otherSection.toggle);
                                        const otherContent = document.getElementById(otherSection.content);
                                        if (otherToggle && otherContent) {
                                            otherContent.classList.add('collapsed');
                                            otherToggle.classList.add('collapsed');
                                            otherContent.style.maxHeight = '0px';
                                        }
                                    }
                                });
                                
                                // Then expand current section
                                content.classList.remove('collapsed');
                                toggle.classList.remove('collapsed');
                                // Use different height constraints based on section
                                const maxViewportHeight = section.content === 'settingsContent' ? 
                                    window.innerHeight * 0.4 : window.innerHeight * 0.4;
                                const contentHeight = Math.min(content.scrollHeight, maxViewportHeight);
                                content.style.maxHeight = contentHeight + 'px';
                            } else {
                                // Collapse current section
                                content.classList.add('collapsed');
                                toggle.classList.add('collapsed');
                                content.style.maxHeight = '0px';
                            }
                        });
                    }
                });
            }

            initializeSliderProgress() {
                const sliders = document.querySelectorAll('input[type="range"]');
                
                const updateSliderProgress = (slider) => {
                    const value = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
                    slider.style.setProperty('--range-progress', `${value}%`);
                };
                
                sliders.forEach(slider => {
                    // Set initial progress
                    updateSliderProgress(slider);
                    
                    // Update progress on input
                    slider.addEventListener('input', () => updateSliderProgress(slider));
                    slider.addEventListener('change', () => updateSliderProgress(slider));
                });
            }

            initializeTypographyControls() {
                // Typography control definitions
                const typographyControls = [
                    { id: 'headerTitleSize', target: '.header h1', property: 'fontSize', display: 'headerTitleDisplay' },
                    { id: 'sectionTitleSize', target: '.section-title', property: 'fontSize', display: 'sectionTitleDisplay' },
                    { id: 'collapsibleTitleSize', target: '.collapsible-title', property: 'fontSize', display: 'collapsibleTitleDisplay' },
                    { id: 'subsectionSize', target: 'h4', property: 'fontSize', display: 'subsectionDisplay' },
                    { id: 'paramLabelSize', target: '.param-item label, .checkbox-item label', property: 'fontSize', display: 'paramLabelDisplay' },
                    { id: 'paramRowSize', target: '.param-row', property: 'fontSize', display: 'paramRowDisplay' },
                    { id: 'buttonSize', target: '.btn', property: 'fontSize', display: 'buttonDisplay' },
                    { id: 'statsSize', target: '.stat-row', property: 'fontSize', display: 'statsDisplay' },
                    { id: 'speedDisplaySize', target: '.speed-display', property: 'fontSize', display: 'speedDisplayDisplay' },
                    { id: 'legendSize', target: '.legend', property: 'fontSize', display: 'legendDisplay' },
                    { id: 'numberInputSize', target: '.param-row input[type="number"]', property: 'fontSize', display: 'numberInputDisplay' }
                ];

                // Initialize value display toggle
                const showValueDisplays = document.getElementById('showValueDisplays');
                const toggleValueDisplays = () => {
                    const displays = document.querySelectorAll('.speed-display');
                    displays.forEach(display => {
                        display.style.display = showValueDisplays.checked ? 'inline' : 'none';
                    });
                };
                
                // Set initial state (hidden by default)
                showValueDisplays.checked = false;
                toggleValueDisplays();
                showValueDisplays.addEventListener('change', toggleValueDisplays);

                // Grid character size control
                const gridCharSlider = document.getElementById('gridCharSize');
                const gridCharDisplay = document.getElementById('gridCharDisplay');
                if (gridCharSlider && gridCharDisplay) {
                    const updateGridCharSize = () => {
                        const value = parseFloat(gridCharSlider.value);
                        gridCharDisplay.textContent = value + 'rem';
                        
                        // Apply to grid characters
                        const grid = document.getElementById('gameGrid');
                        if (grid) {
                            grid.style.fontSize = value + 'rem';
                        }
                    };
                    
                    gridCharSlider.addEventListener('input', updateGridCharSize);
                    gridCharSlider.addEventListener('change', updateGridCharSize);
                    updateGridCharSize(); // Initialize
                }

                // Add event listeners for each control
                typographyControls.forEach(control => {
                    const slider = document.getElementById(control.id);
                    const display = document.getElementById(control.display);
                    
                    if (slider && display) {
                        const updateTypography = () => {
                            const value = parseFloat(slider.value);
                            display.textContent = value + 'rem';
                            
                            // Apply to all matching elements
                            const elements = document.querySelectorAll(control.target);
                            elements.forEach(element => {
                                element.style[control.property] = value + 'rem';
                            });
                        };
                        
                        slider.addEventListener('input', updateTypography);
                        slider.addEventListener('change', updateTypography);
                        
                        // Initialize current values
                        updateTypography();
                    }
                });

                // Reset button functionality
                const resetButton = document.getElementById('resetTypography');
                if (resetButton) {
                    resetButton.addEventListener('click', () => {
                        typographyControls.forEach(control => {
                            const slider = document.getElementById(control.id);
                            if (slider) {
                                // Reset to current default values
                                const defaults = {
                                    'headerTitleSize': 5.7,
                                    'sectionTitleSize': 1.4,
                                    'collapsibleTitleSize': 0.9,
                                    'subsectionSize': 1.0,
                                    'paramLabelSize': 0.7,
                                    'paramRowSize': 0.8,
                                    'buttonSize': 0.7,
                                    'statsSize': 0.8,
                                    'speedDisplaySize': 0.8,
                                    'legendSize': 0.9,
                                    'numberInputSize': 0.8
                                };
                                
                                slider.value = defaults[control.id] || 1;
                                slider.dispatchEvent(new Event('input'));
                            }
                        });
                    });
                }
            }

            initializeCharacterCustomization() {
                // Store default character mappings
                this.characterMap = {
                    empty: '·',
                    cat: 'C',
                    mouse: 'M',
                    obstacle: 'O',
                    unknown: '?',
                    error: '!'
                };
                
                // Initialize empty space font size
                this.emptyCharSize = 1.6;
                
                // Empty space font size control (hidden input for updateEmptyCharFontSize)
                const emptyCharSizeInput = document.getElementById('emptyCharSize');
                if (emptyCharSizeInput) {
                    emptyCharSizeInput.addEventListener('input', () => {
                        this.emptyCharSize = parseFloat(emptyCharSizeInput.value);
                        this.updateEmptyCharFontSize();
                    });
                }
            }

            updateLegend() {
                const legend = document.querySelector('.legend');
                if (legend) {
                    // Create the new content matching the original legend format
                    const newContent = `<span class="cat">${this.characterMap.cat || 'C'}: CAT</span> | <span class="mouse">${this.characterMap.mouse || 'M'}: MOUSE</span> | <span class="obstacle">${this.characterMap.obstacle || 'O'}: OBSTACLE</span> | <span class="cat-vision">${this.characterMap.unknown || '?'}: VISION</span> | <span class="mouse-vision">${this.characterMap.error || '!'}: COLLISION</span>`;
                    
                    // Update the content and preserve scramble structure
                    legend.innerHTML = newContent.trim();
                    
                    // Re-initialize scramble text for the updated content
                    this.reinitializeScrambleText(legend);
                }
            }
            
            reinitializeScrambleText(legend) {
                // Extract text content while preserving structure
                const textContent = legend.textContent;
                let charHTML = '';
                
                for (let i = 0; i < textContent.length; i++) {
                    const char = textContent[i];
                    // Don't wrap spaces, pipes, or colons in spans to preserve natural spacing
                    if (char === ' ' || char === '|' || char === ':') {
                        charHTML += char;
                    } else {
                        charHTML += `<span class="scramble-char" data-original="${char}">${char}</span>`;
                    }
                }
                
                legend.innerHTML = charHTML;
            }
            
            updateEmptyCharFontSize() {
                const grid = document.querySelector('.grid');
                if (grid) {
                    // Create a CSS rule to scale empty characters
                    const style = document.createElement('style');
                    style.textContent = `
                        .grid .empty-char {
                            font-size: ${this.emptyCharSize}em !important;
                            display: inline-block;
                            vertical-align: baseline;
                        }
                    `;
                    
                    // Remove any existing style with the same purpose
                    const existing = document.getElementById('empty-char-style');
                    if (existing) {
                        existing.remove();
                    }
                    
                    style.id = 'empty-char-style';
                    document.head.appendChild(style);
                    
                    // Re-render the grid to apply the new class
                    if (this.gameGrid && this.gameGrid.length > 0) {
                        this.renderGrid();
                    }
                }
            }
            
            initializeLayoutPositioning() {
                // Header positioning
                const headerPosSlider = document.getElementById('headerVerticalPos');
                const headerPosDisplay = document.getElementById('headerPosDisplay');
                if (headerPosSlider && headerPosDisplay) {
                    const updateHeaderPosition = () => {
                        const value = parseInt(headerPosSlider.value);
                        headerPosDisplay.textContent = `${value}px`;
                        document.querySelector('.header').style.marginTop = `${value}px`;
                    };
                    headerPosSlider.addEventListener('input', updateHeaderPosition);
                    headerPosSlider.addEventListener('change', updateHeaderPosition);
                    updateHeaderPosition(); // Set initial value
                }
                
                // Left panel positioning  
                const leftPanelPosSlider = document.getElementById('leftPanelVerticalPos');
                const leftPanelPosDisplay = document.getElementById('leftPanelPosDisplay');
                if (leftPanelPosSlider && leftPanelPosDisplay) {
                    const updateLeftPanelPosition = () => {
                        const value = parseInt(leftPanelPosSlider.value);
                        leftPanelPosDisplay.textContent = `${value}px`;
                        document.querySelector('.control-center').style.marginTop = `${value - 165}px`;
                    };
                    leftPanelPosSlider.addEventListener('input', updateLeftPanelPosition);
                    leftPanelPosSlider.addEventListener('change', updateLeftPanelPosition);
                    updateLeftPanelPosition(); // Set initial value
                }
                
                // Right panel positioning
                const rightPanelPosSlider = document.getElementById('rightPanelVerticalPos');
                const rightPanelPosDisplay = document.getElementById('rightPanelPosDisplay');
                if (rightPanelPosSlider && rightPanelPosDisplay) {
                    const updateRightPanelPosition = () => {
                        const value = parseInt(rightPanelPosSlider.value);
                        rightPanelPosDisplay.textContent = `${value}px`;
                        document.querySelector('.analytics-panel').style.marginTop = `${value - 165}px`;
                    };
                    rightPanelPosSlider.addEventListener('input', updateRightPanelPosition);
                    rightPanelPosSlider.addEventListener('change', updateRightPanelPosition);
                    updateRightPanelPosition(); // Set initial value
                }
                
                // Center panel positioning
                const centerPanelPosSlider = document.getElementById('centerPanelVerticalPos');
                const centerPanelPosDisplay = document.getElementById('centerPanelPosDisplay');
                if (centerPanelPosSlider && centerPanelPosDisplay) {
                    const updateCenterPanelPosition = () => {
                        const value = parseInt(centerPanelPosSlider.value);
                        centerPanelPosDisplay.textContent = `${value}px`;
                        document.querySelector('.simulation-view').style.marginTop = `${value}px`;
                    };
                    centerPanelPosSlider.addEventListener('input', updateCenterPanelPosition);
                    centerPanelPosSlider.addEventListener('change', updateCenterPanelPosition);
                    updateCenterPanelPosition(); // Set initial value
                }
                
                // Footer positioning
                const footerPosSlider = document.getElementById('footerVerticalPos');
                const footerPosDisplay = document.getElementById('footerPosDisplay');
                if (footerPosSlider && footerPosDisplay) {
                    const updateFooterPosition = () => {
                        const value = parseInt(footerPosSlider.value);
                        footerPosDisplay.textContent = `${value}rem`;
                        document.querySelector('.footer-container').style.bottom = `${value}rem`;
                    };
                    footerPosSlider.addEventListener('input', updateFooterPosition);
                    footerPosSlider.addEventListener('change', updateFooterPosition);
                    updateFooterPosition(); // Set initial value
                }
                
            }
            
            initializeLearningParameters() {
                // AI Learning Parameters
                const learningRateSlider = document.getElementById('learningRateSlider');
                const learningRateDisplay = document.getElementById('learningRateDisplay');
                if (learningRateSlider && learningRateDisplay) {
                    const updateLearningRate = () => {
                        const value = parseFloat(learningRateSlider.value);
                        learningRateDisplay.textContent = value.toFixed(2);
                        this.learningRate = value;
                    };
                    
                    // Enhanced live feedback during dragging
                    learningRateSlider.addEventListener('input', (e) => {
                        updateLearningRate();
                        // Add visual feedback while dragging
                        learningRateDisplay.style.transform = 'scale(1.1)';
                        learningRateDisplay.style.color = '#00ff00';
                        setTimeout(() => {
                            learningRateDisplay.style.transform = 'scale(1)';
                            learningRateDisplay.style.color = '';
                        }, 150);
                    });
                    learningRateSlider.addEventListener('change', updateLearningRate);
                    updateLearningRate();
                }
                
                const epsilonSlider = document.getElementById('epsilonSlider');
                const epsilonDisplay = document.getElementById('epsilonDisplay');
                if (epsilonSlider && epsilonDisplay) {
                    const updateEpsilon = () => {
                        const value = parseFloat(epsilonSlider.value);
                        epsilonDisplay.textContent = value.toFixed(2);
                        this.initialEpsilon = value;
                        this.epsilon = value;
                    };
                    
                    // Enhanced live feedback during dragging
                    epsilonSlider.addEventListener('input', (e) => {
                        updateEpsilon();
                        epsilonDisplay.style.transform = 'scale(1.1)';
                        epsilonDisplay.style.color = '#00ff00';
                        setTimeout(() => {
                            epsilonDisplay.style.transform = 'scale(1)';
                            epsilonDisplay.style.color = '';
                        }, 150);
                    });
                    epsilonSlider.addEventListener('change', updateEpsilon);
                    updateEpsilon();
                }
                
                const discountFactorSlider = document.getElementById('discountFactorSlider');
                const discountFactorDisplay = document.getElementById('discountFactorDisplay');
                if (discountFactorSlider && discountFactorDisplay) {
                    const updateDiscountFactor = () => {
                        const value = parseFloat(discountFactorSlider.value);
                        discountFactorDisplay.textContent = value.toFixed(2);
                        this.discountFactor = value;
                    };
                    
                    // Enhanced live feedback during dragging
                    discountFactorSlider.addEventListener('input', (e) => {
                        updateDiscountFactor();
                        discountFactorDisplay.style.transform = 'scale(1.1)';
                        discountFactorDisplay.style.color = '#00ff00';
                        setTimeout(() => {
                            discountFactorDisplay.style.transform = 'scale(1)';
                            discountFactorDisplay.style.color = '';
                        }, 150);
                    });
                    discountFactorSlider.addEventListener('change', updateDiscountFactor);
                    updateDiscountFactor();
                }
                
                const epsilonDecaySlider = document.getElementById('epsilonDecaySlider');
                const epsilonDecayDisplay = document.getElementById('epsilonDecayDisplay');
                if (epsilonDecaySlider && epsilonDecayDisplay) {
                    const updateEpsilonDecay = () => {
                        const value = parseFloat(epsilonDecaySlider.value);
                        epsilonDecayDisplay.textContent = value.toFixed(3);
                        this.epsilonDecay = value;
                    };
                    
                    // Enhanced live feedback during dragging
                    epsilonDecaySlider.addEventListener('input', (e) => {
                        updateEpsilonDecay();
                        epsilonDecayDisplay.style.transform = 'scale(1.1)';
                        epsilonDecayDisplay.style.color = '#00ff00';
                        setTimeout(() => {
                            epsilonDecayDisplay.style.transform = 'scale(1)';
                            epsilonDecayDisplay.style.color = '';
                        }, 150);
                    });
                    epsilonDecaySlider.addEventListener('change', updateEpsilonDecay);
                    updateEpsilonDecay();
                }
            }
            
            initializeHelpPopup() {
                const helpOverlay = document.getElementById('helpOverlay');
                const helpPopup = document.getElementById('helpPopup');
                const helpCloseBtn = document.getElementById('helpCloseBtn');
                const welcomeHelpTrigger = document.getElementById('welcomeHelpTrigger');
                const controlHelpTrigger = null; // Removed help functionality from learning parameters
                
                const showHelp = () => {
                    helpOverlay.style.display = 'block';
                    helpPopup.style.display = 'block';
                };
                
                const hideHelp = () => {
                    helpOverlay.style.display = 'none';
                    helpPopup.style.display = 'none';
                };
                
                // Add click handlers
                if (welcomeHelpTrigger) {
                    welcomeHelpTrigger.addEventListener('click', showHelp);
                }
                
                if (controlHelpTrigger) {
                    controlHelpTrigger.addEventListener('click', showHelp);
                }
                
                // Close handlers
                if (helpCloseBtn) {
                    helpCloseBtn.addEventListener('click', hideHelp);
                }
                
                if (helpOverlay) {
                    helpOverlay.addEventListener('click', hideHelp);
                }
                
                // ESC key handler
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && helpPopup.style.display === 'block') {
                        hideHelp();
                    }
                });
            }
            
            initializeScrambleText() {
                const legend = document.querySelector('.legend');
                if (!legend) return;
                
                // Split legend text into spans for each character, but preserve spaces and separators
                const originalHTML = legend.innerHTML;
                legend.dataset.originalContent = originalHTML;
                
                // Extract text content while preserving structure
                const textContent = legend.textContent;
                let charHTML = '';
                
                for (let i = 0; i < textContent.length; i++) {
                    const char = textContent[i];
                    // Don't wrap spaces, pipes, or colons in spans to preserve natural spacing
                    if (char === ' ' || char === '|' || char === ':') {
                        charHTML += char;
                    } else {
                        charHTML += `<span class="scramble-char" data-original="${char}">${char}</span>`;
                    }
                }
                
                legend.innerHTML = charHTML;
                
                // Add scramble effect on mouse move
                legend.addEventListener('pointermove', (e) => {
                    this.handleScrambleEffect(e, legend);
                });
            }
            
            handleScrambleEffect(e, element) {
                const chars = element.querySelectorAll('.scramble-char');
                const radius = 300;
                const scrambleChars = '.:';
                const duration = 5000;
                
                chars.forEach(char => {
                    const rect = char.getBoundingClientRect();
                    const charCenterX = rect.left + rect.width / 2;
                    const charCenterY = rect.top + rect.height / 2;
                    
                    const dx = e.clientX - charCenterX;
                    const dy = e.clientY - charCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < radius) {
                        const intensity = 1 - (distance / radius);
                        this.scrambleCharacter(char, intensity, scrambleChars, duration);
                    }
                });
            }
            
            scrambleCharacter(charElement, intensity, scrambleChars, duration) {
                // Prevent multiple scrambles on the same character
                if (charElement.isScrambling) return;
                
                const original = charElement.dataset.original;
                const scrambleLength = Math.floor(intensity * 3) + 1; // Reduced scramble cycles
                
                charElement.isScrambling = true;
                let scrambleCount = 0;
                const maxScrambles = scrambleLength;
                const intervalDelay = 80; // More fluid animation speed
                
                const scrambleInterval = setInterval(() => {
                    if (scrambleCount < maxScrambles) {
                        const randomChar = scrambleChars[Math.floor(Math.random() * scrambleChars.length)];
                        charElement.textContent = randomChar;
                        scrambleCount++;
                    } else {
                        charElement.textContent = original;
                        charElement.isScrambling = false;
                        clearInterval(scrambleInterval);
                    }
                }, intervalDelay);
            }
            
            initHeaderScrambleEffect() {
                const header = document.querySelector('.header h1');
                if (!header) return;
                
                const text = header.textContent;
                let charHTML = '';
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    // Don't wrap spaces in spans to preserve natural spacing
                    if (char === ' ') {
                        charHTML += char;
                    } else {
                        charHTML += `<span class="scramble-char" data-original="${char}">${char}</span>`;
                    }
                }
                
                header.innerHTML = charHTML;
                
                // Add scramble effect on mouse move
                header.addEventListener('pointermove', (e) => {
                    this.handleScrambleEffect(e, header);
                });
            }
            
            initializeInlineEditing() {
                // Add inline editing to all editable elements
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('inline-editable')) {
                        this.startInlineEdit(e.target);
                    }
                });
            }
            
            startInlineEdit(element) {
                if (element.classList.contains('editing')) return;
                
                const originalValue = element.textContent;
                const dataType = element.dataset.type || 'text';
                const maxLength = element.dataset.maxlength || (dataType === 'char' ? 1 : 10);
                
                element.classList.add('editing');
                element.contentEditable = true;
                element.style.outline = '1px solid #7FE9E1';
                element.style.background = 'rgba(127, 233, 225, 0.1)';
                
                // Select all text
                const range = document.createRange();
                range.selectNodeContents(element);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
                
                const finishEdit = () => {
                    element.classList.remove('editing');
                    element.contentEditable = false;
                    element.style.outline = '';
                    element.style.background = '';
                    
                    let newValue = element.textContent.trim();
                    
                    // Validate based on data type
                    if (dataType === 'char' && newValue.length > 1) {
                        newValue = newValue.charAt(0);
                    } else if (dataType === 'number') {
                        const numValue = parseFloat(newValue);
                        if (isNaN(numValue)) {
                            newValue = originalValue;
                        } else {
                            const min = parseFloat(element.dataset.min || 0);
                            const max = parseFloat(element.dataset.max || 1000);
                            newValue = Math.max(min, Math.min(max, numValue)).toString();
                        }
                    }
                    
                    element.textContent = newValue;
                    
                    // Trigger update callback if it exists
                    const updateCallback = element.dataset.callback;
                    if (updateCallback && this[updateCallback]) {
                        this[updateCallback](element, newValue, originalValue);
                    }
                };
                
                // Finish editing on Enter or loss of focus
                const handleKeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        finishEdit();
                        element.removeEventListener('keydown', handleKeydown);
                        element.removeEventListener('blur', handleBlur);
                    } else if (e.key === 'Escape') {
                        element.textContent = originalValue;
                        finishEdit();
                        element.removeEventListener('keydown', handleKeydown);
                        element.removeEventListener('blur', handleBlur);
                    }
                };
                
                const handleBlur = () => {
                    finishEdit();
                    element.removeEventListener('keydown', handleKeydown);
                    element.removeEventListener('blur', handleBlur);
                };
                
                element.addEventListener('keydown', handleKeydown);
                element.addEventListener('blur', handleBlur);
            }
            
            // Callback functions for different types of edits
            updateCharacterValue(element, newValue, originalValue) {
                const charType = element.dataset.charType;
                if (charType && this.characterMap[charType] !== undefined) {
                    this.characterMap[charType] = newValue;
                    this.updateLegend();
                    if (this.gameGrid && this.gameGrid.length > 0) {
                        this.renderGrid();
                    }
                }
            }
            
            updateNumericValue(element, newValue, originalValue) {
                const inputId = element.dataset.inputId;
                if (inputId) {
                    const input = document.getElementById(inputId);
                    if (input) {
                        input.value = newValue;
                        // Trigger the input event to update any related functionality
                        input.dispatchEvent(new Event('input'));
                        input.dispatchEvent(new Event('change'));
                        
                        // Special handling for specific controls
                        if (inputId === 'fontSize') {
                            this.updateFontSize();
                        } else if (inputId === 'horizontalSpacing') {
                            this.updateHorizontalSpacing();
                        } else if (inputId === 'verticalSpacing') {
                            this.updateVerticalSpacing();
                        } else if (inputId === 'emptyCharSize') {
                            // Update the display element if it exists
                            const sizeDisplay = document.querySelector('[data-input-id="emptyCharSize"]');
                            if (sizeDisplay) {
                                sizeDisplay.textContent = parseFloat(newValue).toFixed(1);
                            }
                            this.emptyCharSize = parseFloat(newValue);
                            this.updateEmptyCharFontSize();
                        } else if (inputId === 'obstacleCount') {
                            // Regenerate obstacles when count changes
                            if (!this.isTraining) {
                                this.generatePersistentObstacles();
                                this.originalObstacles = JSON.parse(JSON.stringify(this.obstacles));
                                this.placeAgentsAndObstacles();
                                this.renderGrid();
                            }
                        }
                    }
                }
            }

            initializeDraggablePanels() {
                const draggablePanels = document.querySelectorAll('.draggable-panel');
                
                draggablePanels.forEach(panel => {
                    let isDragging = false;
                    let offsetX = 0;
                    let offsetY = 0;
                    let originalParent = null;
                    let originalPosition = null;
                    
                    panel.addEventListener('mousedown', (e) => {
                        // Only start dragging if clicking on the title area
                        if (e.target.classList.contains('section-title') || e.target.closest('.section-title')) {
                            isDragging = true;
                            panel.classList.add('dragging');
                            
                            // Store original position and parent
                            originalParent = panel.parentNode;
                            originalPosition = {
                                position: panel.style.position,
                                top: panel.style.top,
                                left: panel.style.left,
                                width: panel.style.width,
                                height: panel.style.height
                            };
                            
                            // Calculate offset from mouse to panel corner
                            const rect = panel.getBoundingClientRect();
                            offsetX = e.clientX - rect.left;
                            offsetY = e.clientY - rect.top;
                            
                            // Convert to fixed positioning
                            panel.style.position = 'fixed';
                            panel.style.left = rect.left + 'px';
                            panel.style.top = rect.top + 'px';
                            panel.style.width = rect.width + 'px';
                            panel.style.height = rect.height + 'px';
                            panel.style.zIndex = '1000';
                            
                            e.preventDefault();
                        }
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (isDragging && panel.classList.contains('dragging')) {
                            panel.style.left = (e.clientX - offsetX) + 'px';
                            panel.style.top = (e.clientY - offsetY) + 'px';
                        }
                    });
                    
                    document.addEventListener('mouseup', () => {
                        if (isDragging) {
                            isDragging = false;
                            panel.classList.remove('dragging');
                            
                            // Option to restore to original position (double-click title to reset)
                            let resetTimeout = setTimeout(() => {
                                // Keep in dragged position
                            }, 300);
                        }
                    });
                    
                    // Double-click title to reset position
                    const title = panel.querySelector('.section-title');
                    if (title) {
                        title.addEventListener('dblclick', () => {
                            // Reset to original position
                            panel.style.position = originalPosition.position;
                            panel.style.top = originalPosition.top;
                            panel.style.left = originalPosition.left;
                            panel.style.width = originalPosition.width;
                            panel.style.height = originalPosition.height;
                            panel.style.zIndex = '';
                            
                            // Re-attach to original parent if needed
                            if (originalParent && !originalParent.contains(panel)) {
                                originalParent.appendChild(panel);
                            }
                        });
                    }
                });
            }

            updateSpeedDisplay() {
                const speedInput = document.getElementById('simulationSpeed');
                const display = document.getElementById('speedDisplay');
                
                if (!speedInput || !display) return;
                
                const speed = parseInt(speedInput.value);
                display.textContent = speed + 'ms';
            }
            
            updateVisionAngleDisplay() {
                const angle = document.getElementById('visionAngle').value;
                const display = document.getElementById('visionAngleDisplay');
                if (display) display.textContent = `${angle}°`;
            }
            
            updateCatRotationDisplay() {
                const rotation = parseInt(document.getElementById('catRotation').value);
                const display = document.getElementById('catRotationDisplay');
                const directions = {
                    0: "Right", 45: "Down-Right", 90: "Down", 135: "Down-Left",
                    180: "Left", 225: "Up-Left", 270: "Up", 315: "Up-Right", 360: "Right"
                };
                if (display) display.textContent = `${rotation}° (${directions[rotation] || "Custom"})`;
                
                // Update internal rotation when user changes slider
                this.catRotation = rotation;
            }
            
            updateMouseRotationDisplay() {
                const rotation = parseInt(document.getElementById('mouseRotation').value);
                const display = document.getElementById('mouseRotationDisplay');
                const directions = {
                    0: "Right", 45: "Down-Right", 90: "Down", 135: "Down-Left",
                    180: "Left", 225: "Up-Left", 270: "Up", 315: "Up-Right", 360: "Right"
                };
                if (display) display.textContent = `${rotation}° (${directions[rotation] || "Custom"})`;
                
                // Update internal rotation when user changes slider
                this.mouseRotation = rotation;
            }
            
            updateCatLearningRate() {
                const slider = document.getElementById('catLearningRateSlider');
                const display = document.getElementById('catLearningRateDisplay');
                if (slider && display) {
                    const value = parseFloat(slider.value);
                    display.textContent = value.toFixed(2);
                    this.catLearningRate = value;
                }
            }
            
            updateCatEpsilon() {
                const slider = document.getElementById('catEpsilonSlider');
                const display = document.getElementById('catEpsilonDisplay');
                if (slider && display) {
                    const value = parseFloat(slider.value);
                    display.textContent = value.toFixed(2);
                    this.catEpsilon = value;
                    this.catInitialEpsilon = value;
                }
            }
            
            updateMouseLearningRate() {
                const slider = document.getElementById('mouseLearningRateSlider');
                const display = document.getElementById('mouseLearningRateDisplay');
                if (slider && display) {
                    const value = parseFloat(slider.value);
                    display.textContent = value.toFixed(2);
                    this.mouseLearningRate = value;
                }
            }
            
            updateMouseEpsilon() {
                const slider = document.getElementById('mouseEpsilonSlider');
                const display = document.getElementById('mouseEpsilonDisplay');
                if (slider && display) {
                    const value = parseFloat(slider.value);
                    display.textContent = value.toFixed(2);
                    this.mouseEpsilon = value;
                    this.mouseInitialEpsilon = value;
                }
            }
            
            updateRewardParameter(paramName) {
                const slider = document.getElementById(paramName + 'Slider');
                const display = document.getElementById(paramName + 'Display');
                if (slider && display) {
                    const value = parseFloat(slider.value);
                    display.textContent = value;
                    this.rewards[paramName] = value;
                    this.updateWelcomeRewardDisplay();
                }
            }
            
            updateWelcomeRewardDisplay() {
                // Update Cat rewards in welcome page
                const welcomeCatRewards = document.getElementById('welcomeCatRewards');
                if (welcomeCatRewards) {
                    welcomeCatRewards.textContent = `• Win: +${this.rewards.catWin} | Failure: ${this.rewards.catFailure} | Hunting: +${this.rewards.catHunting} | Exploration: +${this.rewards.catExploration}`;
                }
                
                const welcomeCatPenalties = document.getElementById('welcomeCatPenalties');
                if (welcomeCatPenalties) {
                    welcomeCatPenalties.textContent = `• Retreating: ${this.rewards.catRetreating} | Standing still: ${this.rewards.catStandingStill}`;
                }
                
                // Update Mouse rewards in welcome page
                const welcomeMouseRewards = document.getElementById('welcomeMouseRewards');
                if (welcomeMouseRewards) {
                    welcomeMouseRewards.textContent = `• Survival: +${this.rewards.mouseSurvival} | Caught: ${this.rewards.mouseCaught} | Strategic escape: +${this.rewards.mouseStrategicEscape} | Blind escape: +${this.rewards.mouseBlindEscape}`;
                }
                
                const welcomeMousePenalties = document.getElementById('welcomeMousePenalties');
                if (welcomeMousePenalties) {
                    welcomeMousePenalties.textContent = `• Approaching danger: ${this.rewards.mouseApproachingDanger} | Moving toward danger: ${this.rewards.mouseMovingTowardDanger} | Standing still (visible): ${this.rewards.mouseStandingStillVisible}`;
                }
            }

            updateFontSize() {
                const fontSize = parseFloat(document.getElementById('fontSize').value);
                const display = document.getElementById('fontSizeDisplay');
                const grid = document.getElementById('gameGrid');
                
                display.textContent = fontSize.toFixed(1) + 'rem';
                grid.style.fontSize = fontSize + 'rem';
            }

            updateHorizontalSpacing() {
                const spacing = parseFloat(document.getElementById('horizontalSpacing').value);
                const display = document.getElementById('horizontalSpacingDisplay');
                const grid = document.getElementById('gameGrid');
                
                display.textContent = spacing.toFixed(1) + 'rem';
                grid.style.letterSpacing = spacing + 'rem';
            }

            updateVerticalSpacing() {
                const spacing = parseFloat(document.getElementById('verticalSpacing').value);
                const display = document.getElementById('verticalSpacingDisplay');
                const grid = document.getElementById('gameGrid');
                
                display.textContent = spacing.toFixed(1) + 'rem';
                grid.style.lineHeight = spacing + 'rem';
            }
            
            updateCRTEffect() {
                const enabledEl = document.getElementById('crtEnabled');
                const enabled = enabledEl ? enabledEl.checked : false;
                
                // Get all CRT parameters
                const scanlines = this.getCRTValue('crtScanlines', 0.9);
                const glow = this.getCRTValue('crtGlow', 0.7);
                const contrast = this.getCRTValue('crtContrast', 0.9);
                const brightness = this.getCRTValue('crtBrightness', 1.05);
                const saturation = this.getCRTValue('crtSaturation', 1.1);
                const flicker = this.getCRTValue('crtFlicker', 0.8);
                const noise = this.getCRTValue('crtNoise', 0.7);
                const warp = this.getCRTValue('crtWarp', 0);
                const chromaticAberration = this.getCRTValue('crtChromaticAberration', 8);
                const distortion = this.getCRTValue('crtDistortion', 7.5);
                const vignette = this.getCRTValue('crtVignette', 3.5);
                
                // Update displays
                this.updateCRTDisplays({
                    scanlines, glow, contrast, brightness, saturation, 
                    flicker, noise, warp, chromaticAberration, distortion, vignette
                });
                
                if (!enabled) {
                    this.disableCRTEffects();
                    return;
                }
                
                // Apply shader-like CRT effects
                this.applyCRTShaderEffects({
                    scanlines, glow, contrast, brightness, saturation,
                    flicker, noise, warp, chromaticAberration, distortion, vignette
                });
            }
            
            getCRTValue(id, defaultValue) {
                const el = document.getElementById(id);
                return el ? parseFloat(el.value) : defaultValue;
            }
            
            updateCRTDisplays(values) {
                const displays = {
                    'scanlinesDisplay': values.scanlines,
                    'glowDisplay': values.glow,
                    'contrastDisplay': values.contrast,
                    'brightnessDisplay': values.brightness,
                    'saturationDisplay': values.saturation,
                    'flickerDisplay': values.flicker,
                    'noiseDisplay': values.noise,
                    'warpDisplay': values.warp,
                    'chromaticDisplay': values.chromaticAberration,
                    'distortionDisplay': values.distortion,
                    'vignetteDisplay': values.vignette
                };
                
                Object.entries(displays).forEach(([id, value]) => {
                    const display = document.getElementById(id);
                    if (display) {
                        display.textContent = (id === 'brightnessDisplay') ? 
                            value.toFixed(2) : value.toFixed(1);
                    }
                });
            }
            
            disableCRTEffects() {
                const overlay = document.querySelector('.crt-overlay');
                const container = document.querySelector('.container');
                const canvas = document.getElementById('crtCanvas');
                
                if (overlay) overlay.style.display = 'none';
                if (container) container.classList.remove('crt-screen');
                if (canvas) canvas.style.display = 'none';
                
                // Clear intervals
                if (this.noiseInterval) {
                    clearInterval(this.noiseInterval);
                    this.noiseInterval = null;
                }
                if (this.crtAnimationFrame) {
                    cancelAnimationFrame(this.crtAnimationFrame);
                    this.crtAnimationFrame = null;
                }
            }
            
            applyCRTShaderEffects(params) {
                const overlay = document.querySelector('.crt-overlay');
                const container = document.querySelector('.container');
                const canvas = document.getElementById('crtCanvas');
                
                if (overlay) overlay.style.display = 'block';
                if (container) container.classList.add('crt-screen');
                
                // Apply CSS-based effects
                this.applyCSSEffects(container, params);
                
                // Start shader-like canvas effects
                if (canvas) {
                    canvas.style.display = 'block';
                    this.startCRTShaderAnimation(canvas, params);
                }
            }
            
            applyCSSEffects(container, params) {
                if (!container) return;
                
                // Apply filter effects
                container.style.filter = `
                    contrast(${params.contrast}) 
                    brightness(${params.brightness}) 
                    saturate(${params.saturation})
                `;
                
                // Apply fisheye warp effect
                if (params.warp > 0) {
                    const fisheyeIntensity = params.warp * 0.05;
                    const borderRadius = 15 + (params.warp * 8);
                    const perspectiveValue = 1000 - (params.warp * 50);
                    const scaleValue = 1 + (params.warp * 0.02);
                    
                    container.classList.add('crt-monitor-curve');
                    container.style.transform = `
                        perspective(${perspectiveValue}px) 
                        rotateX(${fisheyeIntensity * 3}deg) 
                        scale(${scaleValue})
                    `;
                    container.style.borderRadius = `${borderRadius}px ${borderRadius}px ${borderRadius + 5}px ${borderRadius + 5}px`;
                } else {
                    container.classList.remove('crt-monitor-curve');
                    container.style.transform = 'none';
                    container.style.borderRadius = '0px';
                }
            }
            
            startCRTShaderAnimation(canvas, params) {
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                const animate = (time) => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Apply shader-like effects
                    this.renderCRTEffects(ctx, canvas, params, time);
                    
                    this.crtAnimationFrame = requestAnimationFrame(animate);
                };
                
                if (this.crtAnimationFrame) {
                    cancelAnimationFrame(this.crtAnimationFrame);
                }
                this.crtAnimationFrame = requestAnimationFrame(animate);
            }
            
            renderCRTEffects(ctx, canvas, params, time) {
                const width = canvas.width;
                const height = canvas.height;
                
                // Scanlines
                if (params.scanlines > 0) {
                    ctx.globalAlpha = params.scanlines * 0.1;
                    ctx.fillStyle = '#000000';
                    for (let y = 0; y < height; y += 3) {
                        ctx.fillRect(0, y, width, 1);
                    }
                }
                
                // Static noise
                if (params.noise > 0) {
                    const imageData = ctx.createImageData(width, height);
                    const data = imageData.data;
                    const noiseIntensity = params.noise * 25;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const noise = Math.random() * noiseIntensity;
                        data[i] = noise;     // Red
                        data[i + 1] = noise; // Green  
                        data[i + 2] = noise; // Blue
                        data[i + 3] = noise; // Alpha
                    }
                    
                    ctx.globalAlpha = 0.05;
                    ctx.putImageData(imageData, 0, 0);
                }
                
                // Flicker
                if (params.flicker > 0) {
                    const flickerAmount = Math.sin(time * 0.12) * params.flicker * 0.1;
                    ctx.globalAlpha = Math.abs(flickerAmount);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, width, height);
                }
                
                // Vignette
                if (params.vignette > 0) {
                    const gradient = ctx.createRadialGradient(
                        width / 2, height / 2, 0,
                        width / 2, height / 2, Math.max(width, height) * 0.6
                    );
                    gradient.addColorStop(0, 'rgba(0,0,0,0)');
                    gradient.addColorStop(1, `rgba(0,0,0,${params.vignette * 0.08})`);
                    
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                }
                
                ctx.globalAlpha = 1;
            }
            

            updateTextPressureSettings() {
                const enabled = document.getElementById('textPressureEnabled').checked;
                const range = parseInt(document.getElementById('textPressureRange').value);
                const smoothing = parseInt(document.getElementById('textPressureSmoothing').value);
                const minWeight = parseInt(document.getElementById('textPressureMinWeight').value);
                const maxWeight = parseInt(document.getElementById('textPressureMaxWeight').value);
                const minOpacity = parseFloat(document.getElementById('textPressureMinOpacity').value);
                const maxOpacity = parseFloat(document.getElementById('textPressureMaxOpacity').value);
                
                // Text Effects
                const boldEffect = document.getElementById('textPressureBold').checked;
                const italicEffect = document.getElementById('textPressureItalic').checked;
                const strikeEffect = document.getElementById('textPressureStrike').checked;
                const underlineEffect = document.getElementById('textPressureUnderline').checked;
                const scaleEffect = document.getElementById('textPressureScale').checked;
                const scaleMin = parseFloat(document.getElementById('textPressureScaleMin').value);
                const scaleMax = parseFloat(document.getElementById('textPressureScaleMax').value);
                
                // Update displays
                document.getElementById('rangeDisplay').textContent = range + 'px';
                document.getElementById('smoothingDisplay').textContent = smoothing;
                document.getElementById('minWeightDisplay').textContent = minWeight;
                document.getElementById('maxWeightDisplay').textContent = maxWeight;
                document.getElementById('minOpacityDisplay').textContent = minOpacity.toFixed(1);
                document.getElementById('maxOpacityDisplay').textContent = maxOpacity.toFixed(1);
                document.getElementById('scaleMinDisplay').textContent = scaleMin.toFixed(1);
                document.getElementById('scaleMaxDisplay').textContent = scaleMax.toFixed(1);
                
                // Store settings globally for the text pressure effect
                this.textPressureSettings = {
                    enabled,
                    range,
                    smoothing,
                    minWeight,
                    maxWeight,
                    minOpacity,
                    maxOpacity,
                    boldEffect,
                    italicEffect,
                    strikeEffect,
                    underlineEffect,
                    scaleEffect,
                    scaleMin,
                    scaleMax
                };
            }

            initTextPressureTitle() {
                // Initialize settings first
                this.updateTextPressureSettings();
                
                const title = document.querySelector('.header h1');
                const text = title.textContent;
                const chars = text.split('');
                
                // Replace text with individual character spans
                title.innerHTML = chars.map((char, i) => 
                    `<span class="text-pressure-char" data-index="${i}">${char === ' ' ? '&nbsp;' : char}</span>`
                ).join('');
                
                const spans = title.querySelectorAll('.text-pressure-char');
                
                let mouseX = 0;
                let mouseY = 0;
                let targetX = 0;
                let targetY = 0;
                
                const handleMouseMove = (e) => {
                    targetX = e.clientX;
                    targetY = e.clientY;
                };
                
                const animate = () => {
                    if (!this.textPressureSettings.enabled) {
                        // Reset to default when disabled
                        spans.forEach(span => {
                            span.style.fontWeight = '600';
                            span.style.opacity = '1';
                        });
                        requestAnimationFrame(animate);
                        return;
                    }
                    
                    const smoothing = this.textPressureSettings.smoothing;
                    mouseX += (targetX - mouseX) / smoothing;
                    mouseY += (targetY - mouseY) / smoothing;
                    
                    const maxDist = this.textPressureSettings.range;
                    
                    spans.forEach(span => {
                        const rect = span.getBoundingClientRect();
                        const charCenterX = rect.left + rect.width / 2;
                        const charCenterY = rect.top + rect.height / 2;
                        
                        const distance = Math.sqrt(
                            Math.pow(mouseX - charCenterX, 2) + 
                            Math.pow(mouseY - charCenterY, 2)
                        );
                        
                        // Calculate effects based on distance
                        const getAttr = (distance, minVal, maxVal) => {
                            if (distance > maxDist) return minVal;
                            const normalizedDistance = distance / maxDist;
                            return minVal + (maxVal - minVal) * (1 - normalizedDistance);
                        };
                        
                        // Weight effect (configurable min to max)
                        const weight = this.textPressureSettings.boldEffect ? 
                            Math.floor(getAttr(distance, 
                                this.textPressureSettings.minWeight, 
                                this.textPressureSettings.maxWeight
                            )) : 600;
                        
                        // Alpha effect (configurable min to max)
                        const alpha = getAttr(distance, 
                            this.textPressureSettings.minOpacity, 
                            this.textPressureSettings.maxOpacity
                        ).toFixed(2);
                        
                        // Scale effect
                        const scale = this.textPressureSettings.scaleEffect ?
                            getAttr(distance, 
                                this.textPressureSettings.scaleMin, 
                                this.textPressureSettings.scaleMax
                            ).toFixed(2) : 1;
                        
                        // Apply effects
                        span.style.fontWeight = weight;
                        span.style.opacity = alpha;
                        span.style.fontStyle = this.textPressureSettings.italicEffect && distance <= maxDist ? 'italic' : 'normal';
                        span.style.textDecoration = this.getTextDecoration(distance, maxDist);
                        span.style.transform = `scale(${scale})`;
                        span.style.transformOrigin = 'center';
                        span.style.display = 'inline-block';
                    });
                    
                    requestAnimationFrame(animate);
                };
                
                document.addEventListener('mousemove', handleMouseMove);
                animate();
            }

            getTextDecoration(distance, maxDist) {
                const decorations = [];
                
                if (this.textPressureSettings.strikeEffect && distance <= maxDist) {
                    decorations.push('line-through');
                }
                
                if (this.textPressureSettings.underlineEffect && distance <= maxDist) {
                    decorations.push('underline');
                }
                
                return decorations.length > 0 ? decorations.join(' ') : 'none';
            }

            initializeGrid() {
                this.grid = Array(this.gridHeight).fill().map(() => Array(this.gridWidth).fill(this.characterMap?.empty || '·'));
                this.placeAgentsAndObstacles();
                this.renderGrid();
            }

            generatePersistentObstacles() {
                const obstacleCount = parseInt(document.getElementById('obstacleCount').value);
                this.obstacles = [];
                
                for (let i = 0; i < obstacleCount; i++) {
                    let pos;
                    do {
                        pos = {
                            x: Math.floor(Math.random() * (this.gridWidth - 2)) + 1,
                            y: Math.floor(Math.random() * (this.gridHeight - 2)) + 1
                        };
                    } while (this.obstacles.some(obs => obs.x === pos.x && obs.y === pos.y));
                    this.obstacles.push(pos);
                }
            }

            establishTrainingSpawnPoints() {
                // Generate obstacles for training session
                this.generatePersistentObstacles();
                
                // Establish fixed spawn points for this training session
                do {
                    this.trainingCatSpawn = {
                        x: Math.floor(Math.random() * (this.gridWidth - 2)) + 1,
                        y: Math.floor(Math.random() * (this.gridHeight - 2)) + 1
                    };
                } while (this.obstacles.some(obs => obs.x === this.trainingCatSpawn.x && obs.y === this.trainingCatSpawn.y));
                
                do {
                    this.trainingMouseSpawn = {
                        x: Math.floor(Math.random() * (this.gridWidth - 2)) + 1,
                        y: Math.floor(Math.random() * (this.gridHeight - 2)) + 1
                    };
                } while (
                    (this.trainingMouseSpawn.x === this.trainingCatSpawn.x && this.trainingMouseSpawn.y === this.trainingCatSpawn.y) ||
                    this.obstacles.some(obs => obs.x === this.trainingMouseSpawn.x && obs.y === this.trainingMouseSpawn.y)
                );
                
                console.log('Training spawn points established:', {
                    cat: this.trainingCatSpawn,
                    mouse: this.trainingMouseSpawn,
                    obstacles: this.obstacles.length
                });
            }

            placeAgentsAndObstacles() {
                // Clear previous positions
                this.grid = Array(this.gridHeight).fill().map(() => Array(this.gridWidth).fill(this.characterMap?.empty || '·'));
                
                // Reset obstacles to their original positions
                this.obstacles = JSON.parse(JSON.stringify(this.originalObstacles));
                
                // Use consistent spawn points during training, random otherwise
                if (this.isTraining && this.trainingCatSpawn && this.trainingMouseSpawn) {
                    this.catPos = { ...this.trainingCatSpawn };
                    this.mousePos = { ...this.trainingMouseSpawn };
                } else {
                    // Place cat (ensure it's not on an obstacle)
                    do {
                        this.catPos = {
                            x: Math.floor(Math.random() * (this.gridWidth - 2)) + 1,
                            y: Math.floor(Math.random() * (this.gridHeight - 2)) + 1
                        };
                    } while (this.obstacles.some(obs => obs.x === this.catPos.x && obs.y === this.catPos.y));
                    
                    // Place mouse (ensure it's not on the cat or obstacles)
                    do {
                        this.mousePos = {
                            x: Math.floor(Math.random() * (this.gridWidth - 2)) + 1,
                            y: Math.floor(Math.random() * (this.gridHeight - 2)) + 1
                        };
                    } while (
                        (this.mousePos.x === this.catPos.x && this.mousePos.y === this.catPos.y) ||
                        this.obstacles.some(obs => obs.x === this.mousePos.x && obs.y === this.mousePos.y)
                    );
                }
                
                // Update grid
                this.updateGridDisplay();
            }

            updateGridDisplay() {
                // Clear grid
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        this.grid[y][x] = this.characterMap?.empty || '·';
                    }
                }
                
                // Add vision if enabled
                if (document.getElementById('toggleVision').checked) {
                    this.addVisionToGrid();
                }
                
                // Place obstacles
                this.obstacles.forEach(obs => {
                    if (this.grid[obs.y][obs.x] === (this.characterMap?.empty || '·')) {
                        this.grid[obs.y][obs.x] = this.characterMap?.obstacle || 'O';
                    }
                });
                
                // Place agents (they override everything else)
                this.grid[this.catPos.y][this.catPos.x] = this.characterMap?.cat || 'C';
                this.grid[this.mousePos.y][this.mousePos.x] = this.characterMap?.mouse || 'M';
            }

            addVisionToGrid() {
                const catVision = parseInt(document.getElementById('predatorVision').value);
                const mouseVision = parseInt(document.getElementById('preyVision').value);
                
                // Get vision cells for both agents
                const catVisibleCells = this.getVisibleCells(this.catPos, catVision, 'cat');
                const mouseVisibleCells = this.getVisibleCells(this.mousePos, mouseVision, 'mouse');
                
                // Create sets for efficient lookup
                const catVisionSet = new Set(catVisibleCells.map(cell => `${cell.x},${cell.y}`));
                const mouseVisionSet = new Set(mouseVisibleCells.map(cell => `${cell.x},${cell.y}`));
                
                // Add cat vision (use ? for both cat and mouse vision)
                catVisibleCells.forEach(cell => {
                    if (this.grid[cell.y][cell.x] === (this.characterMap?.empty || '·')) {
                        this.grid[cell.y][cell.x] = this.characterMap?.unknown || '?';
                    }
                });
                
                // Add mouse vision (also use ?, but check for overlap)
                mouseVisibleCells.forEach(cell => {
                    const cellKey = `${cell.x},${cell.y}`;
                    if (this.grid[cell.y][cell.x] === (this.characterMap?.empty || '·')) {
                        this.grid[cell.y][cell.x] = this.characterMap?.unknown || '?';
                    }
                    // If this cell is visible to both agents, use collision symbol
                    else if (this.grid[cell.y][cell.x] === (this.characterMap?.unknown || '?') && catVisionSet.has(cellKey)) {
                        this.grid[cell.y][cell.x] = this.characterMap?.error || '!';
                    }
                });
            }

            getVisibleCells(pos, range, agentType = null) {
                const visible = [];
                const useConeVision = document.getElementById('toggleConeVision')?.checked || false;
                
                if (!useConeVision) {
                    // Use circular vision (original behavior)
                    for (let dx = -range; dx <= range; dx++) {
                        for (let dy = -range; dy <= range; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance > range) continue; // Skip if outside circular range
                            
                            const targetX = pos.x + dx;
                            const targetY = pos.y + dy;
                            
                            if (targetX >= 0 && targetX < this.gridWidth && 
                                targetY >= 0 && targetY < this.gridHeight) {
                                
                                if (this.hasLineOfSight(pos, { x: targetX, y: targetY })) {
                                    visible.push({ x: targetX, y: targetY });
                                }
                            }
                        }
                    }
                } else {
                    // Use cone vision
                    const visionAngle = parseInt(document.getElementById('visionAngle')?.value || 90);
                    let rotation = 0;
                    
                    // Get rotation based on agent type (use dynamic rotation)
                    if (agentType === 'cat') {
                        rotation = this.catRotation;
                    } else if (agentType === 'mouse') {
                        rotation = this.mouseRotation;
                    }
                    
                    // Convert rotation to radians
                    const rotationRad = (rotation * Math.PI) / 180;
                    const halfAngleRad = (visionAngle * Math.PI) / 360; // Half of cone angle
                    
                    for (let dx = -range; dx <= range; dx++) {
                        for (let dy = -range; dy <= range; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance > range) continue; // Skip if outside circular range
                            
                            // Calculate angle from agent position to target cell
                            const targetAngle = Math.atan2(dy, dx);
                            
                            // Calculate angle difference from rotation direction
                            let angleDiff = targetAngle - rotationRad;
                            
                            // Normalize angle difference to [-π, π]
                            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                            
                            // Check if within cone angle
                            if (Math.abs(angleDiff) <= halfAngleRad) {
                                const targetX = pos.x + dx;
                                const targetY = pos.y + dy;
                                
                                if (targetX >= 0 && targetX < this.gridWidth && 
                                    targetY >= 0 && targetY < this.gridHeight) {
                                    
                                    if (this.hasLineOfSight(pos, { x: targetX, y: targetY })) {
                                        visible.push({ x: targetX, y: targetY });
                                    }
                                }
                            }
                        }
                    }
                }
                
                return visible;
            }

            hasLineOfSight(from, to) {
                // Use Bresenham's line algorithm to check line of sight
                const dx = Math.abs(to.x - from.x);
                const dy = Math.abs(to.y - from.y);
                const sx = from.x < to.x ? 1 : -1;
                const sy = from.y < to.y ? 1 : -1;
                let err = dx - dy;
                
                let x = from.x;
                let y = from.y;
                
                // Check each step along the line
                while (x !== to.x || y !== to.y) {
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                    
                    // If we hit an obstacle before reaching the target, vision is blocked
                    if (this.obstacles.some(obs => obs.x === x && obs.y === y)) {
                        return false;
                    }
                }
                
                return true; // Clear line of sight to target
            }

            renderGrid() {
                if (!document.getElementById('toggleRender').checked) return;
                
                let gridText = '';
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        gridText += this.grid[y][x];
                    }
                    gridText += '\n';
                }
                
                document.getElementById('gameGrid').textContent = gridText;
            }

            getState(agentPos, targetPos) {
                const dx = targetPos.x - agentPos.x;
                const dy = targetPos.y - agentPos.y;
                const distance = Math.abs(dx) + Math.abs(dy);
                
                return `${agentPos.x},${agentPos.y},${dx},${dy},${distance}`;
            }

            getAction(agent, state) {
                const actions = ['up', 'down', 'left', 'right'];
                const qTable = agent === 'cat' ? this.catQTable : this.mouseQTable;
                
                const epsilon = agent === 'cat' ? this.catEpsilon : this.mouseEpsilon;
                if (Math.random() < epsilon || !qTable[state]) {
                    // Random exploration: choose random movement and rotation
                    this.chooseRandomRotation(agent);
                    return actions[Math.floor(Math.random() * actions.length)];
                }
                
                // Initialize with random action to avoid bias
                let bestActions = [];
                let bestValue = -Infinity;
                
                for (let action of actions) {
                    const value = qTable[state][action] || 0;
                    if (value > bestValue) {
                        bestValue = value;
                        bestActions = [action];
                    } else if (value === bestValue) {
                        bestActions.push(action);
                    }
                }
                
                // When exploiting, choose strategic rotation
                this.chooseStrategicRotation(agent, state);
                
                // Randomly select from best actions to break ties
                const bestAction = bestActions[Math.floor(Math.random() * bestActions.length)];
                
                return bestAction;
            }
            
            chooseRandomRotation(agent) {
                // Only rotate if cone vision is enabled
                if (!document.getElementById('toggleConeVision')?.checked) return;
                
                const rotations = [0, 45, 90, 135, 180, 225, 270, 315];
                const randomRotation = rotations[Math.floor(Math.random() * rotations.length)];
                
                if (agent === 'cat') {
                    this.catRotation = randomRotation;
                } else if (agent === 'mouse') {
                    this.mouseRotation = randomRotation;
                }
                
                // Update the UI sliders to reflect the new rotation
                this.updateRotationSliders();
            }
            
            chooseStrategicRotation(agent, state) {
                // Only rotate if cone vision is enabled
                if (!document.getElementById('toggleConeVision')?.checked) return;
                
                // Strategic rotation: face towards target
                const agentPos = agent === 'cat' ? this.catPos : this.mousePos;
                const targetPos = agent === 'cat' ? this.mousePos : this.catPos;
                
                const dx = targetPos.x - agentPos.x;
                const dy = targetPos.y - agentPos.y;
                
                // Calculate optimal facing direction
                let optimalRotation = 0;
                if (dx > 0 && dy === 0) optimalRotation = 0;    // Right
                else if (dx > 0 && dy > 0) optimalRotation = 45;  // Down-Right
                else if (dx === 0 && dy > 0) optimalRotation = 90;  // Down
                else if (dx < 0 && dy > 0) optimalRotation = 135; // Down-Left
                else if (dx < 0 && dy === 0) optimalRotation = 180; // Left
                else if (dx < 0 && dy < 0) optimalRotation = 225; // Up-Left
                else if (dx === 0 && dy < 0) optimalRotation = 270; // Up
                else if (dx > 0 && dy < 0) optimalRotation = 315; // Up-Right
                
                // For mouse, sometimes choose opposite direction (evasion)
                if (agent === 'mouse' && Math.random() < 0.3) {
                    optimalRotation = (optimalRotation + 180) % 360;
                }
                
                if (agent === 'cat') {
                    this.catRotation = optimalRotation;
                } else if (agent === 'mouse') {
                    this.mouseRotation = optimalRotation;
                }
                
                // Update the UI sliders to reflect the new rotation
                this.updateRotationSliders();
            }
            
            updateRotationSliders() {
                // Rotation sliders have been removed - rotations are now fully AI-controlled
                // This method is kept for compatibility but no longer updates UI elements
            }
            
            openDisplayControls() {
                const toggle = document.getElementById('displayControlsToggle');
                const content = document.getElementById('displayControlsContent');
                
                if (toggle && content) {
                    toggle.classList.remove('collapsed');
                    content.classList.remove('collapsed');
                    toggle.textContent = toggle.textContent.replace('▶', '▼');
                }
            }

            updateQTable(agent, state, action, reward, nextState) {
                const qTable = agent === 'cat' ? this.catQTable : this.mouseQTable;
                
                if (!qTable[state]) {
                    qTable[state] = { up: 0, down: 0, left: 0, right: 0 };
                }
                
                if (!qTable[nextState]) {
                    qTable[nextState] = { up: 0, down: 0, left: 0, right: 0 };
                }
                
                const currentQ = qTable[state][action];
                const maxNextQ = Math.max(...Object.values(qTable[nextState]));
                const learningRate = agent === 'cat' ? this.catLearningRate : this.mouseLearningRate;
                const newQ = currentQ + learningRate * (reward + this.discountFactor * maxNextQ - currentQ);
                
                qTable[state][action] = newQ;
            }

            moveAgent(pos, action) {
                const newPos = { ...pos };
                
                switch (action) {
                    case 'up': newPos.y = Math.max(0, pos.y - 1); break;
                    case 'down': newPos.y = Math.min(this.gridHeight - 1, pos.y + 1); break;
                    case 'left': newPos.x = Math.max(0, pos.x - 1); break;
                    case 'right': newPos.x = Math.min(this.gridWidth - 1, pos.x + 1); break;
                }
                
                // Handle obstacle pushing
                const obstacleIndex = this.obstacles.findIndex(obs => obs.x === newPos.x && obs.y === newPos.y);
                if (obstacleIndex !== -1) {
                    const obstacle = this.obstacles[obstacleIndex];
                    const pushPos = { ...obstacle };
                    
                    switch (action) {
                        case 'up': pushPos.y = Math.max(0, obstacle.y - 1); break;
                        case 'down': pushPos.y = Math.min(this.gridHeight - 1, obstacle.y + 1); break;
                        case 'left': pushPos.x = Math.max(0, obstacle.x - 1); break;
                        case 'right': pushPos.x = Math.min(this.gridWidth - 1, obstacle.x + 1); break;
                    }
                    
                    // Check if push position is valid (not another obstacle)
                    const canPush = !this.obstacles.some(obs => obs.x === pushPos.x && obs.y === pushPos.y);
                    
                    if (canPush) {
                        this.obstacles[obstacleIndex] = pushPos;
                        return newPos;
                    } else {
                        return pos; // Can't move, obstacle can't be pushed
                    }
                }
                
                return newPos;
            }

            calculateReward(agent, oldPos, newPos, targetPos, caught) {
                if (caught) {
                    return agent === 'cat' ? this.rewards.catWin : this.rewards.mouseCaught;
                }
                
                const oldDistance = Math.abs(oldPos.x - targetPos.x) + Math.abs(oldPos.y - targetPos.y);
                const newDistance = Math.abs(newPos.x - targetPos.x) + Math.abs(newPos.y - targetPos.y);
                
                if (agent === 'cat') {
                    const catCanSee = this.getVisibleCells(oldPos, parseInt(document.getElementById('predatorVision').value), 'cat')
                        .some(cell => cell.x === targetPos.x && cell.y === targetPos.y);
                    
                    // User-configurable cat reward system
                    if (catCanSee && newDistance < oldDistance) return this.rewards.catHunting;
                    if (!catCanSee && newDistance < oldDistance) return this.rewards.catExploration;
                    if (newDistance === oldDistance) return this.rewards.catStandingStill;
                    if (catCanSee && newDistance > oldDistance) return this.rewards.catRetreating;
                    if (!catCanSee && newDistance > oldDistance) return this.rewards.catStandingStill; // Light penalty for moving away blindly
                } else {
                    const mouseCanSee = this.getVisibleCells(oldPos, parseInt(document.getElementById('preyVision').value), 'mouse')
                        .some(cell => cell.x === targetPos.x && cell.y === targetPos.y);
                    
                    // User-configurable mouse reward system
                    if (!mouseCanSee && newDistance > oldDistance) return this.rewards.mouseBlindEscape;
                    if (mouseCanSee && newDistance > oldDistance) return this.rewards.mouseStrategicEscape;
                    if (newDistance === oldDistance) {
                        return mouseCanSee ? this.rewards.mouseStandingStillVisible : 0; // Only penalize standing still if cat is visible
                    }
                    if (!mouseCanSee && newDistance < oldDistance) return this.rewards.mouseMovingTowardDanger;
                    if (mouseCanSee && newDistance < oldDistance) return this.rewards.mouseApproachingDanger;
                }
                
                return 0;
            }

            async runEpisode() {
                this.placeAgentsAndObstacles();
                const maxSteps = parseInt(document.getElementById('stepCount').value);
                let episodeSteps = 0;
                this.currentCatScore = 0;
                this.currentMouseScore = 0;
                
                for (let step = 0; step < maxSteps && this.isTraining && !this.isPaused; step++) {
                    this.currentStep = step;
                    episodeSteps = step + 1;
                    
                    // Get states
                    const catState = this.getState(this.catPos, this.mousePos);
                    const mouseState = this.getState(this.mousePos, this.catPos);
                    
                    // Get actions
                    const catAction = this.getAction('cat', catState);
                    const mouseAction = this.getAction('mouse', mouseState);
                    
                    // Store old positions
                    const oldCatPos = { ...this.catPos };
                    const oldMousePos = { ...this.mousePos };
                    
                    // Move agents
                    this.catPos = this.moveAgent(this.catPos, catAction);
                    this.mousePos = this.moveAgent(this.mousePos, mouseAction);
                    
                    // Check if caught
                    const caught = this.catPos.x === this.mousePos.x && this.catPos.y === this.mousePos.y;
                    
                    // Calculate rewards
                    const catReward = this.calculateReward('cat', oldCatPos, this.catPos, this.mousePos, caught);
                    const mouseReward = this.calculateReward('mouse', oldMousePos, this.mousePos, this.catPos, caught);
                    
                    // Update current episode scores
                    this.currentCatScore += catReward;
                    this.currentMouseScore += mouseReward;
                    
                    // Get new states
                    const newCatState = this.getState(this.catPos, this.mousePos);
                    const newMouseState = this.getState(this.mousePos, this.catPos);
                    
                    // Update Q-tables
                    this.updateQTable('cat', catState, catAction, catReward, newCatState);
                    this.updateQTable('mouse', mouseState, mouseAction, mouseReward, newMouseState);
                    
                    // Update display
                    this.updateGridDisplay();
                    this.renderGrid();
                    this.updateStats();
                    
                    // Check if episode ended
                    if (caught) {
                        this.catWins++;
                        break;
                    }
                    
                    // Add delay based on speed setting
                    const speed = parseInt(document.getElementById('simulationSpeed').value);
                    if (speed < 500) {
                        await new Promise(resolve => setTimeout(resolve, 500 - speed));
                    } else {
                        // For very fast speeds, yield control to prevent UI freeze
                        if (step % 10 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    }
                }
                
                // If we reached max steps without catching, mouse wins
                if (episodeSteps >= maxSteps && (this.catPos.x !== this.mousePos.x || this.catPos.y !== this.mousePos.y)) {
                    // Give mouse big survival reward
                    const finalMouseState = this.getState(this.mousePos, this.catPos);
                    this.updateQTable('mouse', finalMouseState, 'survival', this.rewards.mouseSurvival, finalMouseState);
                    this.currentMouseScore += this.rewards.mouseSurvival;
                    
                    // Penalize cat for not catching mouse
                    const finalCatState = this.getState(this.catPos, this.mousePos);
                    this.updateQTable('cat', finalCatState, 'failure', this.rewards.catFailure, finalCatState);
                    this.currentCatScore += this.rewards.catFailure;
                    
                    this.mouseWins++;
                }
                
                this.totalSteps += episodeSteps;
                
                // Record episode data for chart
                const catWinRate = (this.catWins / (this.currentEpisode + 1)) * 100;
                const mouseWinRate = (this.mouseWins / (this.currentEpisode + 1)) * 100;
                
                this.episodeData.push({
                    episode: this.currentEpisode + 1,
                    catWinRate: catWinRate,
                    mouseWinRate: mouseWinRate
                });
            }

            async startTraining() {
                this.isTraining = true;
                this.isPaused = false;
                this.updateButtonStates(); // Update buttons when training starts
                this.openDisplayControls(); // Always open display controls when training starts
                
                // Only reset stats if starting fresh (no existing Q-tables or episode data)
                const isStartingFresh = Object.keys(this.catQTable).length === 0 && 
                                       Object.keys(this.mouseQTable).length === 0 && 
                                       this.episodeData.length === 0;
                
                if (isStartingFresh) {
                    this.currentEpisode = 0;
                    this.currentStep = 0;
                    this.catWins = 0;
                    this.mouseWins = 0;
                    this.totalSteps = 0;
                    this.episodeData = [];
                    
                    // Reset epsilon for new training session
                    this.catEpsilon = this.catInitialEpsilon;
                    this.mouseEpsilon = this.mouseInitialEpsilon;
                }
                
                // Establish consistent spawn points for this training session
                this.establishTrainingSpawnPoints();
                
                document.getElementById('trainingStatus').textContent = 'Training';
                this.lockParameters(true);
                
                // Show the simulation view and hide welcome screen when training starts
                document.getElementById('welcomeScreen').style.display = 'none';
                document.getElementById('gridView').style.display = 'flex';
                
                const totalEpisodes = parseInt(document.getElementById('episodeCount').value);
                const startingEpisode = this.currentEpisode || 0;
                
                for (let episode = startingEpisode; episode < startingEpisode + totalEpisodes && this.isTraining; episode++) {
                    if (this.isPaused) {
                        document.getElementById('trainingStatus').textContent = 'Paused';
                        break;
                    }
                    
                    this.currentEpisode = episode;
                    await this.runEpisode();
                    this.updateStats();
                    
                    // Apply epsilon decay for reduced exploration over time
                    if (this.catEpsilon > this.minEpsilon) {
                        this.catEpsilon = Math.max(this.minEpsilon, this.catEpsilon * this.epsilonDecay);
                    }
                    if (this.mouseEpsilon > this.minEpsilon) {
                        this.mouseEpsilon = Math.max(this.minEpsilon, this.mouseEpsilon * this.epsilonDecay);
                    }
                }
                
                if (this.isTraining && !this.isPaused) {
                    this.isTraining = false;
                    document.getElementById('trainingStatus').textContent = 'Completed';
                    this.lockParameters(false);
                    this.showPerformanceChart();
                }
            }

            stopTraining() {
                this.isTraining = false;
                this.isPaused = true;
                document.getElementById('trainingStatus').textContent = 'Stopped';
                this.lockParameters(false);
                this.updateButtonStates(); // Update buttons when training stops
                
                // Show welcome screen when training stops
                document.getElementById('gridView').style.display = 'none';
                document.getElementById('welcomeScreen').style.display = 'flex';
            }

            continueTraining() {
                if (this.isPaused) {
                    this.isPaused = false;
                    this.startTraining();
                } else {
                    this.startTraining();
                }
            }

            lockParameters(lock) {
                const parameterIds = [
                    'episodeCount', 'stepCount', 'predatorVision', 'preyVision', 'obstacleCount'
                ];
                
                parameterIds.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.disabled = lock;
                        if (lock) {
                            element.style.opacity = '0.5';
                            element.style.cursor = 'not-allowed';
                        } else {
                            element.style.opacity = '1';
                            element.style.cursor = 'default';
                        }
                    }
                });
            }

            updateStats() {
                document.getElementById('currentEpisode').textContent = this.currentEpisode + 1;
                document.getElementById('currentStep').textContent = this.currentStep + 1;
                document.getElementById('catWins').textContent = this.catWins;
                document.getElementById('mouseWins').textContent = this.mouseWins;
                document.getElementById('currentCatScore').textContent = this.currentCatScore.toFixed(2);
                document.getElementById('currentMouseScore').textContent = this.currentMouseScore.toFixed(2);
                document.getElementById('obstacleCountDisplay').textContent = this.obstacles ? this.obstacles.length : 0;
                
                const totalGames = this.catWins + this.mouseWins;
                if (totalGames > 0) {
                    document.getElementById('catWinRate').textContent = Math.round((this.catWins / totalGames) * 100) + '%';
                    document.getElementById('mouseWinRate').textContent = Math.round((this.mouseWins / totalGames) * 100) + '%';
                    document.getElementById('avgSteps').textContent = Math.round(this.totalSteps / totalGames);
                }
            }

            showPerformanceChart() {
                document.getElementById('gridView').style.display = 'none';
                document.getElementById('chartContainer').style.display = 'block';
                
                const ctx = document.getElementById('performanceChart').getContext('2d');
                
                if (this.performanceChart) {
                    this.performanceChart.destroy();
                }
                
                this.performanceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: this.episodeData.map(d => d.episode),
                        datasets: [{
                            label: 'M (Mouse) Win Rate %',
                            data: this.episodeData.map(d => d.catWinRate),
                            borderColor: '#7FE9E1',
                            backgroundColor: 'rgba(127, 233, 225, 0.1)',
                            tension: 0.1
                        }, {
                            label: 'C (Cat) Win Rate %',
                            data: this.episodeData.map(d => d.mouseWinRate),
                            borderColor: '#4ECDC4',
                            backgroundColor: 'rgba(78, 205, 196, 0.1)',
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Win Rate %',
                                    color: '#7FE9E1'
                                },
                                ticks: {
                                    color: '#7FE9E1'
                                },
                                grid: {
                                    color: 'rgba(127, 233, 225, 0.2)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Episode Number',
                                    color: '#7FE9E1'
                                },
                                ticks: {
                                    color: '#7FE9E1'
                                },
                                grid: {
                                    color: 'rgba(127, 233, 225, 0.2)'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Performance Over Episodes',
                                color: '#7FE9E1'
                            },
                            legend: {
                                labels: {
                                    color: '#7FE9E1'
                                }
                            }
                        }
                    }
                });
            }

            downloadTraining() {
                const trainingData = {
                    catQTable: this.catQTable,
                    mouseQTable: this.mouseQTable,
                    episodeData: this.episodeData,
                    stats: {
                        catWins: this.catWins,
                        mouseWins: this.mouseWins,
                        currentEpisode: this.currentEpisode,
                        totalSteps: this.totalSteps
                    },
                    environmentData: {
                        obstacles: this.originalObstacles || this.obstacles,
                        trainingCatSpawn: this.trainingCatSpawn,
                        trainingMouseSpawn: this.trainingMouseSpawn,
                        gridWidth: this.gridWidth,
                        gridHeight: this.gridHeight,
                        characterMap: this.characterMap
                    }
                };
                
                const blob = new Blob([JSON.stringify(trainingData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lumon_training_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            triggerUpload() {
                const uploadButton = document.getElementById('uploadTrainingButton');
                uploadButton.textContent = 'Selecting...';
                uploadButton.style.opacity = '0.7';
                document.getElementById('uploadTraining').click();
            }
            
            updateButtonStates() {
                const startButton = document.getElementById('startTraining');
                const stopButton = document.getElementById('stopTraining');
                const continueButton = document.getElementById('continueTraining');
                
                // Check if there's existing training data
                const hasExistingData = Object.keys(this.catQTable).length > 0 || 
                                      Object.keys(this.mouseQTable).length > 0 || 
                                      this.currentEpisode > 0;
                
                if (this.isTraining) {
                    // During training: hide Start/Continue, show Stop
                    startButton.style.display = 'none';
                    continueButton.style.display = 'none';
                    stopButton.style.display = 'inline-block';
                } else if (hasExistingData) {
                    // Has data but not training: show Continue, hide Start/Stop
                    startButton.style.display = 'none';
                    stopButton.style.display = 'none';
                    continueButton.style.display = 'inline-block';
                    continueButton.textContent = 'Continue';
                } else {
                    // No data and not training: show Start, hide Continue/Stop
                    startButton.style.display = 'inline-block';
                    stopButton.style.display = 'none';
                    continueButton.style.display = 'none';
                    startButton.textContent = 'Start';
                }
            }
            
            toggleSettingsVisibility() {
                // Toggle all settings sections by their container elements
                const settingsSection = document.getElementById('settingsSection');
                const typographySection = document.querySelector('[id="typographyToggle"]').parentElement;
                const charactersSection = document.querySelector('[id="charactersToggle"]').parentElement;
                const layoutSection = document.querySelector('[id="layoutToggle"]').parentElement;
                
                const sections = [settingsSection, typographySection, charactersSection, layoutSection];
                sections.forEach(section => {
                    if (section) {
                        section.classList.toggle('settings-section-hidden');
                    }
                });
            }

            loadTraining() {
                if (!this.uploadFile) {
                    alert('No file selected');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const trainingData = JSON.parse(e.target.result);
                        
                        this.catQTable = trainingData.catQTable || {};
                        this.mouseQTable = trainingData.mouseQTable || {};
                        this.episodeData = trainingData.episodeData || [];
                        
                        if (trainingData.stats) {
                            this.catWins = trainingData.stats.catWins || 0;
                            this.mouseWins = trainingData.stats.mouseWins || 0;
                            this.currentEpisode = trainingData.stats.currentEpisode || 0;
                            this.totalSteps = trainingData.stats.totalSteps || 0;
                        }
                        
                        // Restore environment data if available
                        if (trainingData.environmentData) {
                            const envData = trainingData.environmentData;
                            if (envData.obstacles) {
                                this.obstacles = envData.obstacles;
                                this.originalObstacles = JSON.parse(JSON.stringify(envData.obstacles));
                            }
                            if (envData.trainingCatSpawn) {
                                this.trainingCatSpawn = envData.trainingCatSpawn;
                            }
                            if (envData.trainingMouseSpawn) {
                                this.trainingMouseSpawn = envData.trainingMouseSpawn;
                            }
                            if (envData.characterMap) {
                                this.characterMap = envData.characterMap;
                                this.updateLegend();
                                // Update character input fields with null checks
                                const emptyCharInput = document.getElementById('emptyChar');
                                const catCharInput = document.getElementById('catChar');
                                const mouseCharInput = document.getElementById('mouseChar');
                                const obstacleCharInput = document.getElementById('obstacleChar');
                                const unknownCharInput = document.getElementById('unknownChar');
                                const errorCharInput = document.getElementById('errorChar');
                                
                                if (emptyCharInput) emptyCharInput.value = envData.characterMap.empty || '·';
                                if (catCharInput) catCharInput.value = envData.characterMap.cat || 'C';
                                if (mouseCharInput) mouseCharInput.value = envData.characterMap.mouse || 'M';
                                if (obstacleCharInput) obstacleCharInput.value = envData.characterMap.obstacle || 'O';
                                if (unknownCharInput) unknownCharInput.value = envData.characterMap.unknown || '?';
                                if (errorCharInput) errorCharInput.value = envData.characterMap.error || '!';
                            }
                        }
                        
                        this.updateStats();
                        this.updateButtonStates(); // Update button states after loading
                        
                        // Reset upload button
                        const uploadButton = document.getElementById('uploadTrainingButton');
                        uploadButton.textContent = 'Upload';
                        uploadButton.style.opacity = '1';
                        
                        alert('Training data loaded successfully!');
                        
                    } catch (error) {
                        // Reset upload button on error
                        const uploadButton = document.getElementById('uploadTrainingButton');
                        uploadButton.textContent = 'Upload';
                        uploadButton.style.opacity = '1';
                        
                        alert('Error loading training data: ' + error.message);
                    }
                };
                reader.readAsText(this.uploadFile);
            }
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Temporarily disable animations on page load
            document.body.classList.add('no-animations');
            
            const app = new LumonResearch();
            app.initHeaderScrambleEffect(); // Initialize header scramble effect
            
            // Re-enable animations after a short delay
            setTimeout(() => {
                document.body.classList.remove('no-animations');
            }, 100);
        });
    </script>

    <!-- Help Popup -->
    <div class="help-popup-overlay" id="helpOverlay"></div>
    <div class="help-popup" id="helpPopup">
        <div class="help-popup-content">
            <button class="help-close-btn" id="helpCloseBtn">&times;</button>
            <div style="width: 100%; text-align: left; line-height: 1.4; font-size: 0.9rem;">
                <div style="margin-bottom: 1.5rem;">
                    <h3 style="color: #7FE9E1; margin-bottom: 0.4rem; font-size: 1.1rem;">Learning Parameters Explained</h3>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #7FE9E1; margin-bottom: 0.4rem; font-size: 1.1rem;">Learning Rate</h4>
                    <p style="margin-bottom: 0.3rem; font-size: 0.85rem; color: #a0e7e0; font-style: italic;">Range: 0.01 - 0.5 (Default: 0.1)</p>
                    <p style="margin-bottom: 0.5rem;">Controls how much the AI agents learn from each experience. Higher values make agents adapt quickly to new situations but may cause instability. Lower values create stable, gradual learning but slower adaptation.</p>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #7FE9E1; margin-bottom: 0.4rem; font-size: 1.1rem;">Exploration Rate</h4>
                    <p style="margin-bottom: 0.3rem; font-size: 0.85rem; color: #a0e7e0; font-style: italic;">Range: 0.05 - 0.8 (Default: 0.3)</p>
                    <p style="margin-bottom: 0.5rem;">Determines how often agents try random actions versus using their learned knowledge. High exploration encourages discovering new strategies but reduces efficiency. Low exploration focuses on known good strategies but may miss better solutions.</p>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #7FE9E1; margin-bottom: 0.4rem; font-size: 1.1rem;">Discount Factor</h4>
                    <p style="margin-bottom: 0.3rem; font-size: 0.85rem; color: #a0e7e0; font-style: italic;">Range: 0.1 - 0.99 (Default: 0.95)</p>
                    <p style="margin-bottom: 0.5rem;">Controls how much agents value future rewards versus immediate rewards. Values near 1.0 make agents plan far ahead for long-term success. Lower values focus on immediate gains and short-term thinking.</p>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #7FE9E1; margin-bottom: 0.4rem; font-size: 1.1rem;">Exploration Decay</h4>
                    <p style="margin-bottom: 0.3rem; font-size: 0.85rem; color: #a0e7e0; font-style: italic;">Range: 0.990 - 0.999 (Default: 0.995)</p>
                    <p style="margin-bottom: 0.5rem;">Rate at which exploration decreases over time. Agents start curious and gradually become more focused on their learned strategies. Higher values maintain exploration longer, lower values quickly shift to exploitation.</p>
                </div>
            </div>
        </div>
    </div>
</body>
</html>