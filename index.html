<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumon Research</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Mono', 'Lucida Console', monospace;
            background: #101827;
            color: #7FE9E1;
            min-height: 100vh;
            overflow-x: hidden;
            text-transform: uppercase;
            position: relative;
            cursor: default;
        }
        
        /* Mouse cursor rules */
        button, input[type="number"], input[type="text"], input[type="file"], .btn, .file-input-custom {
            cursor: pointer !important;
        }
        
        input[type="range"], input[type="checkbox"], .collapsible-title {
            cursor: pointer !important;
        }

        .crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .crt-overlay::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 1px,
                rgba(127, 233, 225, 0.08) 1px,
                rgba(127, 233, 225, 0.08) 2px,
                transparent 2px,
                transparent 4px
            );
            opacity: var(--crt-scanlines, 0.8);
            animation: crt-scanlines 0.1s linear infinite;
        }

        .crt-overlay::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 1px,
                    rgba(127, 233, 225, 0.02) 1px,
                    rgba(127, 233, 225, 0.02) 2px
                ),
                radial-gradient(
                    ellipse 120% 100% at center,
                    transparent 65%,
                    rgba(0, 0, 0, 0.4) 100%
                );
            opacity: var(--crt-pixels, 0.3);
        }

        @keyframes crt-scanlines {
            0% { transform: translateY(0px); }
            100% { transform: translateY(4px); }
        }

        @keyframes crt-flicker {
            0% { opacity: 1; }
            50% { opacity: 0.98; }
            100% { opacity: 1; }
        }



        .crt-screen {
            filter: 
                contrast(1.1) 
                brightness(1.05) 
                saturate(1.2);
        }

        .crt-screen::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .crt-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .crt-screen * {
            text-shadow: 
                0 0 1px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.4)),
                0 0 2px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.2)),
                0 0 3px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.1));
        }

        .crt-screen .grid {
            text-shadow: 
                0 0 1px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.6)),
                0 0 2px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.3)),
                0 0 3px rgba(127, 233, 225, calc(var(--crt-glow, 0.3) * 0.2));
        }

        .container {
            display: flex;
            min-height: 100vh;
            background: #101827;
            position: relative;
            overflow: hidden;
        }

        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: transparent;
            padding: 1rem 2rem;
            z-index: 1000;
        }

        .header h1 {
            font-family: 'Orbitron', 'Space Mono', 'Lucida Console', 'Impact', 'Arial Black', monospace;
            font-size: 4rem;
            font-weight: 700;
            color: #7FE9E1;
            text-align: center;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .main-content {
            display: flex;
            width: 100%;
            margin-top: 165px;
            min-height: calc(100vh - 165px);
        }

        .control-center {
            width: 15%;
            background: #101827;
            padding: 1rem;
            overflow-y: auto;
            position: relative;
        }

        .draggable-panel {
            cursor: move;
            user-select: none;
            position: relative;
        }

        .draggable-panel:hover {
            opacity: 0.9;
        }

        .draggable-panel.dragging {
            z-index: 1000;
            position: fixed;
            background: #101827;
            border: 1px solid #7FE9E1;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(127, 233, 225, 0.3);
        }

        .simulation-view {
            width: 70%;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: stretch;
            background: #101827;
            min-height: calc(100vh - 80px);
            position: relative;
        }

        .analytics-panel {
            width: 15%;
            background: #101827;
            padding: 1rem;
            overflow-y: auto;
        }

        .section-title {
            font-size: 1.6rem;
            font-weight: 700;
            color: #7FE9E1;
            margin-bottom: 0.7rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #4B566A;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .collapsible-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #7FE9E1;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border: 1px solid #4B566A;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            background: #101827;
            transition: all 0.2s;
            user-select: none;
            position: relative;
        }

        .collapsible-title:hover {
            background: #4B566A;
            box-shadow: 0 0 5px rgba(127, 233, 225, 0.3);
        }

        .collapsible-title::after {
            content: '▼';
            position: absolute;
            right: 0.5rem;
            transition: transform 0.2s;
        }

        .collapsible-title.collapsed::after {
            transform: rotate(-90deg);
        }

        .collapsible-content {
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }

        .collapsible-content:not(.collapsed) {
            max-height: 90vh;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        /* Specific constraint for Settings dropdown to prevent footer movement */
        #settingsContent:not(.collapsed) {
            max-height: 40vh;
            overflow-y: auto;
            overflow-x: hidden;
            /* Hide scrollbar for WebKit browsers */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        /* Hide settings section by default (shown only with Ctrl+M) */
        .settings-section-hidden {
            display: none !important;
        }
        
        /* Hide scrollbar for WebKit browsers */
        #settingsContent:not(.collapsed)::-webkit-scrollbar {
            display: none;
        }
        
        /* Specific constraint for Typography section to prevent page overflow */
        #typographyContent:not(.collapsed) {
            max-height: 40vh;
            overflow-y: auto;
            overflow-x: hidden;
            /* Hide scrollbar for WebKit browsers */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        /* Hide scrollbar for WebKit browsers */
        #typographyContent:not(.collapsed)::-webkit-scrollbar {
            display: none;
        }

        #layoutContent:not(.collapsed) {
            max-height: 40vh;
            overflow-y: auto;
        }

        /* Hide scrollbar for display controls while maintaining scroll functionality */
        #displayControlsContent:not(.collapsed) {
            overflow-y: auto;
            overflow-x: hidden;
            /* Hide scrollbar for WebKit browsers */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        /* Hide scrollbar for learning parameters */
        #learningParametersContent:not(.collapsed) {
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        /* Hide scrollbar for rewards */
        #rewardsContent:not(.collapsed) {
            overflow-y: auto;
            overflow-x: hidden;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
        }
        
        /* Hide scrollbar for WebKit browsers */
        #displayControlsContent:not(.collapsed)::-webkit-scrollbar {
            display: none;
        }
        
        #learningParametersContent:not(.collapsed)::-webkit-scrollbar {
            display: none;
        }
        
        #rewardsContent:not(.collapsed)::-webkit-scrollbar {
            display: none;
        }

        #layoutContent:not(.collapsed)::-webkit-scrollbar {
            display: none;
        }

        /* Enhanced slider value displays */
        .speed-display {
            transition: transform 0.15s ease, color 0.15s ease;
        }
        
        /* DecryptedText effect styles */
        .decrypted-text-wrapper {
            display: inline-block;
            white-space: pre-wrap;
        }
        
        .decrypted-char {
            display: inline-block;
            transition: opacity 0.1s ease;
        }
        
        .encrypted-char {
            color: #4B566A;
            opacity: 0.6;
        }
        
        .decrypted-char.revealed {
            color: #7FE9E1;
            opacity: 1;
        }
        
        /* Ensure interactive elements stay above any canvas */
        .left-panel, .right-panel, .help-popup, .help-popup-overlay,
        .left-panel button, .left-panel input, .left-panel select,
        .right-panel button, .right-panel input, .right-panel select,
        .draggable-panel, .button-row, .button-row button,
        .chart-close-btn, .help-close-btn {
            position: relative;
            z-index: 1000 !important;
            pointer-events: auto !important;
        }
        
        /* Special handling for main control buttons */
        #startTraining, #stopTraining, #continueTraining, #newTraining, #startNewRound,
        #downloadTraining, #uploadTrainingButton {
            z-index: 1001 !important;
            pointer-events: auto !important;
        }

        /* Help popup styles - matching welcome page */
        .help-popup {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10001;
            display: none;
        }

        .help-popup-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70%;
            height: 100%;
            background: #101827;
            color: #7FE9E1;
            padding: 1rem;
            padding-top: 4rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
        }

        .help-popup-content h3 {
            color: #7FE9E1;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .help-param {
            margin-bottom: 1.5rem;
            width: 100%;
            text-align: left;
            line-height: 1.4;
            font-size: 0.9rem;
        }

        .help-param h4 {
            color: #7FE9E1;
            margin-bottom: 0.4rem;
            font-size: 1.1rem;
        }

        .help-param .param-range {
            font-size: 0.85rem;
            color: #a0e7e0;
            font-style: italic;
            margin-bottom: 0.5rem;
        }

        .help-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            display: none;
        }

        .help-close-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: #7FE9E1;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10002;
        }

        .help-close-btn:hover {
            color: #ffffff;
            background: rgba(127, 233, 225, 0.2);
            border-radius: 50%;
        }

        .help-clickable {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
        }

        .help-clickable:hover {
            color: #ffffff;
        }

        /* Button row layout */
        .button-row {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .button-row .btn {
            flex: 1;
            min-width: fit-content;
            font-size: 0.8rem;
            padding: 0.4rem 0.6rem;
            text-align: center;
        }

        .legend .scramble-char {
            display: inline-block;
            min-width: 1ch;
            text-align: center;
            font-family: 'Consolas', 'Courier New', monospace;
        }

        .header .scramble-char {
            display: inline-block;
            min-width: 1ch;
            text-align: center;
        }

        .inline-editable {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 2px;
            transition: background-color 0.2s;
        }

        .inline-editable:hover {
            background: rgba(127, 233, 225, 0.1);
        }

        .inline-editable.editing {
            background: rgba(127, 233, 225, 0.2) !important;
            outline: 1px solid #7FE9E1 !important;
        }

        .param-group {
            margin-bottom: 0.7rem;
        }

        .param-item {
            margin-bottom: 0.4rem;
        }
        
        /* Compact settings sections */
        .settings-section-compact .param-item {
            margin-bottom: 0.2rem;
        }
        
        .settings-section-compact .param-item label {
            font-size: 0.7rem;
            margin-bottom: 0.1rem;
        }
        
        .settings-section-compact .speed-display {
            font-size: 0.6rem;
        }

        .param-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.4rem;
            font-size: 0.85rem;
        }
        
        /* Ensure consistent spacing between all parameter elements */
        .param-group > .param-item:last-child,
        .param-group > .param-row:last-child {
            margin-bottom: 0;
        }
        
        /* Ensure consistent spacing in analytics panels */
        .analytics-panel .stat-row:last-child {
            margin-bottom: 0;
        }
        
        /* Ensure consistent spacing within bordered sections */
        div[style*="border-top"] .stat-row:last-child {
            margin-bottom: 0;
        }

        .param-label {
            color: #4B566A;
            text-transform: uppercase;
            font-weight: 500;
        }

        .param-value {
            font-weight: 600;
            color: #7FE9E1;
        }

        .param-item label {
            display: block;
            font-size: 0.9rem;
            font-weight: 500;
            color: #7FE9E1;
            margin-bottom: 0.2rem;
            text-transform: uppercase;
        }

        .param-item input[type="number"] {
            width: 100%;
            padding: 0.3rem;
            border: 1px solid #4B566A;
            border-radius: 2px;
            font-size: 0.7rem;
            background: #101827;
            color: #7FE9E1;
        }
        
        .param-item input[type="range"] {
            width: 100%;
            padding: 0.3rem;
            border: none;
            border-radius: 2px;
            font-size: 0.7rem;
            background: transparent;
            color: #7FE9E1;
        }

        .param-item input[type="number"]:focus {
            outline: none;
            border-color: #7FE9E1;
            box-shadow: 0 0 5px rgba(127, 233, 225, 0.3);
        }
        
        .param-item input[type="range"]:focus {
            outline: none;
            box-shadow: 0 0 5px rgba(127, 233, 225, 0.3);
        }

        .param-item input[type="number"]:disabled,
        .param-item input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Remove number input arrows */
        .param-row input[type="number"]::-webkit-outer-spin-button,
        .param-row input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .param-row input[type="number"] {
            -moz-appearance: textfield;
        }

        .param-row input[type="number"]:focus {
            outline: 1px solid #7FE9E1;
            background: rgba(127, 233, 225, 0.1);
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .checkbox-item input[type="checkbox"],
        .param-row input[type="checkbox"] {
            margin-right: 0.5rem;
            appearance: none;
            width: 16px;
            height: 16px;
            border: 2px solid #7FE9E1;
            border-radius: 2px;
            background: transparent;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
        }

        .checkbox-item input[type="checkbox"]:checked,
        .param-row input[type="checkbox"]:checked {
            background: #7FE9E1;
            border-color: #7FE9E1;
        }

        .checkbox-item input[type="checkbox"]:checked::after,
        .param-row input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            top: -1px;
            left: 2px;
            color: #101827;
            font-size: 12px;
            font-weight: bold;
        }

        .checkbox-item input[type="checkbox"]:hover,
        .param-row input[type="checkbox"]:hover {
            border-color: #7FE9E1;
            box-shadow: 0 0 8px rgba(127, 233, 225, 0.4);
            transform: scale(1.05);
        }

        /* Custom Slider Styles */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: #4B566A;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        input[type="range"]:hover {
            background: #5A6478;
            box-shadow: 0 0 10px rgba(127, 233, 225, 0.2);
        }

        /* Webkit Slider Thumb - Hidden */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 0;
            height: 0;
            background: transparent;
            cursor: pointer;
        }

        /* Firefox Slider Thumb - Hidden */
        input[type="range"]::-moz-range-thumb {
            width: 0;
            height: 0;
            background: transparent;
            border: none;
            cursor: pointer;
        }

        /* Firefox Slider Track */
        input[type="range"]::-moz-range-track {
            height: 4px;
            background: #4B566A;
            border-radius: 2px;
            border: none;
        }

        /* Active slider track fill */
        input[type="range"]::-webkit-slider-runnable-track {
            height: 4px;
            background: linear-gradient(to right, #7FE9E1 0%, #7FE9E1 var(--range-progress, 0%), #4B566A var(--range-progress, 0%), #4B566A 100%);
            border-radius: 2px;
        }

        .checkbox-item label {
            font-size: 0.9rem;
            color: #7FE9E1;
            margin: 0;
            text-transform: uppercase;
        }

        .btn {
            width: 100%;
            padding: 0.5rem;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 0.2rem;
        }

        /* Prevent animations on page load */
        .no-animations * {
            transition: none !important;
            animation: none !important;
        }

        /* Authentic CRT Monitor Screen Curvature */
        .crt-monitor-curve {
            border-radius: 20px 20px 25px 25px;
            overflow: hidden;
            box-shadow: 
                inset 0 0 0 2px rgba(127, 233, 225, 0.1),
                inset 0 0 30px rgba(0,0,0,0.2),
                0 0 20px rgba(0,0,0,0.3);
            transform-style: preserve-3d;
        }
        
        
        /* Screen glass reflection effect */
        .crt-glass-reflection {
            position: fixed;
            top: 5%;
            left: 15%;
            width: 30%;
            height: 40%;
            pointer-events: none;
            z-index: 1001;
            background: 
                linear-gradient(135deg, 
                    rgba(255,255,255,0.1) 0%, 
                    rgba(255,255,255,0.05) 30%, 
                    transparent 70%
                );
            border-radius: 50% 20% 80% 40%;
            opacity: 0.3;
            mix-blend-mode: screen;
        }
        
        /* CRT Screen bezel shadow */
        .crt-bezel-shadow {
            position: fixed;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            pointer-events: none;
            z-index: 998;
            background: 
                radial-gradient(ellipse 100% 100% at center, 
                    transparent 75%, 
                    rgba(0,0,0,0.3) 90%, 
                    rgba(0,0,0,0.8) 100%
                );
            border-radius: 40px;
        }

        .btn-primary {
            background: #4B566A;
            color: #7FE9E1;
            border: 1px solid #7FE9E1;
            text-transform: uppercase;
        }

        .btn-primary:hover {
            background: #7FE9E1;
            color: #101827;
            box-shadow: 0 0 10px rgba(127, 233, 225, 0.5);
        }

        .btn-secondary {
            background: #101827;
            color: #7FE9E1;
            border: 1px solid #4B566A;
            text-transform: uppercase;
        }

        .btn-secondary:hover {
            background: #4B566A;
            border-color: #7FE9E1;
        }

        .btn-danger {
            background: #101827;
            color: #7FE9E1;
            border: 1px solid #7FE9E1;
            text-transform: uppercase;
        }

        .btn-danger:hover {
            background: #7FE9E1;
            color: #101827;
        }

        .grid-container {
            background: #101827;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding-top: 2rem; /* Add padding to avoid title overlap */
        }

        .grid {
            font-family: 'Consolas', 'Courier New', monospace;
            font-size: 1.6rem;
            line-height: 1.3rem;
            letter-spacing: 0.4rem;
            color: #7FE9E1;
            white-space: pre;
            background: #101827;
            padding: 0;
            margin: 0;
            border: none;
            overflow: hidden;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: flex-start;
            position: relative;
        }

        /* Mouse proximity effects for individual characters */
        .grid-char {
            display: inline-block;
            transition: all 0.15s ease-out;
            position: relative;
            z-index: 1;
        }

        .grid-char.proximity-active {
            transform: scale(var(--char-scale, 1));
            color: rgba(127, 233, 225, var(--char-intensity, 1));
            text-shadow: 
                0 0 calc(5px * var(--char-glow, 1)) rgba(127, 233, 225, var(--char-intensity, 0.3)),
                0 0 calc(10px * var(--char-glow, 1)) rgba(127, 233, 225, calc(var(--char-intensity, 0.2) * 0.5)),
                0 0 calc(15px * var(--char-glow, 1)) rgba(127, 233, 225, calc(var(--char-intensity, 0.1) * 0.3));
            font-weight: calc(400 + (200 * var(--char-weight, 0)));
        }

        /* Special effects for different character types */
        .grid-char.char-cat.proximity-active {
            color: rgba(255, 120, 120, var(--char-intensity, 1));
            text-shadow: 
                0 0 calc(8px * var(--char-glow, 1)) rgba(255, 120, 120, var(--char-intensity, 0.4)),
                0 0 calc(16px * var(--char-glow, 1)) rgba(255, 120, 120, calc(var(--char-intensity, 0.3) * 0.5));
        }

        .grid-char.char-mouse.proximity-active {
            color: rgba(120, 255, 120, var(--char-intensity, 1));
            text-shadow: 
                0 0 calc(8px * var(--char-glow, 1)) rgba(120, 255, 120, var(--char-intensity, 0.4)),
                0 0 calc(16px * var(--char-glow, 1)) rgba(120, 255, 120, calc(var(--char-intensity, 0.3) * 0.5));
        }

        .grid-char.char-obstacle.proximity-active {
            color: rgba(255, 255, 120, var(--char-intensity, 1));
            text-shadow: 
                0 0 calc(6px * var(--char-glow, 1)) rgba(255, 255, 120, var(--char-intensity, 0.4)),
                0 0 calc(12px * var(--char-glow, 1)) rgba(255, 255, 120, calc(var(--char-intensity, 0.3) * 0.5));
        }
            justify-content: center;
            padding-top: 4.1rem;
            font-weight: normal;
        }

        .footer-container {
            position: absolute;
            bottom: 7rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }

        .legend {
            font-size: 1rem;
            color: #7FE9E1;
            text-align: center;
            padding: 0.5rem;
            background: #101827;
            text-transform: uppercase;
            white-space: nowrap;
            overflow: hidden;
            min-width: max-content;
            letter-spacing: normal;
            word-spacing: normal;
        }

        .chart-container {
            width: 100%;
            height: 500px;
            display: none;
            position: relative;
        }
        
        .chart-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 30px;
            height: 30px;
            background: #101827;
            border: 2px solid #7FE9E1;
            color: #7FE9E1;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }
        
        .chart-close-btn:hover {
            background: #7FE9E1;
            color: #101827;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.4rem;
            font-size: 0.85rem;
        }

        .stat-label {
            color: #4B566A;
            text-transform: uppercase;
        }

        .stat-value {
            font-weight: 600;
            color: #7FE9E1;
        }

        .file-input {
            display: none;
        }

        .file-input-custom {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid #4B566A;
            border-radius: 2px;
            font-size: 0.7rem;
            margin-bottom: 0.2rem;
            background: #101827;
            color: #7FE9E1;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: center;
            user-select: none;
        }

        .file-input-custom:hover {
            border-color: #7FE9E1;
            background: rgba(127, 233, 225, 0.1);
            box-shadow: 0 0 5px rgba(127, 233, 225, 0.3);
        }

        .file-input-custom.has-file {
            color: #7FE9E1;
            background: rgba(127, 233, 225, 0.05);
        }

        .speed-display {
            text-align: center;
            font-size: 0.8rem;
            color: #4B566A;
            margin-top: 0.2rem;
            text-transform: uppercase;
        }

        .cat { color: #7FE9E1; }
        .mouse { color: #7FE9E1; }
        .obstacle { color: #7FE9E1; }
        .cat-vision { color: #7FE9E1; }
        .mouse-vision { color: #7FE9E1; }
    </style>
</head>
<body>
    <div class="crt-overlay"></div>
    
    <!-- CRT Monitor Effects -->
    <div class="crt-glass-reflection" id="crtGlassReflection"></div>
    <div class="crt-bezel-shadow" id="crtBezelShadow"></div>
    
    
    <!-- CRT Shader Canvas -->
    <canvas id="crtCanvas" style="position: fixed; top: 0; left: 0; pointer-events: none; z-index: 1001; mix-blend-mode: overlay;"></canvas>
    
    <header class="header">
        <h1>LUMON RESEARCH</h1>
    </header>

    <div class="container crt-screen">
        <div class="main-content">
            <!-- Left Column: Control Center -->
            <div class="control-center draggable-panel" id="controlPanel">
                <h3 class="section-title">Control Center</h3>
                
                <div class="param-group">
                    <h4 style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Simulation Parameters</h4>
                    
                    <div class="param-row">
                        <span class="param-label">Episode Count:</span>
                        <span class="param-value inline-editable" data-type="number" data-min="1" data-input-id="episodeCount" data-callback="updateNumericValue">1000</span>
                    </div>
                    <input type="number" id="episodeCount" value="1000" min="1" style="display: none;">
                    
                    <div class="param-row">
                        <span class="param-label">Step Count:</span>
                        <span class="param-value inline-editable" data-type="number" data-min="10" data-input-id="stepCount" data-callback="updateNumericValue">200</span>
                    </div>
                    <input type="number" id="stepCount" value="200" min="10" style="display: none;">
                    
                    <div class="param-row">
                        <span class="param-label">Cat Vision:</span>
                        <span class="param-value inline-editable" data-type="number" data-min="1" data-max="15" data-input-id="predatorVision" data-callback="updateNumericValue">8</span>
                    </div>
                    <input type="number" id="predatorVision" value="8" min="1" max="15" style="display: none;">
                    
                    <div class="param-row">
                        <span class="param-label">Mouse Vision:</span>
                        <span class="param-value inline-editable" data-type="number" data-min="1" data-max="15" data-input-id="preyVision" data-callback="updateNumericValue">6</span>
                    </div>
                    <input type="number" id="preyVision" value="6" min="1" max="15" style="display: none;">
                    
                    
                    <div class="param-row">
                        <span class="param-label">Obstacle Count:</span>
                        <span class="param-value inline-editable" data-type="number" data-min="0" data-max="50" data-input-id="obstacleCount" data-callback="updateNumericValue">10</span>
                    </div>
                    <input type="number" id="obstacleCount" value="10" min="0" max="50" style="display: none;">
                    
                    <div class="param-row" style="margin-top: 0.5rem;">
                        <span class="param-label">Cone Vision:</span>
                        <input type="checkbox" id="toggleConeVision" checked style="margin: 0;">
                    </div>
                    
                    <div class="param-item">
                        <label for="visionAngle" id="visionAngleLabel">Vision Cone Angle: 90°</label>
                        <input type="range" id="visionAngle" min="30" max="180" step="15" value="90">
                        <div class="speed-display" id="visionAngleDisplay">90°</div>
                    </div>
                    
                    <div class="param-item">
                        <label for="simulationSpeed" id="simulationSpeedLabel">Simulation Speed: 100ms</label>
                        <input type="range" id="simulationSpeed" min="1" max="5000" step="10" value="100">
                        <div class="speed-display" id="speedDisplay">100ms</div>
                    </div>
                    
                    <div style="margin-top: 1rem; padding-top: 1rem;">
                        <div class="button-row" style="margin-bottom: 1rem;">
                            <button class="btn btn-primary" id="startTraining">Start</button>
                            <button class="btn btn-danger" id="stopTraining">Stop</button>
                            <button class="btn btn-secondary" id="continueTraining">Continue</button>
                            <button class="btn btn-secondary" id="newTraining" style="display: none;">New Training</button>
                            <button class="btn btn-secondary" id="startNewRound" style="display: none;">New Round</button>
                        </div>
                        
                        <div class="collapsible-title collapsed" id="learningParametersToggle" style="font-size: 0.9rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Learning Parameters</div>
                        <div class="collapsible-content collapsed" id="learningParametersContent">
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h5 style="font-size: 0.8rem; color: #7FE9E1; margin-bottom: 0.3rem; text-transform: uppercase;">Cat (Predator)</h5>
                            
                            <div class="param-item">
                                <label for="catLearningRateSlider" id="catLearningRateLabel">Learning Rate: 0.11</label>
                                <input type="range" id="catLearningRateSlider" min="0.01" max="0.5" step="0.01" value="0.11">
                                <div class="speed-display" id="catLearningRateDisplay">0.11</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catEpsilonSlider" id="catEpsilonLabel">Exploration Rate: 0.35</label>
                                <input type="range" id="catEpsilonSlider" min="0.05" max="0.8" step="0.05" value="0.35">
                                <div class="speed-display" id="catEpsilonDisplay">0.35</div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h5 style="font-size: 0.8rem; color: #7FE9E1; margin-bottom: 0.3rem; text-transform: uppercase;">Mouse (Prey)</h5>
                            
                            <div class="param-item">
                                <label for="mouseLearningRateSlider" id="mouseLearningRateLabel">Learning Rate: 0.12</label>
                                <input type="range" id="mouseLearningRateSlider" min="0.01" max="0.5" step="0.01" value="0.12">
                                <div class="speed-display" id="mouseLearningRateDisplay">0.12</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseEpsilonSlider" id="mouseEpsilonLabel">Exploration Rate: 0.25</label>
                                <input type="range" id="mouseEpsilonSlider" min="0.05" max="0.8" step="0.05" value="0.25">
                                <div class="speed-display" id="mouseEpsilonDisplay">0.25</div>
                            </div>
                        </div>
                        
                        <div style="padding-top: 0.5rem;">
                            <h5 style="font-size: 0.8rem; color: #7FE9E1; margin-bottom: 0.3rem; text-transform: uppercase;">Shared Parameters</h5>
                            
                            <div class="param-item">
                                <label for="discountFactorSlider" id="discountFactorLabel">Discount Factor: 0.95</label>
                                <input type="range" id="discountFactorSlider" min="0.1" max="0.99" step="0.05" value="0.95">
                                <div class="speed-display" id="discountFactorDisplay">0.95</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="epsilonDecaySlider" id="epsilonDecayLabel">Exploration Decay: 0.995</label>
                                <input type="range" id="epsilonDecaySlider" min="0.990" max="0.999" step="0.001" value="0.995">
                                <div class="speed-display" id="epsilonDecayDisplay">0.995</div>
                            </div>
                        </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 1rem;">
                        <div class="collapsible-title collapsed" id="rewardsToggle" style="font-size: 0.9rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Reward Parameters</div>
                        <div class="collapsible-content collapsed" id="rewardsContent">
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h5 style="font-size: 0.8rem; color: #7FE9E1; margin-bottom: 0.3rem; text-transform: uppercase;">Cat (Predator) Rewards</h5>
                            
                            <div class="param-item">
                                <label for="catWinSlider" id="catWinLabel">Win Bonus: +500</label>
                                <input type="range" id="catWinSlider" min="100" max="1000" step="50" value="500">
                                <div class="speed-display" id="catWinDisplay">500</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catHuntingSlider" id="catHuntingLabel">Hunting (Visible): +8</label>
                                <input type="range" id="catHuntingSlider" min="1" max="20" step="1" value="8">
                                <div class="speed-display" id="catHuntingDisplay">8</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catExplorationSlider" id="catExplorationLabel">Exploration: +2</label>
                                <input type="range" id="catExplorationSlider" min="0" max="10" step="0.5" value="2">
                                <div class="speed-display" id="catExplorationDisplay">2</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catRetreatingSlider" id="catRetreatingLabel">Retreating: -1</label>
                                <input type="range" id="catRetreatingSlider" min="-10" max="0" step="0.1" value="-1">
                                <div class="speed-display" id="catRetreatingDisplay">-1</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catStandingStillSlider" id="catStandingStillLabel">Standing Still: -0.1</label>
                                <input type="range" id="catStandingStillSlider" min="-1" max="0" step="0.01" value="-0.1">
                                <div class="speed-display" id="catStandingStillDisplay">-0.1</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="catFailureSlider" id="catFailureLabel">Failure Penalty: -200</label>
                                <input type="range" id="catFailureSlider" min="-500" max="0" step="10" value="-200">
                                <div class="speed-display" id="catFailureDisplay">-200</div>
                            </div>
                        </div>
                        
                        <div style="margin-bottom: 0.8rem;">
                            <h5 style="font-size: 0.8rem; color: #7FE9E1; margin-bottom: 0.3rem; text-transform: uppercase;">Mouse (Prey) Rewards</h5>
                            
                            <div class="param-item">
                                <label for="mouseSurvivalSlider" id="mouseSurvivalLabel">Survival Bonus: +500</label>
                                <input type="range" id="mouseSurvivalSlider" min="100" max="1000" step="50" value="500">
                                <div class="speed-display" id="mouseSurvivalDisplay">500</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseCaughtSlider" id="mouseCaughtLabel">Caught Penalty: -500</label>
                                <input type="range" id="mouseCaughtSlider" min="-1000" max="-100" step="50" value="-500">
                                <div class="speed-display" id="mouseCaughtDisplay">-500</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseStrategicEscapeSlider" id="mouseStrategicEscapeLabel">Strategic Escape: +4</label>
                                <input type="range" id="mouseStrategicEscapeSlider" min="1" max="10" step="0.5" value="4">
                                <div class="speed-display" id="mouseStrategicEscapeDisplay">4</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseBlindEscapeSlider" id="mouseBlindEscapeLabel">Blind Escape: +2</label>
                                <input type="range" id="mouseBlindEscapeSlider" min="0" max="10" step="0.5" value="2">
                                <div class="speed-display" id="mouseBlindEscapeDisplay">2</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseApproachingDangerSlider" id="mouseApproachingDangerLabel">Approaching Danger: -2</label>
                                <input type="range" id="mouseApproachingDangerSlider" min="-10" max="0" step="0.1" value="-2">
                                <div class="speed-display" id="mouseApproachingDangerDisplay">-2</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseStandingStillVisibleSlider" id="mouseStandingStillVisibleLabel">Standing Still (Visible): -0.5</label>
                                <input type="range" id="mouseStandingStillVisibleSlider" min="-2" max="0" step="0.1" value="-0.5">
                                <div class="speed-display" id="mouseStandingStillVisibleDisplay">-0.5</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="mouseMovingTowardDangerSlider" id="mouseMovingTowardDangerLabel">Moving Toward Danger: -0.5</label>
                                <input type="range" id="mouseMovingTowardDangerSlider" min="-2" max="0" step="0.1" value="-0.5">
                                <div class="speed-display" id="mouseMovingTowardDangerDisplay">-0.5</div>
                            </div>
                        </div>
                        
                        <div style="font-style: italic; color: #7FE9E1; font-size: 0.7rem; text-align: center; margin-top: 0.5rem;">
                            Real-time reward tuning for balanced competitive gameplay
                        </div>
                        </div>
                    </div>
                </div>

                <div class="param-group">
                    <div class="collapsible-title collapsed" id="displayControlsToggle" style="font-size: 1.1rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Display Controls</div>
                    <div class="collapsible-content collapsed" id="displayControlsContent">
                    
                    <div class="param-row">
                        <span class="param-label">Toggle Render:</span>
                        <input type="checkbox" id="toggleRender" checked style="margin: 0;">
                    </div>
                    
                    <div class="param-row">
                        <span class="param-label">Toggle Vision:</span>
                        <input type="checkbox" id="toggleVision" checked style="margin: 0;">
                    </div>
                    
                    <div class="param-row">
                        <span class="param-label">Show Heat Map:</span>
                        <input type="checkbox" id="toggleHeatMap" style="margin: 0;">
                    </div>
                    
                    <div class="param-item">
                        <label for="heatMapIntensity">Heat Map Intensity</label>
                        <input type="range" id="heatMapIntensity" min="0.1" max="1.0" step="0.1" value="0.7">
                        <div class="speed-display" id="heatMapIntensityDisplay">0.7</div>
                    </div>
                    
                    <div class="button-row" style="margin-top: 0.5rem;">
                        <button class="btn btn-secondary" id="clearHeatMap" style="font-size: 0.8rem;">Clear Heat Map</button>
                    </div>
                    </div>
                </div>

                <!-- Environment Presets Section -->
                <div class="param-group">
                    <h4 style="font-size: 0.9rem; margin-bottom: 0.3rem; color: #7FE9E1; text-transform: uppercase;">Presets</h4>
                    
                    <div class="button-row" style="margin-bottom: 0.3rem;">
                        <button class="btn btn-secondary" id="presetBeginner" style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">Begin</button>
                        <button class="btn btn-secondary" id="presetIntermediate" style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">Inter</button>
                        <button class="btn btn-secondary" id="presetExpert" style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">Expert</button>
                        <button class="btn btn-secondary" id="presetChaos" style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">Chaos</button>
                    </div>
                    
                    <div class="button-row">
                        <button class="btn btn-secondary" id="downloadTraining" style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">Download</button>
                        <button class="btn btn-secondary" id="uploadTrainingButton" style="font-size: 0.7rem; padding: 0.2rem 0.4rem;">Upload</button>
                    </div>
                    <input type="file" id="uploadTraining" class="file-input" accept=".json" style="display: none;">
                </div>
            </div>

            <!-- Middle Column: Simulation View -->
            <div class="simulation-view">
                <!-- Welcome Screen -->
                <div id="welcomeScreen" style="width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: flex-start; align-items: flex-start; padding: 0.8rem; padding-top: 3rem; color: #7FE9E1; overflow-y: auto;">
                    <div style="width: 100%; text-align: left; line-height: 1.3; font-size: 0.8rem;">
                        <div style="margin-bottom: 1rem; text-align: center;">
                            <h2 style="color: #7FE9E1; margin-bottom: 0.3rem; font-size: 1.2rem; font-weight: bold;" data-decrypt="heading">AI Predator-Prey Research Platform</h2>
                            <p style="margin-bottom: 0.5rem; font-size: 0.75rem; opacity: 0.9;" data-decrypt="content">Advanced reinforcement learning simulation with real-time analytics</p>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                            <div style="background: rgba(75, 86, 106, 0.1); padding: 0.6rem; border-radius: 4px; border-left: 3px solid #7FE9E1;">
                                <h4 style="color: #7FE9E1; margin-bottom: 0.3rem; font-size: 0.85rem;" data-decrypt="heading">The Simulation</h4>
                                <p style="margin-bottom: 0.2rem; font-size: 0.75rem;" data-decrypt="content">Cat (C) hunts Mouse (M) in a grid with Obstacles (O)</p>
                                <p style="font-size: 0.7rem; opacity: 0.8;" data-decrypt="content">Both agents use Q-Learning to develop optimal strategies</p>
                            </div>
                            
                            <div style="background: rgba(75, 86, 106, 0.1); padding: 0.6rem; border-radius: 4px; border-left: 3px solid #7FE9E1;">
                                <h4 style="color: #7FE9E1; margin-bottom: 0.3rem; font-size: 0.85rem;" data-decrypt="heading">Controls</h4>
                                <p style="margin-bottom: 0.2rem; font-size: 0.75rem;" data-decrypt="content">Adjust parameters in real-time during training</p>
                                <p style="font-size: 0.7rem; opacity: 0.8;" data-decrypt="content">Individual learning rates for each agent</p>
                            </div>
                        </div>
                        
                        <div style="background: rgba(75, 86, 106, 0.1); padding: 0.6rem; border-radius: 4px; margin-bottom: 1rem;">
                            <h4 style="color: #7FE9E1; margin-bottom: 0.3rem; font-size: 0.85rem;" data-decrypt="heading">Balanced Reward System</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; font-size: 0.7rem;">
                                <div>
                                    <p style="margin-bottom: 0.2rem;"><strong>Cat Rewards:</strong></p>
                                    <p style="margin-left: 0.3rem; margin-bottom: 0.1rem;" id="welcomeCatRewards" data-decrypt="content">Win: +500, Hunting: +8, Exploration: +2</p>
                                </div>
                                <div>
                                    <p style="margin-bottom: 0.2rem;"><strong>Mouse Rewards:</strong></p>
                                    <p style="margin-left: 0.3rem; margin-bottom: 0.1rem;" id="welcomeMouseRewards" data-decrypt="content">Survival: +500, Strategic escape: +4</p>
                                </div>
                            </div>
                        </div>
                        
                        <div style="background: rgba(75, 86, 106, 0.1); padding: 0.6rem; border-radius: 4px; margin-bottom: 1rem;">
                            <h4 style="color: #7FE9E1; margin-bottom: 0.3rem; font-size: 0.85rem;" data-decrypt="heading">Training Persistence</h4>
                            <p style="margin-bottom: 0.3rem; font-size: 0.75rem;" data-decrypt="content">Save and restore complete training sessions with full state preservation</p>
                            <div style="font-size: 0.7rem; opacity: 0.9;">
                                <p style="margin-bottom: 0.1rem;">• Download: Exports Q-tables, episode history, environment config</p>
                                <p style="margin-bottom: 0.1rem;">• Upload: Restores exact game environment and button states</p>
                            </div>
                        </div>
                        
                        <div style="text-align: center; margin-top: 1rem; padding-top: 0.5rem; border-top: 1px solid rgba(75, 86, 106, 0.3);">
                            <p style="font-size: 0.7rem; opacity: 0.7;" data-decrypt="content">Click <strong>Start</strong> to begin training • Use <strong>Ctrl+M</strong> for advanced settings</p>
                        </div>
                    </div>
                </div>
                
                <!-- Simulation Grid (Hidden Initially) -->
                <div id="gridView" style="width: 100%; height: 100%; display: none; flex-direction: column;">
                    <div class="grid-container">
                        <pre class="grid" id="gameGrid"></pre>
                    </div>
                </div>
                
                <!-- Separate Footer/Legend -->
                <div class="footer-container">
                    <div class="legend" id="gridLegend">
                        <span class="cat">C: CAT(S)</span> | 
                        <span class="mouse">M: MOUSE (MICE)</span> | 
                        <span class="obstacle">O: OBSTACLE</span> | 
                        <span class="cat-vision">?: VISION</span> | 
                        <span class="mouse-vision">!: VISION OVERLAP</span>
                    </div>
                </div>
                
                <div class="chart-container" id="chartContainer">
                    <button class="chart-close-btn" id="chartCloseBtn">×</button>
                    <div class="chart-stats" id="chartStats" style="padding: 1rem; background: rgba(16, 24, 39, 0.9); color: #7FE9E1; font-size: 0.8rem; border-bottom: 1px solid #4B566A; display: none;">
                        <h4 style="color: #7FE9E1; margin-bottom: 0.5rem;">Training Summary</h4>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;">
                            <div>
                                <div><strong>Fastest Round:</strong> <span id="fastestRound">-</span></div>
                                <div><strong>Slowest Round:</strong> <span id="slowestRound">-</span></div>
                                <div><strong>Average Round:</strong> <span id="averageRound">-</span></div>
                            </div>
                            <div>
                                <div><strong>Min Steps:</strong> <span id="minSteps">-</span></div>
                                <div><strong>Max Steps:</strong> <span id="maxSteps">-</span></div>
                                <div><strong>Total Episodes:</strong> <span id="totalEpisodes">-</span></div>
                            </div>
                            <div>
                                <div><strong>Best Cat Score:</strong> <span id="bestCatScore">-</span></div>
                                <div><strong>Best Mouse Score:</strong> <span id="bestMouseScore">-</span></div>
                                <div><strong>Final Win Rates:</strong> <span id="finalWinRates">-</span></div>
                            </div>
                        </div>
                    </div>
                    <canvas id="performanceChart"></canvas>
                </div>
            </div>

            <!-- Right Column: Analytics Panel -->
            <div class="analytics-panel draggable-panel" id="analyticsPanel">
                <h3 class="section-title">Analytics Panel</h3>
                
                <div class="stat-row">
                    <span class="stat-label">Episode:</span>
                    <span class="stat-value" id="currentEpisode">0</span>
                </div>
                
                <div class="stat-row">
                    <span class="stat-label">Step:</span>
                    <span class="stat-value" id="currentStep">0</span>
                </div>
                
                
                <div class="stat-row">
                    <span class="stat-label">Cat Wins:</span>
                    <span class="stat-value" id="catWins">0</span>
                </div>
                
                <div class="stat-row">
                    <span class="stat-label">Mouse Wins:</span>
                    <span class="stat-value" id="mouseWins">0</span>
                </div>

                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #4B566A;">
                    <div class="stat-row">
                        <span class="stat-label">Cat Win Rate:</span>
                        <span class="stat-value" id="catWinRate">0%</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Mouse Win Rate:</span>
                        <span class="stat-value" id="mouseWinRate">0%</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Avg Steps:</span>
                        <span class="stat-value" id="avgSteps">0</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Training Status:</span>
                        <span class="stat-value" id="trainingStatus">Ready</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Progress:</span>
                        <span class="stat-value" id="trainingProgress">0%</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Cat Score:</span>
                        <span class="stat-value" id="currentCatScore">0</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Mouse Score:</span>
                        <span class="stat-value" id="currentMouseScore">0</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Cat Exploration:</span>
                        <span class="stat-value" id="currentCatEpsilon">35.0%</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Mouse Exploration:</span>
                        <span class="stat-value" id="currentMouseEpsilon">25.0%</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Knowledge Size:</span>
                        <span class="stat-value" id="knowledgeSize">0 states</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Obstacles:</span>
                        <span class="stat-value" id="obstacleCountDisplay">0</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Learning Efficiency:</span>
                        <span class="stat-value" id="learningEfficiency">-</span>
                    </div>
                </div>
                
                <!-- Performance Prediction Section -->
                <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #4B566A;">
                    <h4 style="font-size: 0.9rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Performance Trends</h4>
                    
                    <div class="stat-row">
                        <span class="stat-label">Win Rate Trend:</span>
                        <span class="stat-value" id="winRateTrend">-</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Predicted Winner:</span>
                        <span class="stat-value" id="predictedWinner">-</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Confidence:</span>
                        <span class="stat-value" id="predictionConfidence">-</span>
                    </div>
                    
                    <div class="stat-row">
                        <span class="stat-label">Convergence:</span>
                        <span class="stat-value" id="convergenceStatus">-</span>
                    </div>
                </div>
                
                <!-- Settings Section -->
                <div class="settings-section-hidden" id="settingsSection" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #4B566A;">
                    <div class="collapsible-title collapsed" id="settingsToggle" style="font-size: 0.9rem; margin-bottom: 0.5rem; color: #7FE9E1; text-transform: uppercase;">Settings</div>
                    <div class="collapsible-content collapsed" id="settingsContent">
                        
                        <!-- Grid Font Controls -->
                        <div style="margin-bottom: 1rem;">
                            <h4 style="font-size: 0.8rem; margin-bottom: 0.5rem; color: #7FE9E1;">GRID FONT</h4>
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Font Size:</span>
                                    <span class="param-value inline-editable" data-type="number" data-min="0.5" data-max="3" data-input-id="fontSize" data-callback="updateNumericValue">1.6</span>rem
                                </div>
                                <input type="range" id="fontSize" min="0.5" max="3" step="0.1" value="1.6" style="display: none;">
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Horizontal Spacing:</span>
                                    <span class="param-value inline-editable" data-type="number" data-min="-0.5" data-max="1" data-input-id="horizontalSpacing" data-callback="updateNumericValue">0.4</span>rem
                                </div>
                                <input type="range" id="horizontalSpacing" min="-0.5" max="1" step="0.1" value="0.4" style="display: none;">
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Vertical Spacing:</span>
                                    <span class="param-value inline-editable" data-type="number" data-min="0.5" data-max="2" data-input-id="verticalSpacing" data-callback="updateNumericValue">1.3</span>rem
                                </div>
                                <input type="range" id="verticalSpacing" min="0.5" max="2" step="0.1" value="1.3" style="display: none;">
                            </div>
                        </div>

                        <!-- CRT Effects -->
                        <div style="margin-bottom: 1rem;">
                            <h4 style="font-size: 0.8rem; margin-bottom: 0.5rem; color: #7FE9E1;">CRT EFFECTS</h4>
                            <div class="checkbox-item">
                                <input type="checkbox" id="crtEnabled" checked>
                                <label for="crtEnabled">Enable</label>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtGlow">Phosphor Glow</label>
                                <input type="range" id="crtGlow" min="0" max="3" step="0.1" value="0.7">
                                <div class="speed-display" id="glowDisplay">0.7</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtScanlines">Scanlines</label>
                                <input type="range" id="crtScanlines" min="0" max="1" step="0.1" value="0.9">
                                <div class="speed-display" id="scanlinesDisplay">0.9</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtChromaticAberration">Chromatic Aberration</label>
                                <input type="range" id="crtChromaticAberration" min="0" max="10" step="0.5" value="8">
                                <div class="speed-display" id="chromaticDisplay">8</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="shaderScreenWidth">Screen Width</label>
                                <input type="range" id="shaderScreenWidth" min="240" max="1920" step="10" value="1920">
                                <div class="speed-display" id="screenWidthDisplay">1920</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="shaderScreenHeight">Screen Height</label>
                                <input type="range" id="shaderScreenHeight" min="135" max="1080" step="5" value="1080">
                                <div class="speed-display" id="screenHeightDisplay">1080</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="captureScale">Capture Resolution Scale</label>
                                <input type="range" id="captureScale" min="0.2" max="2.0" step="0.1" value="1.2">
                                <div class="speed-display" id="captureScaleDisplay">1.2</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="captureThrottle">Update Frequency (ms)</label>
                                <input type="range" id="captureThrottle" min="50" max="1000" step="50" value="100">
                                <div class="speed-display" id="captureThrottleDisplay">100</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="textureFiltering">Texture Filtering</label>
                                <select id="textureFiltering">
                                    <option value="NEAREST">Sharp (NEAREST)</option>
                                    <option value="LINEAR">Smooth (LINEAR)</option>
                                </select>
                            </div>
                            
                            <div class="param-item">
                                <label for="centerX">Center X Offset</label>
                                <input type="range" id="centerX" min="-0.5" max="0.5" step="0.01" value="0">
                                <div class="speed-display" id="centerXDisplay">0</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="centerY">Center Y Offset</label>
                                <input type="range" id="centerY" min="-0.5" max="0.5" step="0.01" value="0">
                                <div class="speed-display" id="centerYDisplay">0</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtVignette">Vignette</label>
                                <input type="range" id="crtVignette" min="0" max="10" step="0.5" value="5">
                                <div class="speed-display" id="vignetteDisplay">5</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtContrast">Contrast</label>
                                <input type="range" id="crtContrast" min="0.5" max="2" step="0.1" value="1">
                                <div class="speed-display" id="contrastDisplay">1</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtBrightness">Brightness</label>
                                <input type="range" id="crtBrightness" min="0.3" max="1.5" step="0.05" value="1.05">
                                <div class="speed-display" id="brightnessDisplay">1.05</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtSaturation">Saturation</label>
                                <input type="range" id="crtSaturation" min="0" max="2" step="0.1" value="1.1">
                                <div class="speed-display" id="saturationDisplay">1.1</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtFlicker">Screen Flicker</label>
                                <input type="range" id="crtFlicker" min="0" max="1" step="0.05" value="0.8">
                                <div class="speed-display" id="flickerDisplay">0.8</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtNoise">Static Noise</label>
                                <input type="range" id="crtNoise" min="0" max="1" step="0.05" value="0.7">
                                <div class="speed-display" id="noiseDisplay">0.7</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="crtPixels">Pixel Grid</label>
                                <input type="range" id="crtPixels" min="0" max="1" step="0.1" value="0">
                                <div class="speed-display" id="pixelsDisplay">0</div>
                            </div>
                        </div>
                        
                        <!-- Text Pressure -->
                        <div style="margin-bottom: 1rem;">
                            <h4 style="font-size: 0.8rem; margin-bottom: 0.5rem; color: #7FE9E1;">TEXT PRESSURE</h4>
                            <div class="checkbox-item">
                                <input type="checkbox" id="textPressureEnabled" checked>
                                <label for="textPressureEnabled">Enable</label>
                            </div>
                            
                            <div class="param-item">
                                <label for="textPressureRange">Effect Range</label>
                                <input type="range" id="textPressureRange" min="50" max="500" value="111">
                                <div class="speed-display" id="rangeDisplay">111px</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="textPressureSmoothing">Smoothing</label>
                                <input type="range" id="textPressureSmoothing" min="5" max="30" value="30">
                                <div class="speed-display" id="smoothingDisplay">30</div>
                            </div>
                        </div>
                            
                        <div class="param-item">
                            <label for="textPressureMinWeight">Min Font Weight</label>
                            <input type="range" id="textPressureMinWeight" min="1" max="1500" step="1" value="1">
                            <div class="speed-display" id="minWeightDisplay">1</div>
                        </div>
                        
                        <div class="param-item">
                            <label for="textPressureMaxWeight">Max Font Weight</label>
                            <input type="range" id="textPressureMaxWeight" min="1" max="1500" step="1" value="1500">
                            <div class="speed-display" id="maxWeightDisplay">1500</div>
                        </div>
                        
                        <div class="param-item">
                            <label for="textPressureMinOpacity">Min Opacity</label>
                            <input type="range" id="textPressureMinOpacity" min="0" max="1" step="0.1" value="0.8">
                            <div class="speed-display" id="minOpacityDisplay">0.8</div>
                        </div>
                        
                        <div class="param-item">
                            <label for="textPressureMaxOpacity">Max Opacity</label>
                            <input type="range" id="textPressureMaxOpacity" min="0.5" max="1" step="0.1" value="1">
                            <div class="speed-display" id="maxOpacityDisplay">1</div>
                        </div>
                        
                        <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #4B566A;">
                            <h4 style="font-size: 1.1rem; margin-bottom: 0.3rem; color: #7FE9E1; text-transform: uppercase;">Text Effects</h4>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="textPressureBold" checked>
                                <label for="textPressureBold">Bold Weight Effect</label>
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="textPressureItalic">
                                <label for="textPressureItalic">Italic Effect</label>
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="textPressureStrike">
                                <label for="textPressureStrike">Strikethrough Effect</label>
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="textPressureUnderline">
                                <label for="textPressureUnderline">Underline Effect</label>
                            </div>
                            
                            <div class="checkbox-item">
                                <input type="checkbox" id="textPressureScale" checked>
                                <label for="textPressureScale">Scale Effect</label>
                            </div>
                        </div>
                        
                        <div style="margin-top: 0.5rem;">
                            <div class="param-item">
                                <label for="textPressureScaleMin">Min Scale</label>
                                <input type="range" id="textPressureScaleMin" min="0.5" max="1" step="0.1" value="0.7">
                                <div class="speed-display" id="scaleMinDisplay">0.7</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="textPressureScaleMax">Max Scale</label>
                                <input type="range" id="textPressureScaleMax" min="1" max="3" step="0.1" value="1.3">
                                <div class="speed-display" id="scaleMaxDisplay">1.3</div>
                            </div>
                        </div>
                        
                        <!-- Layout Positioning -->
                        <div class="settings-section-hidden" style="margin-bottom: 1rem;">
                            <div class="collapsible-title collapsed" id="layoutToggle" style="font-size: 0.8rem; margin-bottom: 0.5rem; color: #7FE9E1; cursor: pointer;">LAYOUT POSITIONING</div>
                            <div class="collapsible-content collapsed" id="layoutContent">
                            
                            <div class="param-item">
                                <label for="headerVerticalPos">Header Position</label>
                                <input type="range" id="headerVerticalPos" min="-50" max="100" step="5" value="5">
                                <div class="speed-display" id="headerPosDisplay">5px</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="leftPanelVerticalPos">Left Panel Position</label>
                                <input type="range" id="leftPanelVerticalPos" min="-100" max="200" step="5" value="100">
                                <div class="speed-display" id="leftPanelPosDisplay">100px</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="rightPanelVerticalPos">Right Panel Position</label>
                                <input type="range" id="rightPanelVerticalPos" min="-100" max="200" step="5" value="100">
                                <div class="speed-display" id="rightPanelPosDisplay">100px</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="centerPanelVerticalPos">Center Panel Position</label>
                                <input type="range" id="centerPanelVerticalPos" min="-100" max="200" step="5" value="-85">
                                <div class="speed-display" id="centerPanelPosDisplay">-85px</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="footerVerticalPos">Footer Position</label>
                                <input type="range" id="footerVerticalPos" min="0" max="10" step="1" value="5">
                                <div class="speed-display" id="footerPosDisplay">5rem</div>
                            </div>
                            
                            </div>
                        </div>
                        
                        <!-- Typography Controls -->
                        <div class="settings-section-compact settings-section-hidden" style="margin-bottom: 0.5rem;">
                            <div class="collapsible-title collapsed" id="typographyToggle" style="font-size: 0.7rem; margin-bottom: 0.3rem; color: #7FE9E1; cursor: pointer;">TYPOGRAPHY</div>
                            <div class="collapsible-content collapsed" id="typographyContent">
                            
                            <div class="param-item">
                                <label for="showValueDisplays">Show Value Displays</label>
                                <input type="checkbox" id="showValueDisplays" class="custom-checkbox">
                            </div>
                            
                            <div class="param-item">
                                <label for="gridCharSize">Grid Character Size</label>
                                <input type="range" id="gridCharSize" min="0.5" max="3" step="0.1" value="1.6">
                                <div class="speed-display" id="gridCharDisplay">1.6rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="headerTitleSize">Main Header</label>
                                <input type="range" id="headerTitleSize" min="2" max="6" step="0.1" value="5.7">
                                <div class="speed-display" id="headerTitleDisplay">5.7rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="sectionTitleSize">Section Titles</label>
                                <input type="range" id="sectionTitleSize" min="1" max="3" step="0.1" value="1.4">
                                <div class="speed-display" id="sectionTitleDisplay">1.4rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="collapsibleTitleSize">Collapsible Titles</label>
                                <input type="range" id="collapsibleTitleSize" min="0.8" max="2" step="0.1" value="0.9">
                                <div class="speed-display" id="collapsibleTitleDisplay">0.9rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="subsectionSize">Subsection Headers</label>
                                <input type="range" id="subsectionSize" min="0.6" max="1.5" step="0.1" value="1">
                                <div class="speed-display" id="subsectionDisplay">1rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="paramLabelSize">Parameter Labels</label>
                                <input type="range" id="paramLabelSize" min="0.5" max="1.2" step="0.1" value="0.7">
                                <div class="speed-display" id="paramLabelDisplay">0.7rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="paramRowSize">Parameter Rows</label>
                                <input type="range" id="paramRowSize" min="0.5" max="1.2" step="0.1" value="0.8">
                                <div class="speed-display" id="paramRowDisplay">0.8rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="buttonSize">Buttons</label>
                                <input type="range" id="buttonSize" min="0.5" max="1.2" step="0.1" value="0.7">
                                <div class="speed-display" id="buttonDisplay">0.7rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="statsSize">Stats/Analytics</label>
                                <input type="range" id="statsSize" min="0.5" max="1.2" step="0.1" value="0.8">
                                <div class="speed-display" id="statsDisplay">0.8rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="speedDisplaySize">Value Displays</label>
                                <input type="range" id="speedDisplaySize" min="0.4" max="1" step="0.1" value="0.8">
                                <div class="speed-display" id="speedDisplayDisplay">0.8rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="legendSize">Game Legend/Footer</label>
                                <input type="range" id="legendSize" min="0.6" max="1.5" step="0.1" value="0.9">
                                <div class="speed-display" id="legendDisplay">0.9rem</div>
                            </div>
                            
                            <div class="param-item">
                                <label for="numberInputSize">Number Inputs</label>
                                <input type="range" id="numberInputSize" min="0.4" max="1" step="0.1" value="0.8">
                                <div class="speed-display" id="numberInputDisplay">0.8rem</div>
                            </div>
                            
                            </div>
                        </div>

                        <!-- Character Customization -->
                        <div class="settings-section-compact settings-section-hidden" style="margin-bottom: 0.5rem;">
                            <div class="collapsible-title collapsed" id="charactersToggle" style="font-size: 0.7rem; margin-bottom: 0.3rem; color: #7FE9E1; cursor: pointer;">CHARACTERS</div>
                            <div class="collapsible-content collapsed" id="charactersContent">
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Empty Space Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="empty" data-callback="updateCharacterValue">·</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Empty Space Font Size:</span>
                                    <span class="param-value inline-editable" data-type="number" data-min="0.5" data-max="2.0" data-input-id="emptyCharSize" data-callback="updateNumericValue">1.6</span>x
                                </div>
                                <input type="range" id="emptyCharSize" min="0.5" max="2.0" step="0.1" value="1.6" style="display: none;">
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Cat Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="cat" data-callback="updateCharacterValue">C</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Mouse Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="mouse" data-callback="updateCharacterValue">M</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Obstacle Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="obstacle" data-callback="updateCharacterValue">O</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Cat Vision Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="unknown" data-callback="updateCharacterValue">?</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Mouse Vision Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="unknown" data-callback="updateCharacterValue">?</span>
                                </div>
                            </div>
                            
                            <div class="param-item">
                                <div class="param-row">
                                    <span class="param-label">Vision Collision Character:</span>
                                    <span class="param-value inline-editable" data-type="char" data-char-type="error" data-callback="updateCharacterValue">!</span>
                                </div>
                            </div>
                            
                            <div style="margin-top: 0.5rem; padding-top: 0.5rem; border-top: 1px solid #4B566A;">
                                <button class="btn btn-secondary" id="resetTypography">Reset to Defaults</button>
                            </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
            </div>
        </div>
    </div>

    <script>
        class LumonResearch {
            constructor() {
                this.gridWidth = 64;
                this.gridHeight = 32;
                this.grid = [];
                
                // Agent positions
                this.catPos = { x: 0, y: 0 };
                this.mousePos = { x: 0, y: 0 };
                
                this.obstacles = [];
                this.isTraining = false;
                this.isPaused = false;
                this.currentEpisode = 0;
                this.currentStep = 0;
                this.catWins = 0;
                this.mouseWins = 0;
                this.totalSteps = 0;
                this.episodeData = [];
                this.currentCatScore = 0;
                this.currentMouseScore = 0;
                
                // Generate obstacles once for entire training session
                this.generatePersistentObstacles();
                this.originalObstacles = JSON.parse(JSON.stringify(this.obstacles)); // Deep copy
                this.performanceChart = null;
                
                // Q-learning parameters
                this.catQTable = {};
                this.mouseQTable = {};
                
                // Individual learning parameters for cat and mouse
                this.catLearningRate = 0.11;
                this.mouseLearningRate = 0.12;
                this.catEpsilon = 0.35;
                this.mouseEpsilon = 0.25;
                this.catInitialEpsilon = 0.35;
                this.mouseInitialEpsilon = 0.25;
                
                // Shared parameters
                this.discountFactor = 0.95;
                this.minEpsilon = 0.05;
                this.epsilonDecay = 0.995;
                
                // Dynamic rotation for cone vision
                this.catRotation = 0;   // Current cat facing direction
                this.mouseRotation = 180; // Current mouse facing direction
                
                // User-configurable reward values
                this.rewards = {
                    catWin: 500,
                    catHunting: 8,
                    catExploration: 2,
                    catRetreating: -1,
                    catStandingStill: -0.1,
                    catFailure: -200,
                    mouseSurvival: 500,
                    mouseCaught: -500,
                    mouseStrategicEscape: 4,
                    mouseBlindEscape: 2,
                    mouseApproachingDanger: -2,
                    mouseStandingStillVisible: -0.5,
                    mouseMovingTowardDanger: -0.5
                };
                
                // Heat map tracking for strategy visualization
                this.catHeatMap = {};    // Track cat position frequency
                this.mouseHeatMap = {};  // Track mouse position frequency
                this.showHeatMap = false; // Toggle for heat map display
                this.heatMapIntensity = 0.7; // Heat map opacity
                this.heatMapCache = null; // Cache for heat map max values
                this.renderCount = 0; // Counter for rendering optimizations
                
                // Initialize agent counts from UI or defaults
                
                this.initializeEventListeners();
                this.initializeGrid();
                this.updateSpeedDisplay();
                this.updateVisionAngleDisplay();
                this.updateCatRotationDisplay();
                this.updateMouseRotationDisplay();
                this.updateCatLearningRate();
                this.updateCatEpsilon();
                this.updateMouseLearningRate();
                this.updateMouseEpsilon();
                this.updateWelcomeRewardDisplay(); // Initialize welcome page reward display
                this.updateButtonStates(); // Initialize button states
                this.updateCRTEffect(); // Initialize CRT effect
                
                // Initialize UI enhancements
                setTimeout(() => this.addKeyboardIndicator(), 1000); // Add after page loads
            }

            initializeEventListeners() {
                document.getElementById('startTraining').addEventListener('click', () => this.startTraining());
                document.getElementById('stopTraining').addEventListener('click', () => this.stopTraining());
                document.getElementById('continueTraining').addEventListener('click', () => this.continueTraining());
                document.getElementById('newTraining').addEventListener('click', () => this.startNewTraining());
                document.getElementById('startNewRound').addEventListener('click', () => this.startNewRound());
                document.getElementById('downloadTraining').addEventListener('click', () => this.downloadTraining());
                document.getElementById('uploadTrainingButton').addEventListener('click', () => this.triggerUpload());
                document.getElementById('simulationSpeed').addEventListener('input', () => this.updateSpeedDisplay());
                
                // Cone Vision Controls  
                document.getElementById('visionAngle').addEventListener('input', () => this.updateVisionAngleDisplay());
                
                // Individual Learning Parameter Controls
                document.getElementById('catLearningRateSlider').addEventListener('input', () => this.updateCatLearningRate());
                document.getElementById('catEpsilonSlider').addEventListener('input', () => this.updateCatEpsilon());
                document.getElementById('mouseLearningRateSlider').addEventListener('input', () => this.updateMouseLearningRate());
                document.getElementById('mouseEpsilonSlider').addEventListener('input', () => this.updateMouseEpsilon());
                
                // Reward Parameter Controls
                document.getElementById('catWinSlider').addEventListener('input', () => this.updateRewardParameter('catWin'));
                document.getElementById('catHuntingSlider').addEventListener('input', () => this.updateRewardParameter('catHunting'));
                document.getElementById('catExplorationSlider').addEventListener('input', () => this.updateRewardParameter('catExploration'));
                document.getElementById('catRetreatingSlider').addEventListener('input', () => this.updateRewardParameter('catRetreating'));
                document.getElementById('catStandingStillSlider').addEventListener('input', () => this.updateRewardParameter('catStandingStill'));
                document.getElementById('catFailureSlider').addEventListener('input', () => this.updateRewardParameter('catFailure'));
                document.getElementById('mouseSurvivalSlider').addEventListener('input', () => this.updateRewardParameter('mouseSurvival'));
                document.getElementById('mouseCaughtSlider').addEventListener('input', () => this.updateRewardParameter('mouseCaught'));
                document.getElementById('mouseStrategicEscapeSlider').addEventListener('input', () => this.updateRewardParameter('mouseStrategicEscape'));
                document.getElementById('mouseBlindEscapeSlider').addEventListener('input', () => this.updateRewardParameter('mouseBlindEscape'));
                document.getElementById('mouseApproachingDangerSlider').addEventListener('input', () => this.updateRewardParameter('mouseApproachingDanger'));
                document.getElementById('mouseStandingStillVisibleSlider').addEventListener('input', () => this.updateRewardParameter('mouseStandingStillVisible'));
                document.getElementById('mouseMovingTowardDangerSlider').addEventListener('input', () => this.updateRewardParameter('mouseMovingTowardDanger'));
                
                // Heat Map Controls
                document.getElementById('toggleHeatMap').addEventListener('change', () => this.toggleHeatMap());
                document.getElementById('heatMapIntensity').addEventListener('input', () => this.updateHeatMapIntensity());
                document.getElementById('clearHeatMap').addEventListener('click', () => this.clearHeatMap());
                
                // Environment Preset Controls
                document.getElementById('presetBeginner').addEventListener('click', () => this.loadPreset('beginner'));
                document.getElementById('presetIntermediate').addEventListener('click', () => this.loadPreset('intermediate'));
                document.getElementById('presetExpert').addEventListener('click', () => this.loadPreset('expert'));
                document.getElementById('presetChaos').addEventListener('click', () => this.loadPreset('chaos'));
                
                // Enhanced Keyboard Shortcuts
                document.addEventListener('keydown', (e) => {
                    // Prevent shortcuts during text input
                    if (e.target.tagName === 'INPUT' && e.target.type === 'text') return;
                    
                    // Ctrl + M: Toggle Settings
                    if (e.ctrlKey && e.key === 'm') {
                        e.preventDefault();
                        this.toggleSettingsVisibility();
                    }
                    
                    // Spacebar: Start/Stop Training
                    if (e.code === 'Space' && !e.ctrlKey && !e.altKey) {
                        e.preventDefault();
                        if (this.isTraining) {
                            this.stopTraining();
                        } else {
                            this.startTraining();
                        }
                    }
                    
                    // P: Pause/Continue Training
                    if (e.key === 'p' && !e.ctrlKey && !e.altKey) {
                        e.preventDefault();
                        if (this.isTraining && !this.isPaused) {
                            this.isPaused = true;
                            document.getElementById('trainingStatus').textContent = 'Paused';
                        } else if (this.isPaused) {
                            this.continueTraining();
                        }
                    }
                    
                    // R: Reset/New Round
                    if (e.key === 'r' && !e.ctrlKey && !e.altKey) {
                        e.preventDefault();
                        this.startNewRound();
                    }
                    
                    // H: Toggle Heat Map
                    if (e.key === 'h' && !e.ctrlKey && !e.altKey) {
                        e.preventDefault();
                        const heatMapToggle = document.getElementById('toggleHeatMap');
                        heatMapToggle.checked = !heatMapToggle.checked;
                        this.toggleHeatMap();
                    }
                    
                    // V: Toggle Vision
                    if (e.key === 'v' && !e.ctrlKey && !e.altKey) {
                        e.preventDefault();
                        const visionToggle = document.getElementById('toggleVision');
                        visionToggle.checked = !visionToggle.checked;
                    }
                    
                    // Ctrl + D: Download Training Data
                    if (e.ctrlKey && e.key === 'd') {
                        e.preventDefault();
                        this.downloadTraining();
                    }
                    
                    
                    // Arrow Keys: Adjust Speed (when Ctrl is held)
                    if (e.ctrlKey && (e.key === 'ArrowUp' || e.key === 'ArrowDown')) {
                        e.preventDefault();
                        const speedSlider = document.getElementById('simulationSpeed');
                        const currentSpeed = parseInt(speedSlider.value);
                        const adjustment = e.key === 'ArrowUp' ? -50 : 50; // Lower number = faster
                        const newSpeed = Math.max(1, Math.min(5000, currentSpeed + adjustment));
                        speedSlider.value = newSpeed;
                        this.updateSpeedDisplay();
                    }
                    
                    // F1: Show Help
                    if (e.key === 'F1') {
                        e.preventDefault();
                        this.showKeyboardShortcuts();
                    }
                });
                document.getElementById('fontSize').addEventListener('input', () => this.updateFontSize());
                document.getElementById('horizontalSpacing').addEventListener('input', () => this.updateHorizontalSpacing());
                document.getElementById('verticalSpacing').addEventListener('input', () => this.updateVerticalSpacing());
                
                // CRT Controls
                const crtElements = [
                    'crtScanlines', 'crtGlow', 'crtPixels', 'crtContrast', 
                    'crtBrightness', 'crtSaturation', 'crtFlicker', 'crtNoise', 'crtWarp', 
                    'crtChromaticAberration', 'crtDistortion', 'crtVignette'
                ];
                crtElements.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener('input', () => this.updateCRTEffect());
                    }
                });
                
                const crtEnabled = document.getElementById('crtEnabled');
                if (crtEnabled) {
                    crtEnabled.addEventListener('change', () => this.updateCRTEffect());
                }
                
                // Text Pressure Controls
                document.getElementById('textPressureEnabled').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureRange').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureSmoothing').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureMinWeight').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureMaxWeight').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureMinOpacity').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureMaxOpacity').addEventListener('input', () => this.updateTextPressureSettings());
                
                // Text Effects Controls
                document.getElementById('textPressureBold').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureItalic').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureStrike').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureUnderline').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureScale').addEventListener('change', () => this.updateTextPressureSettings());
                document.getElementById('textPressureScaleMin').addEventListener('input', () => this.updateTextPressureSettings());
                document.getElementById('textPressureScaleMax').addEventListener('input', () => this.updateTextPressureSettings());
                
                // File upload handling - automatically load when file is selected
                document.getElementById('uploadTraining').addEventListener('change', (e) => {
                    const uploadButton = document.getElementById('uploadTrainingButton');
                    if (e.target.files.length > 0) {
                        uploadButton.textContent = 'Loading...';
                        this.uploadFile = e.target.files[0];
                        this.loadTraining(); // Automatically load the selected file
                    } else {
                        // Reset button if no file selected
                        uploadButton.textContent = 'Upload';
                        uploadButton.style.opacity = '1';
                    }
                });
                
                // Collapsible section handlers
                this.initializeCollapsibleSections();
                
                // Typography Controls
                this.initializeTypographyControls();
                
                // Initialize draggable panels
                this.initializeDraggablePanels();
                
                // Initialize custom slider progress
                this.initializeSliderProgress();
                
                // Initialize character customization
                this.initializeCharacterCustomization();
                
                // Initialize layout positioning
                this.initializeLayoutPositioning();
                
                // Initialize learning parameters
                this.initializeLearningParameters();
                
                // Initialize help popup
                this.initializeHelpPopup();
                
                // Initialize scramble text effect for footer
                this.initializeScrambleText();
                
                // Initialize text pressure effects
                this.initTextPressureTitle();
                
                // Initialize inline editing
                this.initializeInlineEditing();
                
                // Chart close button
                document.getElementById('chartCloseBtn').addEventListener('click', () => {
                    document.getElementById('chartContainer').style.display = 'none';
                    if (this.isTraining && !this.isPaused) {
                        document.getElementById('gridView').style.display = 'flex';
                    } else {
                        document.getElementById('welcomeScreen').style.display = 'flex';
                    }
                });
            }

            initializeCollapsibleSections() {
                const accordionSections = [
                    { toggle: 'settingsToggle', content: 'settingsContent' },
                    { toggle: 'typographyToggle', content: 'typographyContent' },
                    { toggle: 'charactersToggle', content: 'charactersContent' },
                    { toggle: 'layoutToggle', content: 'layoutContent' },
                    { toggle: 'learningParametersToggle', content: 'learningParametersContent' },
                    { toggle: 'displayControlsToggle', content: 'displayControlsContent' },
                    { toggle: 'rewardsToggle', content: 'rewardsContent' }
                ];

                // Initialize accordion sections (only one open at a time)
                accordionSections.forEach(section => {
                    const toggle = document.getElementById(section.toggle);
                    const content = document.getElementById(section.content);
                    
                    if (toggle && content) {
                        // Use different height constraints based on section
                        const maxViewportHeight = section.content === 'settingsContent' ? 
                            window.innerHeight * 0.4 : window.innerHeight * 0.4;
                        const contentHeight = Math.min(content.scrollHeight, maxViewportHeight);
                        content.style.maxHeight = content.classList.contains('collapsed') ? '0px' : contentHeight + 'px';
                        
                        toggle.addEventListener('click', () => {
                            const isCollapsed = content.classList.contains('collapsed');
                            
                            if (isCollapsed) {
                                // Close all other accordion sections first
                                accordionSections.forEach(otherSection => {
                                    if (otherSection.toggle !== section.toggle) {
                                        const otherToggle = document.getElementById(otherSection.toggle);
                                        const otherContent = document.getElementById(otherSection.content);
                                        if (otherToggle && otherContent) {
                                            otherContent.classList.add('collapsed');
                                            otherToggle.classList.add('collapsed');
                                            otherContent.style.maxHeight = '0px';
                                        }
                                    }
                                });
                                
                                // Then expand current section
                                content.classList.remove('collapsed');
                                toggle.classList.remove('collapsed');
                                // Use different height constraints based on section
                                const maxViewportHeight = section.content === 'settingsContent' ? 
                                    window.innerHeight * 0.4 : window.innerHeight * 0.4;
                                const contentHeight = Math.min(content.scrollHeight, maxViewportHeight);
                                content.style.maxHeight = contentHeight + 'px';
                            } else {
                                // Collapse current section
                                content.classList.add('collapsed');
                                toggle.classList.add('collapsed');
                                content.style.maxHeight = '0px';
                            }
                        });
                    }
                });
            }

            initializeSliderProgress() {
                const sliders = document.querySelectorAll('input[type="range"]');
                
                const updateSliderProgress = (slider) => {
                    const value = ((slider.value - slider.min) / (slider.max - slider.min)) * 100;
                    slider.style.setProperty('--range-progress', `${value}%`);
                };
                
                sliders.forEach(slider => {
                    // Set initial progress
                    updateSliderProgress(slider);
                    
                    // Update progress on input
                    slider.addEventListener('input', () => updateSliderProgress(slider));
                    slider.addEventListener('change', () => updateSliderProgress(slider));
                });
            }

            initializeTypographyControls() {
                // Typography control definitions
                const typographyControls = [
                    { id: 'headerTitleSize', target: '.header h1', property: 'fontSize', display: 'headerTitleDisplay' },
                    { id: 'sectionTitleSize', target: '.section-title', property: 'fontSize', display: 'sectionTitleDisplay' },
                    { id: 'collapsibleTitleSize', target: '.collapsible-title', property: 'fontSize', display: 'collapsibleTitleDisplay' },
                    { id: 'subsectionSize', target: 'h4', property: 'fontSize', display: 'subsectionDisplay' },
                    { id: 'paramLabelSize', target: '.param-item label, .checkbox-item label', property: 'fontSize', display: 'paramLabelDisplay' },
                    { id: 'paramRowSize', target: '.param-row', property: 'fontSize', display: 'paramRowDisplay' },
                    { id: 'buttonSize', target: '.btn', property: 'fontSize', display: 'buttonDisplay' },
                    { id: 'statsSize', target: '.stat-row', property: 'fontSize', display: 'statsDisplay' },
                    { id: 'speedDisplaySize', target: '.speed-display', property: 'fontSize', display: 'speedDisplayDisplay' },
                    { id: 'legendSize', target: '.legend', property: 'fontSize', display: 'legendDisplay' },
                    { id: 'numberInputSize', target: '.param-row input[type="number"]', property: 'fontSize', display: 'numberInputDisplay' }
                ];

                // Initialize value display toggle
                const showValueDisplays = document.getElementById('showValueDisplays');
                const toggleValueDisplays = () => {
                    const displays = document.querySelectorAll('.speed-display');
                    displays.forEach(display => {
                        display.style.display = showValueDisplays.checked ? 'inline' : 'none';
                    });
                };
                
                // Set initial state (hidden by default)
                showValueDisplays.checked = false;
                toggleValueDisplays();
                showValueDisplays.addEventListener('change', toggleValueDisplays);

                // Grid character size control
                const gridCharSlider = document.getElementById('gridCharSize');
                const gridCharDisplay = document.getElementById('gridCharDisplay');
                if (gridCharSlider && gridCharDisplay) {
                    const updateGridCharSize = () => {
                        const value = parseFloat(gridCharSlider.value);
                        gridCharDisplay.textContent = value + 'rem';
                        
                        // Apply to grid characters
                        const grid = document.getElementById('gameGrid');
                        if (grid) {
                            grid.style.fontSize = value + 'rem';
                        }
                    };
                    
                    gridCharSlider.addEventListener('input', updateGridCharSize);
                    gridCharSlider.addEventListener('change', updateGridCharSize);
                    updateGridCharSize(); // Initialize
                }

                // Add event listeners for each control
                typographyControls.forEach(control => {
                    const slider = document.getElementById(control.id);
                    const display = document.getElementById(control.display);
                    
                    if (slider && display) {
                        const updateTypography = () => {
                            const value = parseFloat(slider.value);
                            display.textContent = value + 'rem';
                            
                            // Apply to all matching elements
                            const elements = document.querySelectorAll(control.target);
                            elements.forEach(element => {
                                element.style[control.property] = value + 'rem';
                            });
                        };
                        
                        slider.addEventListener('input', updateTypography);
                        slider.addEventListener('change', updateTypography);
                        
                        // Initialize current values
                        updateTypography();
                    }
                });

                // Reset button functionality
                const resetButton = document.getElementById('resetTypography');
                if (resetButton) {
                    resetButton.addEventListener('click', () => {
                        typographyControls.forEach(control => {
                            const slider = document.getElementById(control.id);
                            if (slider) {
                                // Reset to current default values
                                const defaults = {
                                    'headerTitleSize': 5.7,
                                    'sectionTitleSize': 1.4,
                                    'collapsibleTitleSize': 0.9,
                                    'subsectionSize': 1.0,
                                    'paramLabelSize': 0.7,
                                    'paramRowSize': 0.8,
                                    'buttonSize': 0.7,
                                    'statsSize': 0.8,
                                    'speedDisplaySize': 0.8,
                                    'legendSize': 0.9,
                                    'numberInputSize': 0.8
                                };
                                
                                slider.value = defaults[control.id] || 1;
                                slider.dispatchEvent(new Event('input'));
                            }
                        });
                    });
                }
            }

            initializeCharacterCustomization() {
                // Store default character mappings
                this.characterMap = {
                    empty: '·',
                    cat: 'C',
                    mouse: 'M',
                    obstacle: 'O',
                    unknown: '?',
                    error: '!'
                };
                
                // Initialize empty space font size
                this.emptyCharSize = 1.6;
                
                // Empty space font size control (hidden input for updateEmptyCharFontSize)
                const emptyCharSizeInput = document.getElementById('emptyCharSize');
                if (emptyCharSizeInput) {
                    emptyCharSizeInput.addEventListener('input', () => {
                        this.emptyCharSize = parseFloat(emptyCharSizeInput.value);
                        this.updateEmptyCharFontSize();
                    });
                }
            }

            updateLegend() {
                const legend = document.querySelector('.legend');
                if (legend) {
                    // Create the new content matching the original legend format
                    const newContent = `<span class="cat">${this.characterMap.cat || 'C'}: CAT</span> | <span class="mouse">${this.characterMap.mouse || 'M'}: MOUSE</span> | <span class="obstacle">${this.characterMap.obstacle || 'O'}: OBSTACLE</span> | <span class="cat-vision">${this.characterMap.unknown || '?'}: VISION</span> | <span class="mouse-vision">${this.characterMap.error || '!'}: COLLISION</span>`;
                    
                    // Update the content and preserve scramble structure
                    legend.innerHTML = newContent.trim();
                    
                    // Re-initialize scramble text for the updated content
                    this.reinitializeScrambleText(legend);
                }
            }
            
            reinitializeScrambleText(legend) {
                // Extract text content while preserving structure
                const textContent = legend.textContent;
                let charHTML = '';
                
                for (let i = 0; i < textContent.length; i++) {
                    const char = textContent[i];
                    // Don't wrap spaces, pipes, or colons in spans to preserve natural spacing
                    if (char === ' ' || char === '|' || char === ':') {
                        charHTML += char;
                    } else {
                        charHTML += `<span class="scramble-char" data-original="${char}">${char}</span>`;
                    }
                }
                
                legend.innerHTML = charHTML;
            }
            
            updateEmptyCharFontSize() {
                const grid = document.querySelector('.grid');
                if (grid) {
                    // Create a CSS rule to scale empty characters
                    const style = document.createElement('style');
                    style.textContent = `
                        .grid .empty-char {
                            font-size: ${this.emptyCharSize}em !important;
                            display: inline-block;
                            vertical-align: baseline;
                        }
                    `;
                    
                    // Remove any existing style with the same purpose
                    const existing = document.getElementById('empty-char-style');
                    if (existing) {
                        existing.remove();
                    }
                    
                    style.id = 'empty-char-style';
                    document.head.appendChild(style);
                    
                    // Re-render the grid to apply the new class
                    if (this.gameGrid && this.gameGrid.length > 0) {
                        this.renderGrid();
                    }
                }
            }
            
            initializeLayoutPositioning() {
                // Header positioning
                const headerPosSlider = document.getElementById('headerVerticalPos');
                const headerPosDisplay = document.getElementById('headerPosDisplay');
                if (headerPosSlider && headerPosDisplay) {
                    const updateHeaderPosition = () => {
                        const value = parseInt(headerPosSlider.value);
                        headerPosDisplay.textContent = `${value}px`;
                        document.querySelector('.header').style.marginTop = `${value}px`;
                    };
                    headerPosSlider.addEventListener('input', updateHeaderPosition);
                    headerPosSlider.addEventListener('change', updateHeaderPosition);
                    updateHeaderPosition(); // Set initial value
                }
                
                // Left panel positioning  
                const leftPanelPosSlider = document.getElementById('leftPanelVerticalPos');
                const leftPanelPosDisplay = document.getElementById('leftPanelPosDisplay');
                if (leftPanelPosSlider && leftPanelPosDisplay) {
                    const updateLeftPanelPosition = () => {
                        const value = parseInt(leftPanelPosSlider.value);
                        leftPanelPosDisplay.textContent = `${value}px`;
                        document.querySelector('.control-center').style.marginTop = `${value - 165}px`;
                    };
                    leftPanelPosSlider.addEventListener('input', updateLeftPanelPosition);
                    leftPanelPosSlider.addEventListener('change', updateLeftPanelPosition);
                    updateLeftPanelPosition(); // Set initial value
                }
                
                // Right panel positioning
                const rightPanelPosSlider = document.getElementById('rightPanelVerticalPos');
                const rightPanelPosDisplay = document.getElementById('rightPanelPosDisplay');
                if (rightPanelPosSlider && rightPanelPosDisplay) {
                    const updateRightPanelPosition = () => {
                        const value = parseInt(rightPanelPosSlider.value);
                        rightPanelPosDisplay.textContent = `${value}px`;
                        document.querySelector('.analytics-panel').style.marginTop = `${value - 165}px`;
                    };
                    rightPanelPosSlider.addEventListener('input', updateRightPanelPosition);
                    rightPanelPosSlider.addEventListener('change', updateRightPanelPosition);
                    updateRightPanelPosition(); // Set initial value
                }
                
                // Center panel positioning
                const centerPanelPosSlider = document.getElementById('centerPanelVerticalPos');
                const centerPanelPosDisplay = document.getElementById('centerPanelPosDisplay');
                if (centerPanelPosSlider && centerPanelPosDisplay) {
                    const updateCenterPanelPosition = () => {
                        const value = parseInt(centerPanelPosSlider.value);
                        centerPanelPosDisplay.textContent = `${value}px`;
                        document.querySelector('.simulation-view').style.marginTop = `${value}px`;
                    };
                    centerPanelPosSlider.addEventListener('input', updateCenterPanelPosition);
                    centerPanelPosSlider.addEventListener('change', updateCenterPanelPosition);
                    updateCenterPanelPosition(); // Set initial value
                }
                
                // Footer positioning
                const footerPosSlider = document.getElementById('footerVerticalPos');
                const footerPosDisplay = document.getElementById('footerPosDisplay');
                if (footerPosSlider && footerPosDisplay) {
                    const updateFooterPosition = () => {
                        const value = parseInt(footerPosSlider.value);
                        footerPosDisplay.textContent = `${value}rem`;
                        document.querySelector('.footer-container').style.bottom = `${value}rem`;
                    };
                    footerPosSlider.addEventListener('input', updateFooterPosition);
                    footerPosSlider.addEventListener('change', updateFooterPosition);
                    updateFooterPosition(); // Set initial value
                }
                
            }
            
            initializeLearningParameters() {
                // AI Learning Parameters
                const learningRateSlider = document.getElementById('learningRateSlider');
                const learningRateDisplay = document.getElementById('learningRateDisplay');
                if (learningRateSlider && learningRateDisplay) {
                    const updateLearningRate = () => {
                        const value = parseFloat(learningRateSlider.value);
                        learningRateDisplay.textContent = value.toFixed(2);
                        this.learningRate = value;
                    };
                    
                    // Enhanced live feedback during dragging
                    learningRateSlider.addEventListener('input', (e) => {
                        updateLearningRate();
                        // Add visual feedback while dragging
                        learningRateDisplay.style.transform = 'scale(1.1)';
                        learningRateDisplay.style.color = '#00ff00';
                        setTimeout(() => {
                            learningRateDisplay.style.transform = 'scale(1)';
                            learningRateDisplay.style.color = '';
                        }, 150);
                    });
                    learningRateSlider.addEventListener('change', updateLearningRate);
                    updateLearningRate();
                }
                
                const epsilonSlider = document.getElementById('epsilonSlider');
                const epsilonDisplay = document.getElementById('epsilonDisplay');
                if (epsilonSlider && epsilonDisplay) {
                    const updateEpsilon = () => {
                        const value = parseFloat(epsilonSlider.value);
                        epsilonDisplay.textContent = value.toFixed(2);
                        this.initialEpsilon = value;
                        this.epsilon = value;
                    };
                    
                    // Enhanced live feedback during dragging
                    epsilonSlider.addEventListener('input', (e) => {
                        updateEpsilon();
                        epsilonDisplay.style.transform = 'scale(1.1)';
                        epsilonDisplay.style.color = '#00ff00';
                        setTimeout(() => {
                            epsilonDisplay.style.transform = 'scale(1)';
                            epsilonDisplay.style.color = '';
                        }, 150);
                    });
                    epsilonSlider.addEventListener('change', updateEpsilon);
                    updateEpsilon();
                }
                
                const discountFactorSlider = document.getElementById('discountFactorSlider');
                const discountFactorDisplay = document.getElementById('discountFactorDisplay');
                if (discountFactorSlider && discountFactorDisplay) {
                    const updateDiscountFactor = () => {
                        const value = parseFloat(discountFactorSlider.value);
                        discountFactorDisplay.textContent = value.toFixed(2);
                        const label = document.getElementById('discountFactorLabel');
                        if (label) label.textContent = `Discount Factor: ${value.toFixed(2)}`;
                        this.discountFactor = value;
                    };
                    
                    // Enhanced live feedback during dragging
                    discountFactorSlider.addEventListener('input', (e) => {
                        updateDiscountFactor();
                        discountFactorDisplay.style.transform = 'scale(1.1)';
                        discountFactorDisplay.style.color = '#00ff00';
                        setTimeout(() => {
                            discountFactorDisplay.style.transform = 'scale(1)';
                            discountFactorDisplay.style.color = '';
                        }, 150);
                    });
                    discountFactorSlider.addEventListener('change', updateDiscountFactor);
                    updateDiscountFactor();
                }
                
                const epsilonDecaySlider = document.getElementById('epsilonDecaySlider');
                const epsilonDecayDisplay = document.getElementById('epsilonDecayDisplay');
                if (epsilonDecaySlider && epsilonDecayDisplay) {
                    const updateEpsilonDecay = () => {
                        const value = parseFloat(epsilonDecaySlider.value);
                        epsilonDecayDisplay.textContent = value.toFixed(3);
                        const label = document.getElementById('epsilonDecayLabel');
                        if (label) label.textContent = `Exploration Decay: ${value.toFixed(3)}`;
                        this.epsilonDecay = value;
                    };
                    
                    // Enhanced live feedback during dragging
                    epsilonDecaySlider.addEventListener('input', (e) => {
                        updateEpsilonDecay();
                        epsilonDecayDisplay.style.transform = 'scale(1.1)';
                        epsilonDecayDisplay.style.color = '#00ff00';
                        setTimeout(() => {
                            epsilonDecayDisplay.style.transform = 'scale(1)';
                            epsilonDecayDisplay.style.color = '';
                        }, 150);
                    });
                    epsilonDecaySlider.addEventListener('change', updateEpsilonDecay);
                    updateEpsilonDecay();
                }
            }
            
            initializeHelpPopup() {
                const helpOverlay = document.getElementById('helpOverlay');
                const helpPopup = document.getElementById('helpPopup');
                const helpCloseBtn = document.getElementById('helpCloseBtn');
                const welcomeHelpTrigger = document.getElementById('welcomeHelpTrigger');
                const controlHelpTrigger = null; // Removed help functionality from learning parameters
                
                const showHelp = () => {
                    helpOverlay.style.display = 'block';
                    helpPopup.style.display = 'block';
                };
                
                const hideHelp = () => {
                    helpOverlay.style.display = 'none';
                    helpPopup.style.display = 'none';
                };
                
                // Add click handlers
                if (welcomeHelpTrigger) {
                    welcomeHelpTrigger.addEventListener('click', showHelp);
                }
                
                if (controlHelpTrigger) {
                    controlHelpTrigger.addEventListener('click', showHelp);
                }
                
                // Close handlers
                if (helpCloseBtn) {
                    helpCloseBtn.addEventListener('click', hideHelp);
                }
                
                if (helpOverlay) {
                    helpOverlay.addEventListener('click', hideHelp);
                }
                
                // ESC key handler
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && helpPopup.style.display === 'block') {
                        hideHelp();
                    }
                });
            }
            
            initializeScrambleText() {
                const legend = document.querySelector('.legend');
                if (!legend) return;
                
                // Split legend text into spans for each character, but preserve spaces and separators
                const originalHTML = legend.innerHTML;
                legend.dataset.originalContent = originalHTML;
                
                // Extract text content while preserving structure
                const textContent = legend.textContent;
                let charHTML = '';
                
                for (let i = 0; i < textContent.length; i++) {
                    const char = textContent[i];
                    // Don't wrap spaces, pipes, or colons in spans to preserve natural spacing
                    if (char === ' ' || char === '|' || char === ':') {
                        charHTML += char;
                    } else {
                        charHTML += `<span class="scramble-char" data-original="${char}">${char}</span>`;
                    }
                }
                
                legend.innerHTML = charHTML;
                
                // Add scramble effect on mouse move
                legend.addEventListener('pointermove', (e) => {
                    this.handleScrambleEffect(e, legend);
                });
            }
            
            handleScrambleEffect(e, element) {
                const chars = element.querySelectorAll('.scramble-char');
                const radius = 300;
                const scrambleChars = '.:';
                const duration = 5000;
                
                chars.forEach(char => {
                    const rect = char.getBoundingClientRect();
                    const charCenterX = rect.left + rect.width / 2;
                    const charCenterY = rect.top + rect.height / 2;
                    
                    const dx = e.clientX - charCenterX;
                    const dy = e.clientY - charCenterY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < radius) {
                        const intensity = 1 - (distance / radius);
                        this.scrambleCharacter(char, intensity, scrambleChars, duration);
                    }
                });
            }
            
            scrambleCharacter(charElement, intensity, scrambleChars, duration) {
                // Prevent multiple scrambles on the same character
                if (charElement.isScrambling) return;
                
                const original = charElement.dataset.original;
                const scrambleLength = Math.floor(intensity * 3) + 1; // Reduced scramble cycles
                
                charElement.isScrambling = true;
                let scrambleCount = 0;
                const maxScrambles = scrambleLength;
                const intervalDelay = 80; // More fluid animation speed
                
                const scrambleInterval = setInterval(() => {
                    if (scrambleCount < maxScrambles) {
                        const randomChar = scrambleChars[Math.floor(Math.random() * scrambleChars.length)];
                        charElement.textContent = randomChar;
                        scrambleCount++;
                    } else {
                        charElement.textContent = original;
                        charElement.isScrambling = false;
                        clearInterval(scrambleInterval);
                    }
                }, intervalDelay);
            }
            
            initHeaderScrambleEffect() {
                const header = document.querySelector('.header h1');
                if (!header) return;
                
                const text = header.textContent;
                let charHTML = '';
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    // Don't wrap spaces in spans to preserve natural spacing
                    if (char === ' ') {
                        charHTML += char;
                    } else {
                        charHTML += `<span class="scramble-char" data-original="${char}">${char}</span>`;
                    }
                }
                
                header.innerHTML = charHTML;
                
                // Add scramble effect on mouse move
                header.addEventListener('pointermove', (e) => {
                    this.handleScrambleEffect(e, header);
                });
            }
            
            initWelcomeDecryptedText() {
                // Apply DecryptedText effect to all welcome screen text elements with 50ms speed on page load
                const allTextElements = document.querySelectorAll('#welcomeScreen [data-decrypt]');
                
                allTextElements.forEach(element => {
                    new DecryptedText(element, {
                        speed: 50,
                        maxIterations: 12,
                        sequential: true,
                        revealDirection: 'start',
                        useOriginalCharsOnly: true,
                        animateOn: 'view'  // Trigger on page load when element comes into view
                    });
                });
            }
            
            
            



            
            initializeInlineEditing() {
                // Add inline editing to all editable elements
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('inline-editable')) {
                        this.startInlineEdit(e.target);
                    }
                });
            }
            
            startInlineEdit(element) {
                if (element.classList.contains('editing')) return;
                
                const originalValue = element.textContent;
                const dataType = element.dataset.type || 'text';
                const maxLength = element.dataset.maxlength || (dataType === 'char' ? 1 : 10);
                
                element.classList.add('editing');
                element.contentEditable = true;
                element.style.outline = '1px solid #7FE9E1';
                element.style.background = 'rgba(127, 233, 225, 0.1)';
                
                // Select all text
                const range = document.createRange();
                range.selectNodeContents(element);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
                
                const finishEdit = () => {
                    element.classList.remove('editing');
                    element.contentEditable = false;
                    element.style.outline = '';
                    element.style.background = '';
                    
                    let newValue = element.textContent.trim();
                    
                    // Validate based on data type
                    if (dataType === 'char' && newValue.length > 1) {
                        newValue = newValue.charAt(0);
                    } else if (dataType === 'number') {
                        const numValue = parseFloat(newValue);
                        if (isNaN(numValue)) {
                            newValue = originalValue;
                        } else {
                            const min = parseFloat(element.dataset.min || 0);
                            const maxAttr = element.dataset.max;
                            if (maxAttr) {
                                const max = parseFloat(maxAttr);
                                newValue = Math.max(min, Math.min(max, numValue)).toString();
                            } else {
                                newValue = Math.max(min, numValue).toString();
                            }
                        }
                    }
                    
                    element.textContent = newValue;
                    
                    // Trigger update callback if it exists
                    const updateCallback = element.dataset.callback;
                    if (updateCallback && this[updateCallback]) {
                        this[updateCallback](element, newValue, originalValue);
                    }
                };
                
                // Finish editing on Enter or loss of focus
                const handleKeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        finishEdit();
                        element.removeEventListener('keydown', handleKeydown);
                        element.removeEventListener('blur', handleBlur);
                    } else if (e.key === 'Escape') {
                        element.textContent = originalValue;
                        finishEdit();
                        element.removeEventListener('keydown', handleKeydown);
                        element.removeEventListener('blur', handleBlur);
                    }
                };
                
                const handleBlur = () => {
                    finishEdit();
                    element.removeEventListener('keydown', handleKeydown);
                    element.removeEventListener('blur', handleBlur);
                };
                
                element.addEventListener('keydown', handleKeydown);
                element.addEventListener('blur', handleBlur);
            }
            
            // Callback functions for different types of edits
            updateCharacterValue(element, newValue, originalValue) {
                const charType = element.dataset.charType;
                if (charType && this.characterMap[charType] !== undefined) {
                    this.characterMap[charType] = newValue;
                    this.updateLegend();
                    if (this.gameGrid && this.gameGrid.length > 0) {
                        this.renderGrid();
                    }
                }
            }
            
            updateNumericValue(element, newValue, originalValue) {
                const inputId = element.dataset.inputId;
                if (inputId) {
                    const input = document.getElementById(inputId);
                    if (input) {
                        input.value = newValue;
                        // Trigger the input event to update any related functionality
                        input.dispatchEvent(new Event('input'));
                        input.dispatchEvent(new Event('change'));
                        
                        // Special handling for specific controls
                        if (inputId === 'fontSize') {
                            this.updateFontSize();
                        } else if (inputId === 'horizontalSpacing') {
                            this.updateHorizontalSpacing();
                        } else if (inputId === 'verticalSpacing') {
                            this.updateVerticalSpacing();
                        } else if (inputId === 'emptyCharSize') {
                            // Update the display element if it exists
                            const sizeDisplay = document.querySelector('[data-input-id="emptyCharSize"]');
                            if (sizeDisplay) {
                                sizeDisplay.textContent = parseFloat(newValue).toFixed(1);
                            }
                            this.emptyCharSize = parseFloat(newValue);
                            this.updateEmptyCharFontSize();
                        } else if (inputId === 'obstacleCount') {
                            // Regenerate obstacles when count changes
                            if (!this.isTraining) {
                                this.generatePersistentObstacles();
                                this.originalObstacles = JSON.parse(JSON.stringify(this.obstacles));
                                this.placeAgentsAndObstacles();
                                this.renderGrid();
                            }
                        }
                    }
                }
            }
            
            updateAgentCounts() {
                // Get new counts from UI
                this.catCount = parseInt(document.getElementById('catCount').value) || 1;
                this.mouseCount = parseInt(document.getElementById('mouseCount').value) || 1;
                
                // Resize agent arrays
                this.cats = Array(this.catCount).fill().map((_, i) => ({
                    x: 0, y: 0, id: i, rotation: i * 90  // Spread initial rotations
                }));
                
                this.mice = Array(this.mouseCount).fill().map((_, i) => ({
                    x: 0, y: 0, id: i, rotation: (i * 90 + 180) % 360  // Different from cats
                }));
                
                // Resize Q-table arrays
                while (this.catQTables.length < this.catCount) {
                    this.catQTables.push({});
                }
                while (this.mouseQTables.length < this.mouseCount) {
                    this.mouseQTables.push({});
                }
                
                // Trim excess Q-tables
                this.catQTables = this.catQTables.slice(0, this.catCount);
                this.mouseQTables = this.mouseQTables.slice(0, this.mouseCount);
                
                // Maintain legacy compatibility
                this.catPos = this.cats[0];
                this.mousePos = this.mice[0];
                this.catQTable = this.catQTables[0];
                this.mouseQTable = this.mouseQTables[0];
                
                // Reinitialize positions
                this.placeAgentsAndObstacles();
                this.renderGrid();
                
                console.log(`Updated to ${this.catCount} cats and ${this.mouseCount} mice`);
            }

            initializeDraggablePanels() {
                const draggablePanels = document.querySelectorAll('.draggable-panel');
                
                draggablePanels.forEach(panel => {
                    let isDragging = false;
                    let offsetX = 0;
                    let offsetY = 0;
                    let originalParent = null;
                    let originalPosition = null;
                    
                    panel.addEventListener('mousedown', (e) => {
                        // Only start dragging if clicking on the title area
                        if (e.target.classList.contains('section-title') || e.target.closest('.section-title')) {
                            isDragging = true;
                            panel.classList.add('dragging');
                            
                            // Store original position and parent
                            originalParent = panel.parentNode;
                            originalPosition = {
                                position: panel.style.position,
                                top: panel.style.top,
                                left: panel.style.left,
                                width: panel.style.width,
                                height: panel.style.height
                            };
                            
                            // Calculate offset from mouse to panel corner
                            const rect = panel.getBoundingClientRect();
                            offsetX = e.clientX - rect.left;
                            offsetY = e.clientY - rect.top;
                            
                            // Convert to fixed positioning
                            panel.style.position = 'fixed';
                            panel.style.left = rect.left + 'px';
                            panel.style.top = rect.top + 'px';
                            panel.style.width = rect.width + 'px';
                            panel.style.height = rect.height + 'px';
                            panel.style.zIndex = '1000';
                            
                            e.preventDefault();
                        }
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (isDragging && panel.classList.contains('dragging')) {
                            panel.style.left = (e.clientX - offsetX) + 'px';
                            panel.style.top = (e.clientY - offsetY) + 'px';
                        }
                    });
                    
                    document.addEventListener('mouseup', () => {
                        if (isDragging) {
                            isDragging = false;
                            panel.classList.remove('dragging');
                            
                            // Option to restore to original position (double-click title to reset)
                            let resetTimeout = setTimeout(() => {
                                // Keep in dragged position
                            }, 300);
                        }
                    });
                    
                    // Double-click title to reset position
                    const title = panel.querySelector('.section-title');
                    if (title) {
                        title.addEventListener('dblclick', () => {
                            // Reset to original position
                            panel.style.position = originalPosition.position;
                            panel.style.top = originalPosition.top;
                            panel.style.left = originalPosition.left;
                            panel.style.width = originalPosition.width;
                            panel.style.height = originalPosition.height;
                            panel.style.zIndex = '';
                            
                            // Re-attach to original parent if needed
                            if (originalParent && !originalParent.contains(panel)) {
                                originalParent.appendChild(panel);
                            }
                        });
                    }
                });
            }

            updateSpeedDisplay() {
                const speedInput = document.getElementById('simulationSpeed');
                const display = document.getElementById('speedDisplay');
                const label = document.getElementById('simulationSpeedLabel');
                
                if (!speedInput || !display) return;
                
                const speed = parseInt(speedInput.value);
                display.textContent = speed + 'ms';
                if (label) label.textContent = `Simulation Speed: ${speed}ms`;
            }
            
            updateVisionAngleDisplay() {
                const angle = document.getElementById('visionAngle').value;
                const display = document.getElementById('visionAngleDisplay');
                const label = document.getElementById('visionAngleLabel');
                if (display) display.textContent = `${angle}°`;
                if (label) label.textContent = `Vision Cone Angle: ${angle}°`;
            }
            
            updateCatRotationDisplay() {
                const rotationElement = document.getElementById('catRotation');
                if (!rotationElement) return; // Prevent error if element doesn't exist
                
                const rotation = parseInt(rotationElement.value);
                const display = document.getElementById('catRotationDisplay');
                const directions = {
                    0: "Right", 45: "Down-Right", 90: "Down", 135: "Down-Left",
                    180: "Left", 225: "Up-Left", 270: "Up", 315: "Up-Right", 360: "Right"
                };
                if (display) display.textContent = `${rotation}° (${directions[rotation] || "Custom"})`;
                
                // Update internal rotation when user changes slider
                this.catRotation = rotation;
            }
            
            updateMouseRotationDisplay() {
                const rotationElement = document.getElementById('mouseRotation');
                if (!rotationElement) return; // Prevent error if element doesn't exist
                
                const rotation = parseInt(rotationElement.value);
                const display = document.getElementById('mouseRotationDisplay');
                const directions = {
                    0: "Right", 45: "Down-Right", 90: "Down", 135: "Down-Left",
                    180: "Left", 225: "Up-Left", 270: "Up", 315: "Up-Right", 360: "Right"
                };
                if (display) display.textContent = `${rotation}° (${directions[rotation] || "Custom"})`;
                
                // Update internal rotation when user changes slider
                this.mouseRotation = rotation;
            }
            
            updateCatLearningRate() {
                const slider = document.getElementById('catLearningRateSlider');
                const display = document.getElementById('catLearningRateDisplay');
                const label = document.getElementById('catLearningRateLabel');
                if (slider && display) {
                    const value = parseFloat(slider.value);
                    display.textContent = value.toFixed(2);
                    if (label) label.textContent = `Learning Rate: ${value.toFixed(2)}`;
                    this.catLearningRate = value;
                }
            }
            
            updateCatEpsilon() {
                const slider = document.getElementById('catEpsilonSlider');
                const display = document.getElementById('catEpsilonDisplay');
                const label = document.getElementById('catEpsilonLabel');
                if (slider && display) {
                    const value = parseFloat(slider.value);
                    display.textContent = value.toFixed(2);
                    if (label) label.textContent = `Exploration Rate: ${value.toFixed(2)}`;
                    this.catEpsilon = value;
                    this.catInitialEpsilon = value;
                }
            }
            
            updateMouseLearningRate() {
                const slider = document.getElementById('mouseLearningRateSlider');
                const display = document.getElementById('mouseLearningRateDisplay');
                const label = document.getElementById('mouseLearningRateLabel');
                if (slider && display) {
                    const value = parseFloat(slider.value);
                    display.textContent = value.toFixed(2);
                    if (label) label.textContent = `Learning Rate: ${value.toFixed(2)}`;
                    this.mouseLearningRate = value;
                }
            }
            
            updateMouseEpsilon() {
                const slider = document.getElementById('mouseEpsilonSlider');
                const display = document.getElementById('mouseEpsilonDisplay');
                const label = document.getElementById('mouseEpsilonLabel');
                if (slider && display) {
                    const value = parseFloat(slider.value);
                    display.textContent = value.toFixed(2);
                    if (label) label.textContent = `Exploration Rate: ${value.toFixed(2)}`;
                    this.mouseEpsilon = value;
                    this.mouseInitialEpsilon = value;
                }
            }
            
            updateRewardParameter(paramName) {
                const slider = document.getElementById(paramName + 'Slider');
                const display = document.getElementById(paramName + 'Display');
                const label = document.getElementById(paramName + 'Label');
                if (slider && display) {
                    const value = parseFloat(slider.value);
                    display.textContent = value;
                    
                    // Update the label with appropriate formatting
                    if (label) {
                        const formattedValue = value >= 0 ? `+${value}` : `${value}`;
                        const labelText = this.getRewardLabelText(paramName, formattedValue);
                        label.textContent = labelText;
                    }
                    
                    this.rewards[paramName] = value;
                    this.updateWelcomeRewardDisplay();
                }
            }
            
            getRewardLabelText(paramName, formattedValue) {
                const labelMap = {
                    'catWin': `Win Bonus: ${formattedValue}`,
                    'catHunting': `Hunting (Visible): ${formattedValue}`,
                    'catExploration': `Exploration: ${formattedValue}`,
                    'catRetreating': `Retreating: ${formattedValue}`,
                    'catStandingStill': `Standing Still: ${formattedValue}`,
                    'catFailure': `Failure Penalty: ${formattedValue}`,
                    'mouseSurvival': `Survival Bonus: ${formattedValue}`,
                    'mouseCaught': `Caught Penalty: ${formattedValue}`,
                    'mouseStrategicEscape': `Strategic Escape: ${formattedValue}`,
                    'mouseBlindEscape': `Blind Escape: ${formattedValue}`,
                    'mouseApproachingDanger': `Approaching Danger: ${formattedValue}`,
                    'mouseStandingStillVisible': `Standing Still (Visible): ${formattedValue}`,
                    'mouseMovingTowardDanger': `Moving Toward Danger: ${formattedValue}`
                };
                return labelMap[paramName] || `${paramName}: ${formattedValue}`;
            }
            
            updateWelcomeRewardDisplay() {
                // Update Cat rewards in welcome page
                const welcomeCatRewards = document.getElementById('welcomeCatRewards');
                if (welcomeCatRewards) {
                    welcomeCatRewards.textContent = `• Win: +${this.rewards.catWin} | Failure: ${this.rewards.catFailure} | Hunting: +${this.rewards.catHunting} | Exploration: +${this.rewards.catExploration}`;
                }
                
                const welcomeCatPenalties = document.getElementById('welcomeCatPenalties');
                if (welcomeCatPenalties) {
                    welcomeCatPenalties.textContent = `• Retreating: ${this.rewards.catRetreating} | Standing still: ${this.rewards.catStandingStill}`;
                }
                
                // Update Mouse rewards in welcome page
                const welcomeMouseRewards = document.getElementById('welcomeMouseRewards');
                if (welcomeMouseRewards) {
                    welcomeMouseRewards.textContent = `• Survival: +${this.rewards.mouseSurvival} | Caught: ${this.rewards.mouseCaught} | Strategic escape: +${this.rewards.mouseStrategicEscape} | Blind escape: +${this.rewards.mouseBlindEscape}`;
                }
                
                const welcomeMousePenalties = document.getElementById('welcomeMousePenalties');
                if (welcomeMousePenalties) {
                    welcomeMousePenalties.textContent = `• Approaching danger: ${this.rewards.mouseApproachingDanger} | Moving toward danger: ${this.rewards.mouseMovingTowardDanger} | Standing still (visible): ${this.rewards.mouseStandingStillVisible}`;
                }
            }

            updateFontSize() {
                const fontSize = parseFloat(document.getElementById('fontSize').value);
                const grid = document.getElementById('gameGrid');
                
                // Update the inline-editable span instead of a separate display element
                const paramValue = document.querySelector('[data-input-id="fontSize"]');
                if (paramValue) paramValue.textContent = fontSize.toFixed(1);
                
                grid.style.fontSize = fontSize + 'rem';
            }

            updateHorizontalSpacing() {
                const spacing = parseFloat(document.getElementById('horizontalSpacing').value);
                const grid = document.getElementById('gameGrid');
                
                // Update the inline-editable span instead of a separate display element
                const paramValue = document.querySelector('[data-input-id="horizontalSpacing"]');
                if (paramValue) paramValue.textContent = spacing.toFixed(1);
                
                grid.style.letterSpacing = spacing + 'rem';
            }

            updateVerticalSpacing() {
                const spacing = parseFloat(document.getElementById('verticalSpacing').value);
                const grid = document.getElementById('gameGrid');
                
                // Update the inline-editable span instead of a separate display element
                const paramValue = document.querySelector('[data-input-id="verticalSpacing"]');
                if (paramValue) paramValue.textContent = spacing.toFixed(1);
                
                grid.style.lineHeight = spacing + 'rem';
            }
            
            updateCRTEffect() {
                const enabledEl = document.getElementById('crtEnabled');
                const enabled = enabledEl ? enabledEl.checked : false;
                
                // Get all CRT parameters
                const scanlines = this.getCRTValue('crtScanlines', 0.9);
                const glow = this.getCRTValue('crtGlow', 0.7);
                const contrast = this.getCRTValue('crtContrast', 1);
                const brightness = this.getCRTValue('crtBrightness', 1.05);
                const saturation = this.getCRTValue('crtSaturation', 1.1);
                const flicker = this.getCRTValue('crtFlicker', 0.8);
                const noise = this.getCRTValue('crtNoise', 0.7);
                const warp = this.getCRTValue('crtWarp', 0);
                const chromaticAberration = this.getCRTValue('crtChromaticAberration', 8);
                const distortion = this.getCRTValue('crtDistortion', 7.5);
                const vignette = this.getCRTValue('crtVignette', 5);
                
                // Update displays
                this.updateCRTDisplays({
                    scanlines, glow, contrast, brightness, saturation, 
                    flicker, noise, warp, chromaticAberration, distortion, vignette
                });
                
                if (!enabled) {
                    this.disableCRTEffects();
                    return;
                }
                
                // Apply shader-like CRT effects
                this.applyCRTShaderEffects({
                    scanlines, glow, contrast, brightness, saturation,
                    flicker, noise, warp, chromaticAberration, distortion, vignette
                });
            }
            
            getCRTValue(id, defaultValue) {
                const el = document.getElementById(id);
                return el ? parseFloat(el.value) : defaultValue;
            }
            
            updateCRTDisplays(values) {
                const displays = {
                    'scanlinesDisplay': values.scanlines,
                    'glowDisplay': values.glow,
                    'contrastDisplay': values.contrast,
                    'brightnessDisplay': values.brightness,
                    'saturationDisplay': values.saturation,
                    'flickerDisplay': values.flicker,
                    'noiseDisplay': values.noise,
                    'warpDisplay': values.warp,
                    'chromaticDisplay': values.chromaticAberration,
                    'distortionDisplay': values.distortion,
                    'vignetteDisplay': values.vignette
                };
                
                Object.entries(displays).forEach(([id, value]) => {
                    const display = document.getElementById(id);
                    if (display) {
                        display.textContent = (id === 'brightnessDisplay') ? 
                            value.toFixed(2) : value.toFixed(1);
                    }
                });
            }
            
            disableCRTEffects() {
                const overlay = document.querySelector('.crt-overlay');
                const container = document.querySelector('.container');
                const canvas = document.getElementById('crtCanvas');
                
                if (overlay) overlay.style.display = 'none';
                if (container) container.classList.remove('crt-screen');
                if (canvas) canvas.style.display = 'none';
                
                // Clear intervals
                if (this.noiseInterval) {
                    clearInterval(this.noiseInterval);
                    this.noiseInterval = null;
                }
                if (this.crtAnimationFrame) {
                    cancelAnimationFrame(this.crtAnimationFrame);
                    this.crtAnimationFrame = null;
                }
            }
            
            applyCRTShaderEffects(params) {
                const overlay = document.querySelector('.crt-overlay');
                const container = document.querySelector('.container');
                const canvas = document.getElementById('crtCanvas');
                
                if (overlay) overlay.style.display = 'block';
                if (container) container.classList.add('crt-screen');
                
                // Apply CSS-based effects
                this.applyCSSEffects(container, params);
                
                // Start shader-like canvas effects
                if (canvas) {
                    canvas.style.display = 'block';
                    this.startCRTShaderAnimation(canvas, params);
                }
            }
            
            applyCSSEffects(container, params) {
                if (!container) return;
                
                // Apply filter effects
                container.style.filter = `
                    contrast(${params.contrast}) 
                    brightness(${params.brightness}) 
                    saturate(${params.saturation})
                `;
                
                // Removed fisheye warp effect
            }
            
            startCRTShaderAnimation(canvas, params) {
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                
                const animate = (time) => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Apply shader-like effects
                    this.renderCRTEffects(ctx, canvas, params, time);
                    
                    this.crtAnimationFrame = requestAnimationFrame(animate);
                };
                
                if (this.crtAnimationFrame) {
                    cancelAnimationFrame(this.crtAnimationFrame);
                }
                this.crtAnimationFrame = requestAnimationFrame(animate);
            }
            
            renderCRTEffects(ctx, canvas, params, time) {
                const width = canvas.width;
                const height = canvas.height;
                
                // Scanlines
                if (params.scanlines > 0) {
                    ctx.globalAlpha = params.scanlines * 0.1;
                    ctx.fillStyle = '#000000';
                    for (let y = 0; y < height; y += 3) {
                        ctx.fillRect(0, y, width, 1);
                    }
                }
                
                // Static noise
                if (params.noise > 0) {
                    const imageData = ctx.createImageData(width, height);
                    const data = imageData.data;
                    const noiseIntensity = params.noise * 25;
                    
                    for (let i = 0; i < data.length; i += 4) {
                        const noise = Math.random() * noiseIntensity;
                        data[i] = noise;     // Red
                        data[i + 1] = noise; // Green  
                        data[i + 2] = noise; // Blue
                        data[i + 3] = noise; // Alpha
                    }
                    
                    ctx.globalAlpha = 0.05;
                    ctx.putImageData(imageData, 0, 0);
                }
                
                // Flicker
                if (params.flicker > 0) {
                    const flickerAmount = Math.sin(time * 0.12) * params.flicker * 0.1;
                    ctx.globalAlpha = Math.abs(flickerAmount);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, width, height);
                }
                
                // Vignette
                if (params.vignette > 0) {
                    const gradient = ctx.createRadialGradient(
                        width / 2, height / 2, 0,
                        width / 2, height / 2, Math.max(width, height) * 0.6
                    );
                    gradient.addColorStop(0, 'rgba(0,0,0,0)');
                    gradient.addColorStop(1, `rgba(0,0,0,${params.vignette * 0.08})`);
                    
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);
                }
                
                ctx.globalAlpha = 1;
            }
            

            updateTextPressureSettings() {
                const enabled = document.getElementById('textPressureEnabled').checked;
                const range = parseInt(document.getElementById('textPressureRange').value);
                const smoothing = parseInt(document.getElementById('textPressureSmoothing').value);
                const minWeight = parseInt(document.getElementById('textPressureMinWeight').value);
                const maxWeight = parseInt(document.getElementById('textPressureMaxWeight').value);
                const minOpacity = parseFloat(document.getElementById('textPressureMinOpacity').value);
                const maxOpacity = parseFloat(document.getElementById('textPressureMaxOpacity').value);
                
                // Update display elements
                const rangeDisplay = document.getElementById('rangeDisplay');
                const smoothingDisplay = document.getElementById('smoothingDisplay');
                const minWeightDisplay = document.getElementById('minWeightDisplay');
                const maxWeightDisplay = document.getElementById('maxWeightDisplay');
                const minOpacityDisplay = document.getElementById('minOpacityDisplay');
                const maxOpacityDisplay = document.getElementById('maxOpacityDisplay');
                
                if (rangeDisplay) rangeDisplay.textContent = `${range}px`;
                if (smoothingDisplay) smoothingDisplay.textContent = smoothing.toString();
                if (minWeightDisplay) minWeightDisplay.textContent = minWeight.toString();
                if (maxWeightDisplay) maxWeightDisplay.textContent = maxWeight.toString();
                if (minOpacityDisplay) minOpacityDisplay.textContent = minOpacity.toFixed(1);
                if (maxOpacityDisplay) maxOpacityDisplay.textContent = maxOpacity.toFixed(1);
                
                // Text Effects
                const boldEffect = document.getElementById('textPressureBold').checked;
                const italicEffect = document.getElementById('textPressureItalic').checked;
                const strikeEffect = document.getElementById('textPressureStrike').checked;
                const underlineEffect = document.getElementById('textPressureUnderline').checked;
                const scaleEffect = document.getElementById('textPressureScale').checked;
                const scaleMin = parseFloat(document.getElementById('textPressureScaleMin').value);
                const scaleMax = parseFloat(document.getElementById('textPressureScaleMax').value);
                
                // Update scale displays
                const scaleMinDisplay = document.getElementById('scaleMinDisplay');
                const scaleMaxDisplay = document.getElementById('scaleMaxDisplay');
                
                if (scaleMinDisplay) scaleMinDisplay.textContent = scaleMin.toFixed(1);
                if (scaleMaxDisplay) scaleMaxDisplay.textContent = scaleMax.toFixed(1);
                
                // Store settings globally for the text pressure effect
                this.textPressureSettings = {
                    enabled,
                    range,
                    smoothing,
                    minWeight,
                    maxWeight,
                    minOpacity,
                    maxOpacity,
                    boldEffect,
                    italicEffect,
                    strikeEffect,
                    underlineEffect,
                    scaleEffect,
                    scaleMin,
                    scaleMax
                };
            }

            initTextPressureTitle() {
                // Initialize settings first
                this.updateTextPressureSettings();
                
                const title = document.querySelector('.header h1');
                const text = title.textContent;
                const chars = text.split('');
                
                // Replace text with individual character spans
                title.innerHTML = chars.map((char, i) => 
                    `<span class="text-pressure-char" data-index="${i}">${char === ' ' ? '&nbsp;' : char}</span>`
                ).join('');
                
                const spans = title.querySelectorAll('.text-pressure-char');
                
                let mouseX = 0;
                let mouseY = 0;
                let targetX = 0;
                let targetY = 0;
                
                const handleMouseMove = (e) => {
                    targetX = e.clientX;
                    targetY = e.clientY;
                };
                
                const animate = () => {
                    if (!this.textPressureSettings.enabled) {
                        // Reset to default when disabled
                        spans.forEach(span => {
                            span.style.fontWeight = '600';
                            span.style.opacity = '1';
                        });
                        requestAnimationFrame(animate);
                        return;
                    }
                    
                    const smoothing = this.textPressureSettings.smoothing;
                    mouseX += (targetX - mouseX) / smoothing;
                    mouseY += (targetY - mouseY) / smoothing;
                    
                    const maxDist = this.textPressureSettings.range;
                    
                    spans.forEach(span => {
                        const rect = span.getBoundingClientRect();
                        const charCenterX = rect.left + rect.width / 2;
                        const charCenterY = rect.top + rect.height / 2;
                        
                        const distance = Math.sqrt(
                            Math.pow(mouseX - charCenterX, 2) + 
                            Math.pow(mouseY - charCenterY, 2)
                        );
                        
                        // Calculate effects based on distance
                        const getAttr = (distance, minVal, maxVal) => {
                            if (distance > maxDist) return minVal;
                            const normalizedDistance = distance / maxDist;
                            return minVal + (maxVal - minVal) * (1 - normalizedDistance);
                        };
                        
                        // Weight effect (configurable min to max)
                        const weight = this.textPressureSettings.boldEffect ? 
                            Math.floor(getAttr(distance, 
                                this.textPressureSettings.minWeight, 
                                this.textPressureSettings.maxWeight
                            )) : 600;
                        
                        // Alpha effect (configurable min to max)
                        const alpha = getAttr(distance, 
                            this.textPressureSettings.minOpacity, 
                            this.textPressureSettings.maxOpacity
                        ).toFixed(2);
                        
                        // Scale effect
                        const scale = this.textPressureSettings.scaleEffect ?
                            getAttr(distance, 
                                this.textPressureSettings.scaleMin, 
                                this.textPressureSettings.scaleMax
                            ).toFixed(2) : 1;
                        
                        // Apply effects
                        span.style.fontWeight = weight;
                        span.style.opacity = alpha;
                        span.style.fontStyle = this.textPressureSettings.italicEffect && distance <= maxDist ? 'italic' : 'normal';
                        span.style.textDecoration = this.getTextDecoration(distance, maxDist);
                        span.style.transform = `scale(${scale})`;
                        span.style.transformOrigin = 'center';
                        span.style.display = 'inline-block';
                    });
                    
                    requestAnimationFrame(animate);
                };
                
                document.addEventListener('mousemove', handleMouseMove);
                animate();
            }

            getTextDecoration(distance, maxDist) {
                const decorations = [];
                
                if (this.textPressureSettings.strikeEffect && distance <= maxDist) {
                    decorations.push('line-through');
                }
                
                if (this.textPressureSettings.underlineEffect && distance <= maxDist) {
                    decorations.push('underline');
                }
                
                return decorations.length > 0 ? decorations.join(' ') : 'none';
            }

            initializeGrid() {
                this.grid = Array(this.gridHeight).fill().map(() => Array(this.gridWidth).fill(this.characterMap?.empty || '·'));
                this.placeAgentsAndObstacles();
                this.renderGrid();
            }

            generatePersistentObstacles() {
                const obstacleCount = parseInt(document.getElementById('obstacleCount').value);
                this.obstacles = [];
                
                for (let i = 0; i < obstacleCount; i++) {
                    let pos;
                    do {
                        pos = {
                            x: Math.floor(Math.random() * (this.gridWidth - 2)) + 1,
                            y: Math.floor(Math.random() * (this.gridHeight - 2)) + 1
                        };
                    } while (this.obstacles.some(obs => obs.x === pos.x && obs.y === pos.y));
                    this.obstacles.push(pos);
                }
            }

            establishTrainingSpawnPoints() {
                // Generate obstacles for training session
                this.generatePersistentObstacles();
                
                // Establish fixed spawn points for this training session
                do {
                    this.trainingCatSpawn = {
                        x: Math.floor(Math.random() * (this.gridWidth - 2)) + 1,
                        y: Math.floor(Math.random() * (this.gridHeight - 2)) + 1
                    };
                } while (this.obstacles.some(obs => obs.x === this.trainingCatSpawn.x && obs.y === this.trainingCatSpawn.y));
                
                do {
                    this.trainingMouseSpawn = {
                        x: Math.floor(Math.random() * (this.gridWidth - 2)) + 1,
                        y: Math.floor(Math.random() * (this.gridHeight - 2)) + 1
                    };
                } while (
                    (this.trainingMouseSpawn.x === this.trainingCatSpawn.x && this.trainingMouseSpawn.y === this.trainingCatSpawn.y) ||
                    this.obstacles.some(obs => obs.x === this.trainingMouseSpawn.x && obs.y === this.trainingMouseSpawn.y)
                );
                
                console.log('Training spawn points established:', {
                    cat: this.trainingCatSpawn,
                    mouse: this.trainingMouseSpawn,
                    obstacles: this.obstacles.length
                });
            }

            placeAgentsAndObstacles() {
                // Clear previous positions
                this.grid = Array(this.gridHeight).fill().map(() => Array(this.gridWidth).fill(this.characterMap?.empty || '·'));
                
                // Reset obstacles to their original positions
                this.obstacles = JSON.parse(JSON.stringify(this.originalObstacles));
                
                // Use consistent spawn points during training, random otherwise
                if (this.isTraining && this.trainingCatSpawn && this.trainingMouseSpawn) {
                    this.catPos = { ...this.trainingCatSpawn };
                    this.mousePos = { ...this.trainingMouseSpawn };
                } else {
                    // Place cat (ensure it's not on an obstacle)
                    do {
                        this.catPos = {
                            x: Math.floor(Math.random() * (this.gridWidth - 2)) + 1,
                            y: Math.floor(Math.random() * (this.gridHeight - 2)) + 1
                        };
                    } while (this.obstacles.some(obs => obs.x === this.catPos.x && obs.y === this.catPos.y));
                    
                    // Place mouse (ensure it's not on the cat or obstacles)
                    do {
                        this.mousePos = {
                            x: Math.floor(Math.random() * (this.gridWidth - 2)) + 1,
                            y: Math.floor(Math.random() * (this.gridHeight - 2)) + 1
                        };
                    } while (this.obstacles.some(obs => obs.x === this.mousePos.x && obs.y === this.mousePos.y) ||
                             (this.catPos.x === this.mousePos.x && this.catPos.y === this.mousePos.y));
                }
                
                // Update grid
                this.updateGridDisplay();
            }

            updateGridDisplay() {
                // Clear grid
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        this.grid[y][x] = this.characterMap?.empty || '·';
                    }
                }
                
                // Add vision if enabled (skip for performance if disabled)
                const visionEnabled = document.getElementById('toggleVision').checked;
                if (visionEnabled) {
                    this.addVisionToGrid();
                }
                
                // Place obstacles
                this.obstacles.forEach(obs => {
                    if (this.grid[obs.y][obs.x] === (this.characterMap?.empty || '·')) {
                        this.grid[obs.y][obs.x] = this.characterMap?.obstacle || 'O';
                    }
                });
                
                // Place agents (they override everything else)
                this.grid[this.catPos.y][this.catPos.x] = this.characterMap?.cat || 'C';
                this.grid[this.mousePos.y][this.mousePos.x] = this.characterMap?.mouse || 'M';
            }

            addVisionToGrid() {
                const catVision = parseInt(document.getElementById('predatorVision').value);
                const mouseVision = parseInt(document.getElementById('preyVision').value);
                
                // Get vision cells for single agents
                const catVisibleCells = this.getVisibleCells(this.catPos, catVision, 'cat');
                const mouseVisibleCells = this.getVisibleCells(this.mousePos, mouseVision, 'mouse');
                
                // Create sets for efficient lookup  
                const catVisionSet = new Set(catVisibleCells.map(cell => `${cell.x},${cell.y}`));
                const mouseVisionSet = new Set(mouseVisibleCells.map(cell => `${cell.x},${cell.y}`));
                
                // Add cat vision
                catVisibleCells.forEach(cell => {
                    if (this.grid[cell.y][cell.x] === (this.characterMap?.empty || '·')) {
                        this.grid[cell.y][cell.x] = this.characterMap?.unknown || '?';
                    }
                });
                
                // Add mouse vision (check for overlap)
                mouseVisibleCells.forEach(cell => {
                    const cellKey = `${cell.x},${cell.y}`;
                    if (this.grid[cell.y][cell.x] === (this.characterMap?.empty || '·')) {
                        this.grid[cell.y][cell.x] = this.characterMap?.unknown || '?';
                    }
                    // If this cell is visible to both agents, use collision symbol
                    else if (this.grid[cell.y][cell.x] === (this.characterMap?.unknown || '?') && catVisionSet.has(cellKey)) {
                        this.grid[cell.y][cell.x] = this.characterMap?.error || '!';
                    }
                });
            }

            getVisibleCells(pos, range, agentType = null) {
                const visible = [];
                const useConeVision = document.getElementById('toggleConeVision')?.checked || false;
                
                if (!useConeVision) {
                    // Use circular vision (original behavior)
                    for (let dx = -range; dx <= range; dx++) {
                        for (let dy = -range; dy <= range; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance > range) continue; // Skip if outside circular range
                            
                            const targetX = pos.x + dx;
                            const targetY = pos.y + dy;
                            
                            if (targetX >= 0 && targetX < this.gridWidth && 
                                targetY >= 0 && targetY < this.gridHeight) {
                                
                                if (this.hasLineOfSight(pos, { x: targetX, y: targetY })) {
                                    visible.push({ x: targetX, y: targetY });
                                }
                            }
                        }
                    }
                } else {
                    // Use cone vision
                    const visionAngle = parseInt(document.getElementById('visionAngle')?.value || 90);
                    let rotation = 0;
                    
                    // Get rotation based on agent type (use dynamic rotation)
                    if (agentType === 'cat') {
                        rotation = this.catRotation;
                    } else if (agentType === 'mouse') {
                        rotation = this.mouseRotation;
                    }
                    
                    // Convert rotation to radians
                    const rotationRad = (rotation * Math.PI) / 180;
                    const halfAngleRad = (visionAngle * Math.PI) / 360; // Half of cone angle
                    
                    for (let dx = -range; dx <= range; dx++) {
                        for (let dy = -range; dy <= range; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance > range) continue; // Skip if outside circular range
                            
                            // Calculate angle from agent position to target cell
                            const targetAngle = Math.atan2(dy, dx);
                            
                            // Calculate angle difference from rotation direction
                            let angleDiff = targetAngle - rotationRad;
                            
                            // Normalize angle difference to [-π, π]
                            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
                            
                            // Check if within cone angle
                            if (Math.abs(angleDiff) <= halfAngleRad) {
                                const targetX = pos.x + dx;
                                const targetY = pos.y + dy;
                                
                                if (targetX >= 0 && targetX < this.gridWidth && 
                                    targetY >= 0 && targetY < this.gridHeight) {
                                    
                                    if (this.hasLineOfSight(pos, { x: targetX, y: targetY })) {
                                        visible.push({ x: targetX, y: targetY });
                                    }
                                }
                            }
                        }
                    }
                }
                
                return visible;
            }

            hasLineOfSight(from, to) {
                // Performance optimization: Create obstacle lookup set if not cached
                if (!this.obstacleSet || this.obstacleSetLastUpdate !== this.obstacles.length) {
                    this.obstacleSet = new Set(this.obstacles.map(obs => `${obs.x},${obs.y}`));
                    this.obstacleSetLastUpdate = this.obstacles.length;
                }
                
                // Use Bresenham's line algorithm to check line of sight
                const dx = Math.abs(to.x - from.x);
                const dy = Math.abs(to.y - from.y);
                const sx = from.x < to.x ? 1 : -1;
                const sy = from.y < to.y ? 1 : -1;
                let err = dx - dy;
                
                let x = from.x;
                let y = from.y;
                
                // Check each step along the line
                while (x !== to.x || y !== to.y) {
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        x += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        y += sy;
                    }
                    
                    // If we hit an obstacle before reaching the target, vision is blocked (optimized lookup)
                    if (this.obstacleSet.has(`${x},${y}`)) {
                        return false;
                    }
                }
                
                return true; // Clear line of sight to target
            }

            renderGrid() {
                if (!document.getElementById('toggleRender').checked) return;
                
                const gridElement = document.getElementById('gameGrid');
                
                // Always use HTML rendering for mouse proximity effects
                {
                    let maxCatVisits = 1, maxMouseVisits = 1;
                    
                    // Only calculate heat map values if heat map is actually enabled
                    if (this.showHeatMap) {
                        // Only recalculate max values every 100 renders for performance
                        if (!this.heatMapCache || this.renderCount % 100 === 0) {
                            const allCatVisits = Object.values(this.catHeatMap);
                            const allMouseVisits = Object.values(this.mouseHeatMap);
                            this.heatMapCache = {
                                maxCatVisits: Math.max(...allCatVisits, 1),
                                maxMouseVisits: Math.max(...allMouseVisits, 1)
                            };
                        }
                        
                        // Use cached values
                        maxCatVisits = this.heatMapCache.maxCatVisits;
                        maxMouseVisits = this.heatMapCache.maxMouseVisits;
                    }
                    
                    // Create HTML with heat map backgrounds
                    let gridHTML = '<pre style="margin: 0; font-family: inherit; line-height: inherit;">';
                    for (let y = 0; y < this.gridHeight; y++) {
                        for (let x = 0; x < this.gridWidth; x++) {
                            // Only apply heat map colors if heat maps are enabled
                            let backgroundColor = '';
                            if (this.showHeatMap) {
                                const key = `${x},${y}`;
                                const catVisits = this.catHeatMap[key] || 0;
                                const mouseVisits = this.mouseHeatMap[key] || 0;
                                
                                // Use the agent with more visits for color
                                if (catVisits > mouseVisits) {
                                    backgroundColor = this.getHeatMapColor(catVisits, maxCatVisits, 'cat');
                                } else if (mouseVisits > 0) {
                                    backgroundColor = this.getHeatMapColor(mouseVisits, maxMouseVisits, 'mouse');
                                }
                            }
                            
                            const char = this.grid[y][x];
                            const style = backgroundColor ? `background-color: ${backgroundColor}` : '';
                            
                            // Determine character type for special effects
                            let charClass = 'grid-char';
                            if (char === (this.characterMap?.cat || 'C') || char.startsWith('C')) {
                                charClass += ' char-cat';
                            } else if (char === (this.characterMap?.mouse || 'M') || char.startsWith('M')) {
                                charClass += ' char-mouse';
                            } else if (char === (this.characterMap?.obstacle || 'O')) {
                                charClass += ' char-obstacle';
                            } else if (char === (this.characterMap?.unknown || '?')) {
                                charClass += ' char-vision';
                            } else if (char === (this.characterMap?.error || '!')) {
                                charClass += ' char-collision';
                            }
                            
                            gridHTML += `<span class="${charClass}" style="${style}" data-x="${x}" data-y="${y}">${char}</span>`;
                        }
                        if (y < this.gridHeight - 1) gridHTML += '\n';
                    }
                    gridHTML += '</pre>';
                    
                    gridElement.innerHTML = gridHTML;
                    
                    // Initialize mouse proximity effects
                    this.initializeMouseProximityEffects();
                }
                
                // Increment render counter for optimization timing
                this.renderCount = (this.renderCount || 0) + 1;
            }

            initializeMouseProximityEffects() {
                const gridElement = document.getElementById('gameGrid');
                if (!gridElement) return;

                // Remove existing event listeners
                if (this.proximityMouseHandler) {
                    gridElement.removeEventListener('mousemove', this.proximityMouseHandler);
                    gridElement.removeEventListener('mouseleave', this.proximityMouseLeaveHandler);
                }

                // Mouse proximity effect parameters
                const radius = 80; // Effect radius in pixels
                const maxScale = 1.4; // Maximum scale factor
                const maxGlow = 2.0; // Maximum glow intensity

                this.proximityMouseHandler = (event) => {
                    const gridRect = gridElement.getBoundingClientRect();
                    const mouseX = event.clientX - gridRect.left;
                    const mouseY = event.clientY - gridRect.top;

                    // Cache character elements for performance
                    const charElements = gridElement.querySelectorAll('.grid-char');
                    
                    charElements.forEach(charEl => {
                        const charRect = charEl.getBoundingClientRect();
                        const charCenterX = charRect.left + charRect.width / 2 - gridRect.left;
                        const charCenterY = charRect.top + charRect.height / 2 - gridRect.top;

                        // Calculate distance from mouse to character center
                        const distance = Math.sqrt(
                            Math.pow(mouseX - charCenterX, 2) + Math.pow(mouseY - charCenterY, 2)
                        );

                        if (distance <= radius) {
                            // Calculate proximity factor (1 at center, 0 at radius)
                            const proximityFactor = Math.max(0, 1 - (distance / radius));
                            
                            // Apply different falloff curves for different effects
                            const exponentialFactor = Math.pow(proximityFactor, 2);
                            const linearFactor = proximityFactor;
                            
                            // Calculate effect values
                            const scale = 1 + (exponentialFactor * (maxScale - 1));
                            const intensity = 0.8 + (linearFactor * 0.2);
                            const glow = linearFactor * maxGlow;
                            const weight = exponentialFactor;
                            
                            // Apply effects
                            charEl.classList.add('proximity-active');
                            charEl.style.setProperty('--char-scale', scale.toFixed(3));
                            charEl.style.setProperty('--char-intensity', intensity.toFixed(3));
                            charEl.style.setProperty('--char-glow', glow.toFixed(3));
                            charEl.style.setProperty('--char-weight', weight.toFixed(3));
                        } else {
                            // Reset character to default state
                            charEl.classList.remove('proximity-active');
                            charEl.style.removeProperty('--char-scale');
                            charEl.style.removeProperty('--char-intensity');
                            charEl.style.removeProperty('--char-glow');
                            charEl.style.removeProperty('--char-weight');
                        }
                    });
                };

                this.proximityMouseLeaveHandler = () => {
                    // Reset all characters when mouse leaves grid
                    const charElements = gridElement.querySelectorAll('.grid-char');
                    charElements.forEach(charEl => {
                        charEl.classList.remove('proximity-active');
                        charEl.style.removeProperty('--char-scale');
                        charEl.style.removeProperty('--char-intensity');
                        charEl.style.removeProperty('--char-glow');
                        charEl.style.removeProperty('--char-weight');
                    });
                };

                // Add event listeners
                gridElement.addEventListener('mousemove', this.proximityMouseHandler);
                gridElement.addEventListener('mouseleave', this.proximityMouseLeaveHandler);
            }

            getState(agentPos, targetPos) {
                // Performance optimization: Use relative positions and quantized distances
                // This reduces state space from potentially millions to thousands
                const dx = Math.max(-10, Math.min(10, targetPos.x - agentPos.x)); // Clamp to [-10, 10]
                const dy = Math.max(-10, Math.min(10, targetPos.y - agentPos.y)); // Clamp to [-10, 10]
                const distance = Math.min(20, Math.abs(dx) + Math.abs(dy)); // Cap distance at 20
                
                // Quantize agent position to reduce state space (divide grid into 8x4 regions)
                const regionX = Math.floor(agentPos.x / 8);
                const regionY = Math.floor(agentPos.y / 8);
                
                return `${regionX},${regionY},${dx},${dy},${distance}`;
            }

            getAction(agent, state) {
                const actions = ['up', 'down', 'left', 'right'];
                const qTable = agent === 'cat' ? this.catQTable : this.mouseQTable;
                
                const epsilon = agent === 'cat' ? this.catEpsilon : this.mouseEpsilon;
                if (Math.random() < epsilon || !qTable[state]) {
                    // Random exploration: choose random movement and rotation
                    this.chooseRandomRotation(agent);
                    return actions[Math.floor(Math.random() * actions.length)];
                }
                
                // Initialize with random action to avoid bias
                let bestActions = [];
                let bestValue = -Infinity;
                
                for (let action of actions) {
                    const value = qTable[state][action] || 0;
                    if (value > bestValue) {
                        bestValue = value;
                        bestActions = [action];
                    } else if (value === bestValue) {
                        bestActions.push(action);
                    }
                }
                
                // When exploiting, choose strategic rotation
                this.chooseStrategicRotation(agent, state);
                
                // Randomly select from best actions to break ties
                const bestAction = bestActions[Math.floor(Math.random() * bestActions.length)];
                
                return bestAction;
            }
            
            chooseRandomRotation(agent) {
                // Only rotate if cone vision is enabled
                if (!document.getElementById('toggleConeVision')?.checked) return;
                
                const rotations = [0, 45, 90, 135, 180, 225, 270, 315];
                const randomRotation = rotations[Math.floor(Math.random() * rotations.length)];
                
                if (agent === 'cat') {
                    this.catRotation = randomRotation;
                } else if (agent === 'mouse') {
                    this.mouseRotation = randomRotation;
                }
                
                // Update the UI sliders to reflect the new rotation
                this.updateRotationSliders();
            }
            
            chooseStrategicRotation(agent, state) {
                // Only rotate if cone vision is enabled
                if (!document.getElementById('toggleConeVision')?.checked) return;
                
                // Strategic rotation: face towards target
                const agentPos = agent === 'cat' ? this.catPos : this.mousePos;
                const targetPos = agent === 'cat' ? this.mousePos : this.catPos;
                
                const dx = targetPos.x - agentPos.x;
                const dy = targetPos.y - agentPos.y;
                
                // Calculate optimal facing direction
                let optimalRotation = 0;
                if (dx > 0 && dy === 0) optimalRotation = 0;    // Right
                else if (dx > 0 && dy > 0) optimalRotation = 45;  // Down-Right
                else if (dx === 0 && dy > 0) optimalRotation = 90;  // Down
                else if (dx < 0 && dy > 0) optimalRotation = 135; // Down-Left
                else if (dx < 0 && dy === 0) optimalRotation = 180; // Left
                else if (dx < 0 && dy < 0) optimalRotation = 225; // Up-Left
                else if (dx === 0 && dy < 0) optimalRotation = 270; // Up
                else if (dx > 0 && dy < 0) optimalRotation = 315; // Up-Right
                
                // For mouse, sometimes choose opposite direction (evasion)
                if (agent === 'mouse' && Math.random() < 0.3) {
                    optimalRotation = (optimalRotation + 180) % 360;
                }
                
                if (agent === 'cat') {
                    this.catRotation = optimalRotation;
                } else if (agent === 'mouse') {
                    this.mouseRotation = optimalRotation;
                }
                
                // Update the UI sliders to reflect the new rotation
                this.updateRotationSliders();
            }
            
            updateRotationSliders() {
                // Rotation sliders have been removed - rotations are now fully AI-controlled
                // This method is kept for compatibility but no longer updates UI elements
            }
            
            openDisplayControls() {
                const toggle = document.getElementById('displayControlsToggle');
                const content = document.getElementById('displayControlsContent');
                
                if (toggle && content) {
                    toggle.classList.remove('collapsed');
                    content.classList.remove('collapsed');
                    toggle.textContent = toggle.textContent.replace('▶', '▼');
                }
            }

            updateQTable(agent, state, action, reward, nextState) {
                const qTable = agent === 'cat' ? this.catQTable : this.mouseQTable;
                
                if (!qTable[state]) {
                    qTable[state] = { up: 0, down: 0, left: 0, right: 0 };
                }
                
                if (!qTable[nextState]) {
                    qTable[nextState] = { up: 0, down: 0, left: 0, right: 0 };
                }
                
                const currentQ = qTable[state][action];
                const maxNextQ = Math.max(...Object.values(qTable[nextState]));
                const learningRate = agent === 'cat' ? this.catLearningRate : this.mouseLearningRate;
                const newQ = currentQ + learningRate * (reward + this.discountFactor * maxNextQ - currentQ);
                
                qTable[state][action] = newQ;
                
                // Performance optimization: Limit Q-table size and cleanup old/unused states
                const maxStates = 50000; // Limit to prevent excessive memory usage
                if (Object.keys(qTable).length > maxStates && Math.random() < 0.001) { // 0.1% chance to clean
                    this.cleanupQTable(agent, maxStates);
                }
            }
            
            cleanupQTable(agent, maxStates) {
                const qTable = agent === 'cat' ? this.catQTable : this.mouseQTable;
                const states = Object.keys(qTable);
                
                if (states.length <= maxStates) return;
                
                // Remove states with low Q-values (likely unused or poor strategies)
                const statesWithValues = states.map(state => ({
                    state,
                    maxQ: Math.max(...Object.values(qTable[state]))
                }));
                
                // Sort by max Q-value and keep top 80% of states
                statesWithValues.sort((a, b) => b.maxQ - a.maxQ);
                const keepCount = Math.floor(maxStates * 0.8);
                const statesToKeep = statesWithValues.slice(0, keepCount);
                
                // Create new Q-table with only the best states
                const newQTable = {};
                statesToKeep.forEach(({state}) => {
                    newQTable[state] = qTable[state];
                });
                
                if (agent === 'cat') {
                    this.catQTable = newQTable;
                } else {
                    this.mouseQTable = newQTable;
                }
                
                console.log(`Cleaned up ${agent} Q-table: ${states.length} -> ${Object.keys(newQTable).length} states`);
            }
            
            // Multi-agent helper methods
            getMultiAgentState(agentPos, targetPos, agentType) {
                // Enhanced state representation for multi-agent scenarios
                const dx = Math.max(-10, Math.min(10, targetPos.x - agentPos.x));
                const dy = Math.max(-10, Math.min(10, targetPos.y - agentPos.y));
                const distance = Math.min(20, Math.abs(dx) + Math.abs(dy));
                
                // Quantize position to reduce state space
                const regionX = Math.floor(agentPos.x / 8);
                const regionY = Math.floor(agentPos.y / 8);
                
                // Add agent type and team size information
                const teamCount = agentType === 'cat' ? this.catCount : this.mouseCount;
                const enemyCount = agentType === 'cat' ? this.mouseCount : this.catCount;
                
                return `${regionX},${regionY},${dx},${dy},${distance},${teamCount},${enemyCount}`;
            }
            
            findNearestMouse(catPos, aliveMice) {
                if (aliveMice.length === 0) return null;
                
                let nearest = null;
                let minDistance = Infinity;
                
                aliveMice.forEach(mouseIndex => {
                    const mouse = this.mice[mouseIndex];
                    const distance = Math.abs(catPos.x - mouse.x) + Math.abs(catPos.y - mouse.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = mouse;
                    }
                });
                
                return nearest;
            }
            
            findNearestCat(mousePos) {
                if (this.cats.length === 0) return null;
                
                let nearest = null;
                let minDistance = Infinity;
                
                this.cats.forEach(cat => {
                    const distance = Math.abs(mousePos.x - cat.x) + Math.abs(mousePos.y - cat.y);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearest = cat;
                    }
                });
                
                return nearest;
            }
            
            checkMultiAgentCaptures(aliveMice) {
                const capturedMice = [];
                
                aliveMice.forEach(mouseIndex => {
                    const mouse = this.mice[mouseIndex];
                    
                    // Check if any cat caught this mouse
                    this.cats.forEach(cat => {
                        if (cat.x === mouse.x && cat.y === mouse.y) {
                            capturedMice.push(mouseIndex);
                        }
                    });
                });
                
                return capturedMice;
            }
            
            getCatWinCondition() {
                // Balanced win conditions based on team sizes
                if (this.catCount === 1 && this.mouseCount === 1) return 1;  // 1v1: catch the mouse
                if (this.catCount === 1 && this.mouseCount === 2) return 2;  // 1v2: catch both mice
                if (this.catCount === 1 && this.mouseCount === 3) return 3;  // 1v3: catch all mice
                if (this.catCount === 2 && this.mouseCount === 1) return 1;  // 2v1: catch the mouse
                if (this.catCount === 2 && this.mouseCount === 2) return 2;  // 2v2: catch both mice
                if (this.catCount === 2 && this.mouseCount === 3) return 2;  // 2v3: catch 2 mice
                if (this.catCount === 3 && this.mouseCount === 2) return 2;  // 3v2: catch both mice
                if (this.catCount === 3 && this.mouseCount === 3) return 2;  // 3v3: catch 2 mice
                
                // Default: catch all mice
                return this.mouseCount;
            }
            
            calculateMultiAgentReward(agentType, oldPos, newPos, enemies) {
                // Optimized multi-agent rewards with early returns
                if (agentType === 'cat') {
                    // Cat rewards: hunting bonus for getting closer to any mouse
                    let bestReward = this.rewards.catExploration; // Default reward
                    
                    // Early exit if no enemies
                    if (enemies.length === 0) return bestReward;
                    
                    for (let i = 0; i < enemies.length; i++) {
                        const enemyIndex = enemies[i];
                        const enemy = this.mice[enemyIndex];
                        if (!enemy) continue;
                        
                        const oldDistance = Math.abs(oldPos.x - enemy.x) + Math.abs(oldPos.y - enemy.y);
                        const newDistance = Math.abs(newPos.x - enemy.x) + Math.abs(newPos.y - enemy.y);
                        
                        if (newDistance < oldDistance) {
                            bestReward = this.rewards.catHunting;
                            break; // Early exit on first hunting reward found
                        }
                    }
                    return bestReward;
                } else {
                    // Mouse rewards: escape bonus for getting farther from nearest cat
                    const nearestCat = this.findNearestCat(newPos);
                    if (!nearestCat) return this.rewards.mouseBlindEscape;
                    
                    const oldDistance = Math.abs(oldPos.x - nearestCat.x) + Math.abs(oldPos.y - nearestCat.y);
                    const newDistance = Math.abs(newPos.x - nearestCat.x) + Math.abs(newPos.y - nearestCat.y);
                    
                    if (newDistance > oldDistance) {
                        return this.rewards.mouseStrategicEscape;
                    } else if (newDistance < oldDistance) {
                        return this.rewards.mouseApproachingDanger;
                    }
                    return this.rewards.mouseBlindEscape;
                }
            }
            
            chooseAgentRotation(agentType, agentIndex) {
                // Simplified rotation - can be enhanced with strategic logic
                if (agentType === 'cat') {
                    const cat = this.cats[agentIndex];
                    const nearestMouse = this.findNearestMouse(cat, this.mice.map((_, i) => i));
                    if (nearestMouse) {
                        const dx = nearestMouse.x - cat.x;
                        const dy = nearestMouse.y - cat.y;
                        return Math.atan2(dy, dx) * 180 / Math.PI;
                    }
                } else {
                    const mouse = this.mice[agentIndex];
                    const nearestCat = this.findNearestCat(mouse);
                    if (nearestCat) {
                        // 30% chance to look away from cat (evasion tactic)
                        if (Math.random() < 0.3) {
                            const dx = nearestCat.x - mouse.x;
                            const dy = nearestCat.y - mouse.y;
                            return (Math.atan2(dy, dx) * 180 / Math.PI + 180) % 360;
                        } else {
                            const dx = nearestCat.x - mouse.x;
                            const dy = nearestCat.y - mouse.y;
                            return Math.atan2(dy, dx) * 180 / Math.PI;
                        }
                    }
                }
                return Math.random() * 360; // Random if no target
            }

            moveAgent(pos, action) {
                const newPos = { ...pos };
                
                switch (action) {
                    case 'up': newPos.y = Math.max(0, pos.y - 1); break;
                    case 'down': newPos.y = Math.min(this.gridHeight - 1, pos.y + 1); break;
                    case 'left': newPos.x = Math.max(0, pos.x - 1); break;
                    case 'right': newPos.x = Math.min(this.gridWidth - 1, pos.x + 1); break;
                }
                
                // Handle obstacle pushing
                const obstacleIndex = this.obstacles.findIndex(obs => obs.x === newPos.x && obs.y === newPos.y);
                if (obstacleIndex !== -1) {
                    const obstacle = this.obstacles[obstacleIndex];
                    const pushPos = { ...obstacle };
                    
                    switch (action) {
                        case 'up': pushPos.y = Math.max(0, obstacle.y - 1); break;
                        case 'down': pushPos.y = Math.min(this.gridHeight - 1, obstacle.y + 1); break;
                        case 'left': pushPos.x = Math.max(0, obstacle.x - 1); break;
                        case 'right': pushPos.x = Math.min(this.gridWidth - 1, obstacle.x + 1); break;
                    }
                    
                    // Check if push position is valid (not another obstacle)
                    const canPush = !this.obstacles.some(obs => obs.x === pushPos.x && obs.y === pushPos.y);
                    
                    if (canPush) {
                        this.obstacles[obstacleIndex] = pushPos;
                        return newPos;
                    } else {
                        return pos; // Can't move, obstacle can't be pushed
                    }
                }
                
                return newPos;
            }

            calculateReward(agent, oldPos, newPos, targetPos, caught) {
                if (caught) {
                    return agent === 'cat' ? this.rewards.catWin : this.rewards.mouseCaught;
                }
                
                const oldDistance = Math.abs(oldPos.x - targetPos.x) + Math.abs(oldPos.y - targetPos.y);
                const newDistance = Math.abs(newPos.x - targetPos.x) + Math.abs(newPos.y - targetPos.y);
                
                if (agent === 'cat') {
                    const catCanSee = this.getVisibleCells(oldPos, parseInt(document.getElementById('predatorVision').value), 'cat')
                        .some(cell => cell.x === targetPos.x && cell.y === targetPos.y);
                    
                    // User-configurable cat reward system
                    if (catCanSee && newDistance < oldDistance) return this.rewards.catHunting;
                    if (!catCanSee && newDistance < oldDistance) return this.rewards.catExploration;
                    if (newDistance === oldDistance) return this.rewards.catStandingStill;
                    if (catCanSee && newDistance > oldDistance) return this.rewards.catRetreating;
                    if (!catCanSee && newDistance > oldDistance) return this.rewards.catStandingStill; // Light penalty for moving away blindly
                } else {
                    const mouseCanSee = this.getVisibleCells(oldPos, parseInt(document.getElementById('preyVision').value), 'mouse')
                        .some(cell => cell.x === targetPos.x && cell.y === targetPos.y);
                    
                    // User-configurable mouse reward system
                    if (!mouseCanSee && newDistance > oldDistance) return this.rewards.mouseBlindEscape;
                    if (mouseCanSee && newDistance > oldDistance) return this.rewards.mouseStrategicEscape;
                    if (newDistance === oldDistance) {
                        return mouseCanSee ? this.rewards.mouseStandingStillVisible : 0; // Only penalize standing still if cat is visible
                    }
                    if (!mouseCanSee && newDistance < oldDistance) return this.rewards.mouseMovingTowardDanger;
                    if (mouseCanSee && newDistance < oldDistance) return this.rewards.mouseApproachingDanger;
                }
                
                return 0;
            }
            
            // Multi-agent functionality removed

            async runEpisode() {
                // Single-agent logic
                const episodeStartTime = Date.now();
                this.placeAgentsAndObstacles();
                const maxSteps = parseInt(document.getElementById('stepCount').value);
                let episodeSteps = 0;
                this.currentCatScore = 0;
                this.currentMouseScore = 0;
                
                for (let step = 0; step < maxSteps && this.isTraining && !this.isPaused; step++) {
                    this.currentStep = step;
                    episodeSteps = step + 1;
                    
                    // Get states
                    const catState = this.getState(this.catPos, this.mousePos);
                    const mouseState = this.getState(this.mousePos, this.catPos);
                    
                    // Get actions
                    const catAction = this.getAction('cat', catState);
                    const mouseAction = this.getAction('mouse', mouseState);
                    
                    // Store old positions
                    const oldCatPos = { ...this.catPos };
                    const oldMousePos = { ...this.mousePos };
                    
                    // Move agents
                    this.catPos = this.moveAgent(this.catPos, catAction);
                    this.mousePos = this.moveAgent(this.mousePos, mouseAction);
                    
                    // Update heat maps
                    this.updateHeatMap('cat', this.catPos.x, this.catPos.y);
                    this.updateHeatMap('mouse', this.mousePos.x, this.mousePos.y);
                    
                    // Check if caught
                    const caught = this.catPos.x === this.mousePos.x && this.catPos.y === this.mousePos.y;
                    
                    // Calculate rewards
                    const catReward = this.calculateReward('cat', oldCatPos, this.catPos, this.mousePos, caught);
                    const mouseReward = this.calculateReward('mouse', oldMousePos, this.mousePos, this.catPos, caught);
                    
                    // Update current episode scores
                    this.currentCatScore += catReward;
                    this.currentMouseScore += mouseReward;
                    
                    // Get new states
                    const newCatState = this.getState(this.catPos, this.mousePos);
                    const newMouseState = this.getState(this.mousePos, this.catPos);
                    
                    // Update Q-tables
                    this.updateQTable('cat', catState, catAction, catReward, newCatState);
                    this.updateQTable('mouse', mouseState, mouseAction, mouseReward, newMouseState);
                    
                    // Update display with throttling for performance
                    this.updateGridDisplay();
                    
                    // Throttle rendering during fast training (only render every 10th step)
                    if (step % 10 === 0 || parseInt(document.getElementById('simulationSpeed').value) > 50) {
                        this.renderGrid();
                        this.updateStats();
                    }
                    
                    // Check if episode ended
                    if (caught) {
                        this.catWins++;
                        break;
                    }
                    
                    // Add delay based on speed setting and render mode
                    const speed = parseInt(document.getElementById('simulationSpeed').value);
                    const renderEnabled = document.getElementById('toggleRender').checked;
                    
                    if (!renderEnabled) {
                        // Turbo mode: minimal delays when rendering is disabled
                        if (step % 100 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    } else if (speed < 500) {
                        await new Promise(resolve => setTimeout(resolve, 500 - speed));
                    } else {
                        // For very fast speeds, yield control to prevent UI freeze
                        if (step % 10 === 0) {
                            await new Promise(resolve => setTimeout(resolve, 1));
                        }
                    }
                }
                
                // If we reached max steps without catching, mouse wins
                if (episodeSteps >= maxSteps && (this.catPos.x !== this.mousePos.x || this.catPos.y !== this.mousePos.y)) {
                    // Give mouse big survival reward
                    const finalMouseState = this.getState(this.mousePos, this.catPos);
                    this.updateQTable('mouse', finalMouseState, 'survival', this.rewards.mouseSurvival, finalMouseState);
                    this.currentMouseScore += this.rewards.mouseSurvival;
                    
                    // Penalize cat for not catching mouse
                    const finalCatState = this.getState(this.catPos, this.mousePos);
                    this.updateQTable('cat', finalCatState, 'failure', this.rewards.catFailure, finalCatState);
                    this.currentCatScore += this.rewards.catFailure;
                    
                    this.mouseWins++;
                }
                
                this.totalSteps += episodeSteps;
                
                // Calculate episode duration
                const episodeDuration = Date.now() - episodeStartTime;
                
                // Record episode data for chart
                const catWinRate = (this.catWins / (this.currentEpisode + 1)) * 100;
                const mouseWinRate = (this.mouseWins / (this.currentEpisode + 1)) * 100;
                
                this.episodeData.push({
                    episode: this.currentEpisode + 1,
                    catWinRate: catWinRate,
                    mouseWinRate: mouseWinRate,
                    duration: episodeDuration,
                    steps: episodeSteps,
                    catScore: this.currentCatScore,
                    mouseScore: this.currentMouseScore
                });
                
                // Performance optimization: Limit episode data to last 10,000 episodes
                if (this.episodeData.length > 10000) {
                    this.episodeData = this.episodeData.slice(-5000); // Keep last 5000 when limit reached
                }
            }

            async startTraining() {
                this.isTraining = true;
                this.isPaused = false;
                this.updateButtonStates(); // Update buttons when training starts
                
                // Only reset stats if starting fresh (no existing Q-tables or episode data)
                const isStartingFresh = Object.keys(this.catQTable).length === 0 && 
                                       Object.keys(this.mouseQTable).length === 0 && 
                                       this.episodeData.length === 0;
                
                if (isStartingFresh) {
                    this.currentEpisode = 0;
                    this.currentStep = 0;
                    this.catWins = 0;
                    this.mouseWins = 0;
                    this.totalSteps = 0;
                    this.episodeData = [];
                    
                    // Reset epsilon for new training session
                    this.catEpsilon = this.catInitialEpsilon;
                    this.mouseEpsilon = this.mouseInitialEpsilon;
                }
                
                // Establish consistent spawn points for this training session
                this.establishTrainingSpawnPoints();
                
                document.getElementById('trainingStatus').textContent = 'Training';
                this.lockParameters(true);
                
                // Show the simulation view and hide welcome screen when training starts
                document.getElementById('welcomeScreen').style.display = 'none';
                document.getElementById('gridView').style.display = 'flex';
                
                const totalEpisodes = parseInt(document.getElementById('episodeCount').value);
                const startingEpisode = this.currentEpisode || 0;
                
                for (let episode = startingEpisode; episode < startingEpisode + totalEpisodes && this.isTraining; episode++) {
                    if (this.isPaused) {
                        document.getElementById('trainingStatus').textContent = 'Paused';
                        break;
                    }
                    
                    this.currentEpisode = episode;
                    await this.runEpisode();
                    this.updateStats();
                    
                    // Apply epsilon decay for reduced exploration over time
                    if (this.catEpsilon > this.minEpsilon) {
                        this.catEpsilon = Math.max(this.minEpsilon, this.catEpsilon * this.epsilonDecay);
                    }
                    if (this.mouseEpsilon > this.minEpsilon) {
                        this.mouseEpsilon = Math.max(this.minEpsilon, this.mouseEpsilon * this.epsilonDecay);
                    }
                }
                
                if (this.isTraining && !this.isPaused) {
                    this.isTraining = false;
                    document.getElementById('trainingStatus').textContent = 'Completed';
                    this.lockParameters(false);
                    this.updateButtonStates(); // Update button states when training completes
                    this.showPerformanceChart();
                }
            }

            stopTraining() {
                this.isTraining = false;
                this.isPaused = true;
                document.getElementById('trainingStatus').textContent = 'Stopped';
                this.lockParameters(false);
                this.updateButtonStates(); // Update buttons when training stops
                
                // Show welcome screen when training stops
                document.getElementById('gridView').style.display = 'none';
                document.getElementById('welcomeScreen').style.display = 'flex';
            }
            
            startNewTraining() {
                // Reset all training data
                this.catQTable = {};
                this.mouseQTable = {};
                this.episodeData = [];
                this.catWins = 0;
                this.mouseWins = 0;
                this.episodeCount = 0;
                this.catHeatMap = {};
                this.mouseHeatMap = {};
                
                // Reset UI
                document.getElementById('trainingStatus').textContent = 'Ready';
                document.getElementById('episodeCount').textContent = '0';
                document.getElementById('catWins').textContent = '0';
                document.getElementById('mouseWins').textContent = '0';
                document.getElementById('winRate').textContent = '0%';
                document.getElementById('currentEpisode').textContent = '0';
                
                // Update button states and start training
                this.updateButtonStates();
                this.startTraining();
            }

            continueTraining() {
                if (this.isPaused) {
                    this.isPaused = false;
                    this.startTraining();
                } else {
                    this.startTraining();
                }
            }

            startNewRound() {
                // Reset all training data for a fresh start
                this.catQTable = {};
                this.mouseQTable = {};
                
                
                // Reset statistics
                this.currentEpisode = 0;
                this.currentStep = 0;
                this.catWins = 0;
                this.mouseWins = 0;
                this.currentCatScore = 0;
                this.currentMouseScore = 0;
                this.episodeData = [];
                this.totalSteps = 0;
                
                // Reset epsilon values to initial values
                this.catEpsilon = this.catInitialEpsilon;
                this.mouseEpsilon = this.mouseInitialEpsilon;
                
                // Clear performance caches
                this.visionCache = null;
                this.obstacleSet = null;
                this.heatMapCache = null;
                
                
                // Reset training status
                this.isTraining = false;
                this.isPaused = false;
                document.getElementById('trainingStatus').textContent = 'Ready';
                
                // Update UI
                this.updateStats();
                this.lockParameters(false);
                this.updateButtonStates(); // This will now show "Start" since all data is reset
                
                // Show welcome screen
                document.getElementById('gridView').style.display = 'none';
                document.getElementById('welcomeScreen').style.display = 'flex';
                document.getElementById('chartContainer').style.display = 'none';
            }

            lockParameters(lock) {
                const parameterIds = [
                    'episodeCount', 'stepCount', 'predatorVision', 'preyVision', 'obstacleCount'
                ];
                
                parameterIds.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.disabled = lock;
                        if (lock) {
                            element.style.opacity = '0.5';
                            element.style.cursor = 'not-allowed';
                        } else {
                            element.style.opacity = '1';
                            element.style.cursor = 'default';
                        }
                    }
                });
            }

            updateStats() {
                document.getElementById('currentEpisode').textContent = this.currentEpisode + 1;
                document.getElementById('currentStep').textContent = this.currentStep + 1;
                
                document.getElementById('catWins').textContent = this.catWins;
                document.getElementById('mouseWins').textContent = this.mouseWins;
                document.getElementById('currentCatScore').textContent = this.currentCatScore.toFixed(2);
                document.getElementById('currentMouseScore').textContent = this.currentMouseScore.toFixed(2);
                
                // Update dynamic exploration rates
                document.getElementById('currentCatEpsilon').textContent = `${(this.catEpsilon * 100).toFixed(1)}%`;
                document.getElementById('currentMouseEpsilon').textContent = `${(this.mouseEpsilon * 100).toFixed(1)}%`;
                
                // Update knowledge size (total unique states learned)
                const catStates = Object.keys(this.catQTable).length;
                const mouseStates = Object.keys(this.mouseQTable).length;
                const totalStates = catStates + mouseStates;
                document.getElementById('knowledgeSize').textContent = `${totalStates} states`;
                
                // Calculate and display training progress percentage
                const totalEpisodes = parseInt(document.getElementById('episodeCount').value) || 1000;
                const progressPercentage = Math.min(((this.currentEpisode + 1) / totalEpisodes) * 100, 100);
                document.getElementById('trainingProgress').textContent = `${progressPercentage.toFixed(1)}%`;
                document.getElementById('obstacleCountDisplay').textContent = this.obstacles ? this.obstacles.length : 0;
                
                const totalGames = this.catWins + this.mouseWins;
                if (totalGames > 0) {
                    document.getElementById('catWinRate').textContent = Math.round((this.catWins / totalGames) * 100) + '%';
                    document.getElementById('mouseWinRate').textContent = Math.round((this.mouseWins / totalGames) * 100) + '%';
                    document.getElementById('avgSteps').textContent = Math.round(this.totalSteps / totalGames);
                }
                
                // Update performance prediction (only every 5 episodes for performance)
                if (this.isTraining && this.currentEpisode % 5 === 0) {
                    this.updatePerformancePrediction();
                }
            }

            updateTrainingStatistics() {
                if (this.episodeData.length === 0) return;
                
                // Calculate time statistics
                const durations = this.episodeData.map(d => d.duration);
                const steps = this.episodeData.map(d => d.steps);
                const catScores = this.episodeData.map(d => d.catScore);
                const mouseScores = this.episodeData.map(d => d.mouseScore);
                
                const fastestTime = Math.min(...durations);
                const slowestTime = Math.max(...durations);
                const averageTime = durations.reduce((sum, d) => sum + d, 0) / durations.length;
                
                const minSteps = Math.min(...steps);
                const maxSteps = Math.max(...steps);
                
                const bestCatScore = Math.max(...catScores);
                const bestMouseScore = Math.max(...mouseScores);
                
                const totalGames = this.catWins + this.mouseWins;
                const catWinRate = totalGames > 0 ? Math.round((this.catWins / totalGames) * 100) : 0;
                const mouseWinRate = totalGames > 0 ? Math.round((this.mouseWins / totalGames) * 100) : 0;
                
                // Format time function
                const formatTime = (ms) => {
                    if (ms < 1000) return `${ms}ms`;
                    return `${(ms / 1000).toFixed(1)}s`;
                };
                
                // Update HTML elements
                document.getElementById('fastestRound').textContent = formatTime(fastestTime);
                document.getElementById('slowestRound').textContent = formatTime(slowestTime);
                document.getElementById('averageRound').textContent = formatTime(averageTime);
                document.getElementById('minSteps').textContent = minSteps.toString();
                document.getElementById('maxSteps').textContent = maxSteps.toString();
                document.getElementById('totalEpisodes').textContent = this.episodeData.length.toString();
                document.getElementById('bestCatScore').textContent = bestCatScore.toFixed(1);
                document.getElementById('bestMouseScore').textContent = bestMouseScore.toFixed(1);
                document.getElementById('finalWinRates').textContent = `C:${catWinRate}% M:${mouseWinRate}%`;
                
                // Show the statistics section
                document.getElementById('chartStats').style.display = 'block';
            }

            showPerformanceChart() {
                document.getElementById('gridView').style.display = 'none';
                document.getElementById('chartContainer').style.display = 'block';
                
                // Calculate and display training statistics
                this.updateTrainingStatistics();
                
                const ctx = document.getElementById('performanceChart').getContext('2d');
                
                if (this.performanceChart) {
                    this.performanceChart.destroy();
                }
                
                this.performanceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: this.episodeData.map(d => d.episode),
                        datasets: [{
                            label: 'M (Mouse) Win Rate %',
                            data: this.episodeData.map(d => d.catWinRate),
                            borderColor: '#7FE9E1',
                            backgroundColor: 'rgba(127, 233, 225, 0.1)',
                            tension: 0.1
                        }, {
                            label: 'C (Cat) Win Rate %',
                            data: this.episodeData.map(d => d.mouseWinRate),
                            borderColor: '#4ECDC4',
                            backgroundColor: 'rgba(78, 205, 196, 0.1)',
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                max: 100,
                                title: {
                                    display: true,
                                    text: 'Win Rate %',
                                    color: '#7FE9E1'
                                },
                                ticks: {
                                    color: '#7FE9E1'
                                },
                                grid: {
                                    color: 'rgba(127, 233, 225, 0.2)'
                                }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Episode Number',
                                    color: '#7FE9E1'
                                },
                                ticks: {
                                    color: '#7FE9E1'
                                },
                                grid: {
                                    color: 'rgba(127, 233, 225, 0.2)'
                                }
                            }
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Performance Over Episodes',
                                color: '#7FE9E1'
                            },
                            legend: {
                                labels: {
                                    color: '#7FE9E1'
                                }
                            }
                        }
                    }
                });
            }

            downloadTraining() {
                const trainingData = {
                    catQTable: this.catQTable,
                    mouseQTable: this.mouseQTable,
                    episodeData: this.episodeData,
                    stats: {
                        catWins: this.catWins,
                        mouseWins: this.mouseWins,
                        currentEpisode: this.currentEpisode,
                        totalSteps: this.totalSteps
                    },
                    environmentData: {
                        obstacles: this.originalObstacles || this.obstacles,
                        trainingCatSpawn: this.trainingCatSpawn,
                        trainingMouseSpawn: this.trainingMouseSpawn,
                        gridWidth: this.gridWidth,
                        gridHeight: this.gridHeight,
                        characterMap: this.characterMap
                    }
                };
                
                const blob = new Blob([JSON.stringify(trainingData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `lumon_training_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }

            triggerUpload() {
                const uploadButton = document.getElementById('uploadTrainingButton');
                uploadButton.textContent = 'Selecting...';
                uploadButton.style.opacity = '0.7';
                document.getElementById('uploadTraining').click();
            }
            
            updateButtonStates() {
                const startButton = document.getElementById('startTraining');
                const stopButton = document.getElementById('stopTraining');
                const continueButton = document.getElementById('continueTraining');
                const newTrainingButton = document.getElementById('newTraining');
                const newRoundButton = document.getElementById('startNewRound');
                
                // Check if there's existing training data
                const hasExistingData = Object.keys(this.catQTable).length > 0 || 
                                      Object.keys(this.mouseQTable).length > 0 || 
                                      this.currentEpisode > 0;
                
                // Check if training is completed (not just stopped)
                const isTrainingCompleted = !this.isTraining && !this.isPaused && hasExistingData && 
                                          document.getElementById('trainingStatus').textContent === 'Completed';
                
                if (this.isTraining) {
                    // During training: hide Start/Continue/NewTraining/NewRound, show Stop
                    startButton.style.display = 'none';
                    continueButton.style.display = 'none';
                    newTrainingButton.style.display = 'none';
                    newRoundButton.style.display = 'none';
                    stopButton.style.display = 'inline-block';
                } else if (isTrainingCompleted) {
                    // Training completed: show Continue and New Round, hide Start/Stop/NewTraining
                    startButton.style.display = 'none';
                    stopButton.style.display = 'none';
                    continueButton.style.display = 'inline-block';
                    newTrainingButton.style.display = 'none';
                    newRoundButton.style.display = 'inline-block';
                    continueButton.textContent = 'Continue';
                } else if (hasExistingData && this.isPaused) {
                    // Has data and is stopped: show Continue and New Training, hide Start/Stop/NewRound
                    startButton.style.display = 'none';
                    stopButton.style.display = 'none';
                    continueButton.style.display = 'inline-block';
                    newTrainingButton.style.display = 'inline-block';
                    newRoundButton.style.display = 'none';
                    continueButton.textContent = 'Continue';
                } else if (hasExistingData) {
                    // Has data but not stopped: show Continue, hide others
                    startButton.style.display = 'none';
                    stopButton.style.display = 'none';
                    continueButton.style.display = 'inline-block';
                    newTrainingButton.style.display = 'none';
                    newRoundButton.style.display = 'none';
                    continueButton.textContent = 'Continue';
                } else {
                    // No data and not training: show Start, hide others
                    startButton.style.display = 'inline-block';
                    stopButton.style.display = 'none';
                    continueButton.style.display = 'none';
                    newTrainingButton.style.display = 'none';
                    newRoundButton.style.display = 'none';
                    startButton.textContent = 'Start';
                }
            }
            
            toggleSettingsVisibility() {
                // Toggle advanced settings sections only (Learning and Reward Parameters remain visible)
                const settingsSection = document.getElementById('settingsSection');
                const typographySection = document.querySelector('[id="typographyToggle"]').parentElement;
                const charactersSection = document.querySelector('[id="charactersToggle"]').parentElement;
                const layoutSection = document.querySelector('[id="layoutToggle"]').parentElement;
                
                const sections = [settingsSection, typographySection, charactersSection, layoutSection];
                sections.forEach(section => {
                    if (section) {
                        section.classList.toggle('settings-section-hidden');
                    }
                });
            }

            loadTraining() {
                if (!this.uploadFile) {
                    alert('No file selected');
                    return;
                }
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const trainingData = JSON.parse(e.target.result);
                        
                        this.catQTable = trainingData.catQTable || {};
                        this.mouseQTable = trainingData.mouseQTable || {};
                        this.episodeData = trainingData.episodeData || [];
                        
                        if (trainingData.stats) {
                            this.catWins = trainingData.stats.catWins || 0;
                            this.mouseWins = trainingData.stats.mouseWins || 0;
                            this.currentEpisode = trainingData.stats.currentEpisode || 0;
                            this.totalSteps = trainingData.stats.totalSteps || 0;
                        }
                        
                        // Restore environment data if available
                        if (trainingData.environmentData) {
                            const envData = trainingData.environmentData;
                            if (envData.obstacles) {
                                this.obstacles = envData.obstacles;
                                this.originalObstacles = JSON.parse(JSON.stringify(envData.obstacles));
                            }
                            if (envData.trainingCatSpawn) {
                                this.trainingCatSpawn = envData.trainingCatSpawn;
                            }
                            if (envData.trainingMouseSpawn) {
                                this.trainingMouseSpawn = envData.trainingMouseSpawn;
                            }
                            if (envData.characterMap) {
                                this.characterMap = envData.characterMap;
                                this.updateLegend();
                                // Update character input fields with null checks
                                const emptyCharInput = document.getElementById('emptyChar');
                                const catCharInput = document.getElementById('catChar');
                                const mouseCharInput = document.getElementById('mouseChar');
                                const obstacleCharInput = document.getElementById('obstacleChar');
                                const unknownCharInput = document.getElementById('unknownChar');
                                const errorCharInput = document.getElementById('errorChar');
                                
                                if (emptyCharInput) emptyCharInput.value = envData.characterMap.empty || '·';
                                if (catCharInput) catCharInput.value = envData.characterMap.cat || 'C';
                                if (mouseCharInput) mouseCharInput.value = envData.characterMap.mouse || 'M';
                                if (obstacleCharInput) obstacleCharInput.value = envData.characterMap.obstacle || 'O';
                                if (unknownCharInput) unknownCharInput.value = envData.characterMap.unknown || '?';
                                if (errorCharInput) errorCharInput.value = envData.characterMap.error || '!';
                            }
                        }
                        
                        this.updateStats();
                        this.updateButtonStates(); // Update button states after loading
                        
                        // Reset upload button
                        const uploadButton = document.getElementById('uploadTrainingButton');
                        uploadButton.textContent = 'Upload';
                        uploadButton.style.opacity = '1';
                        
                        alert('Training data loaded successfully!');
                        
                    } catch (error) {
                        // Reset upload button on error
                        const uploadButton = document.getElementById('uploadTrainingButton');
                        uploadButton.textContent = 'Upload';
                        uploadButton.style.opacity = '1';
                        
                        alert('Error loading training data: ' + error.message);
                    }
                };
                reader.readAsText(this.uploadFile);
            }
            
            // Heat Map Methods
            updateHeatMap(agent, x, y) {
                const key = `${x},${y}`;
                const heatMap = agent === 'cat' ? this.catHeatMap : this.mouseHeatMap;
                heatMap[key] = (heatMap[key] || 0) + 1;
            }
            
            toggleHeatMap() {
                const checkbox = document.getElementById('toggleHeatMap');
                this.showHeatMap = checkbox.checked;
                this.renderGrid();
            }
            
            updateHeatMapIntensity() {
                const slider = document.getElementById('heatMapIntensity');
                const display = document.getElementById('heatMapIntensityDisplay');
                this.heatMapIntensity = parseFloat(slider.value);
                display.textContent = this.heatMapIntensity.toFixed(1);
                if (this.showHeatMap) {
                    this.renderGrid();
                }
            }
            
            clearHeatMap() {
                this.catHeatMap = {};
                this.mouseHeatMap = {};
                this.renderGrid();
            }
            
            getHeatMapColor(visits, maxVisits, agent) {
                if (visits === 0) return '';
                const intensity = Math.min(visits / maxVisits, 1);
                const alpha = intensity * this.heatMapIntensity;
                
                // Tom and Jerry colors: grayish for cat (Tom), brown/orange for mouse (Jerry)
                if (agent === 'cat') {
                    return `rgba(128, 128, 128, ${alpha})`; // Gray for Tom (cat)
                } else {
                    return `rgba(205, 133, 63, ${alpha})`; // Brown/orange for Jerry (mouse)
                }
            }
            
            // Performance Prediction Methods
            calculateLearningEfficiency() {
                if (this.episodeData.length < 10) return 0;
                
                const recentEpisodes = this.episodeData.slice(-10);
                const initialWinRate = this.episodeData.slice(0, 10).reduce((sum, ep) => 
                    sum + (ep.catWinRate || 0), 0) / 10;
                const recentWinRate = recentEpisodes.reduce((sum, ep) => 
                    sum + (ep.catWinRate || 0), 0) / 10;
                
                // Efficiency based on convergence speed and stability
                const improvement = Math.abs(recentWinRate - initialWinRate);
                const stability = this.calculateWinRateStability(recentEpisodes);
                
                return Math.min(100, (improvement * 50 + stability * 50));
            }
            
            calculateWinRateStability(episodes) {
                if (episodes.length < 5) return 0;
                
                const winRates = episodes.map(ep => ep.catWinRate || 0);
                const mean = winRates.reduce((sum, rate) => sum + rate, 0) / winRates.length;
                const variance = winRates.reduce((sum, rate) => sum + Math.pow(rate - mean, 2), 0) / winRates.length;
                const standardDeviation = Math.sqrt(variance);
                
                // Lower deviation = higher stability (inverted scale 0-100)
                return Math.max(0, 100 - (standardDeviation * 2));
            }
            
            predictPerformanceTrend() {
                if (this.episodeData.length < 15) {
                    return {
                        trend: 'insufficient data',
                        predictedWinner: '-',
                        confidence: 0,
                        convergence: 'early training'
                    };
                }
                
                const recentData = this.episodeData.slice(-15);
                const catWinRates = recentData.map(ep => ep.catWinRate || 0);
                
                // Calculate trend using linear regression
                const trend = this.calculateTrend(catWinRates);
                const currentWinRate = catWinRates[catWinRates.length - 1];
                
                // Predict winner based on trend and current performance
                let predictedWinner = 'balanced';
                let confidence = 0;
                
                if (currentWinRate > 60) {
                    predictedWinner = trend > 0 ? 'cat (strengthening)' : 'cat (weakening)';
                    confidence = Math.min(95, currentWinRate + Math.abs(trend * 10));
                } else if (currentWinRate < 40) {
                    predictedWinner = trend < 0 ? 'mouse (strengthening)' : 'mouse (weakening)';
                    confidence = Math.min(95, (100 - currentWinRate) + Math.abs(trend * 10));
                } else {
                    confidence = Math.max(0, 50 - Math.abs(currentWinRate - 50));
                }
                
                // Determine convergence status
                const stability = this.calculateWinRateStability(recentData);
                let convergence = 'converging';
                if (stability > 80) convergence = 'converged';
                else if (stability < 40) convergence = 'unstable';
                
                return {
                    trend: trend > 1 ? '↗ improving' : trend < -1 ? '↘ declining' : '→ stable',
                    predictedWinner,
                    confidence: Math.round(confidence),
                    convergence
                };
            }
            
            calculateTrend(values) {
                const n = values.length;
                if (n < 2) return 0;
                
                const sumX = (n * (n - 1)) / 2; // Sum of indices
                const sumY = values.reduce((sum, val) => sum + val, 0);
                const sumXY = values.reduce((sum, val, i) => sum + (i * val), 0);
                const sumX2 = values.reduce((sum, val, i) => sum + (i * i), 0);
                
                // Linear regression slope
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                return slope;
            }
            
            updatePerformancePrediction() {
                const prediction = this.predictPerformanceTrend();
                const efficiency = this.calculateLearningEfficiency();
                
                // Update UI elements
                document.getElementById('learningEfficiency').textContent = 
                    efficiency > 0 ? `${Math.round(efficiency)}%` : '-';
                
                document.getElementById('winRateTrend').textContent = prediction.trend;
                document.getElementById('predictedWinner').textContent = prediction.predictedWinner;
                document.getElementById('predictionConfidence').textContent = 
                    prediction.confidence > 0 ? `${prediction.confidence}%` : '-';
                document.getElementById('convergenceStatus').textContent = prediction.convergence;
            }
            
            // Environment Preset Methods
            getPresetConfigurations() {
                return {
                    beginner: {
                        name: 'Beginner',
                        description: 'Easy learning environment with high vision and few obstacles',
                        episodeCount: 500,
                        stepCount: 150,
                        predatorVision: 10,
                        preyVision: 8,
                        obstacleCount: 5,
                        catLearningRate: 0.15,
                        mouseLearningRate: 0.15,
                        catEpsilon: 0.4,
                        mouseEpsilon: 0.3,
                        discountFactor: 0.9,
                        epsilonDecay: 0.995
                    },
                    intermediate: {
                        name: 'Intermediate',
                        description: 'Balanced environment for standard training',
                        episodeCount: 1000,
                        stepCount: 200,
                        predatorVision: 8,
                        preyVision: 6,
                        obstacleCount: 10,
                        catLearningRate: 0.11,
                        mouseLearningRate: 0.12,
                        catEpsilon: 0.35,
                        mouseEpsilon: 0.25,
                        discountFactor: 0.95,
                        epsilonDecay: 0.995
                    },
                    expert: {
                        name: 'Expert',
                        description: 'Challenging environment with limited vision and many obstacles',
                        episodeCount: 1500,
                        stepCount: 250,
                        predatorVision: 6,
                        preyVision: 4,
                        obstacleCount: 20,
                        catLearningRate: 0.08,
                        mouseLearningRate: 0.09,
                        catEpsilon: 0.3,
                        mouseEpsilon: 0.2,
                        discountFactor: 0.98,
                        epsilonDecay: 0.998
                    },
                    chaos: {
                        name: 'Chaos Mode',
                        description: 'Extreme difficulty with minimal vision and maximum obstacles',
                        episodeCount: 2000,
                        stepCount: 300,
                        predatorVision: 4,
                        preyVision: 3,
                        obstacleCount: 35,
                        catLearningRate: 0.05,
                        mouseLearningRate: 0.06,
                        catEpsilon: 0.25,
                        mouseEpsilon: 0.15,
                        discountFactor: 0.99,
                        epsilonDecay: 0.999
                    }
                };
            }
            
            loadPreset(presetName) {
                const presets = this.getPresetConfigurations();
                const preset = presets[presetName];
                
                if (!preset) {
                    alert('Unknown preset: ' + presetName);
                    return;
                }
                
                // Apply preset values to form controls
                document.getElementById('episodeCount').value = preset.episodeCount;
                document.getElementById('stepCount').value = preset.stepCount;
                document.getElementById('predatorVision').value = preset.predatorVision;
                document.getElementById('preyVision').value = preset.preyVision;
                document.getElementById('obstacleCount').value = preset.obstacleCount;
                
                // Update learning parameters
                document.getElementById('catLearningRateSlider').value = preset.catLearningRate;
                document.getElementById('mouseLearningRateSlider').value = preset.mouseLearningRate;
                document.getElementById('catEpsilonSlider').value = preset.catEpsilon;
                document.getElementById('mouseEpsilonSlider').value = preset.mouseEpsilon;
                document.getElementById('discountFactorSlider').value = preset.discountFactor;
                document.getElementById('epsilonDecaySlider').value = preset.epsilonDecay;
                
                // Update internal values
                this.catLearningRate = preset.catLearningRate;
                this.mouseLearningRate = preset.mouseLearningRate;
                this.catEpsilon = preset.catEpsilon;
                this.mouseEpsilon = preset.mouseEpsilon;
                this.catInitialEpsilon = preset.catEpsilon;
                this.mouseInitialEpsilon = preset.mouseEpsilon;
                this.discountFactor = preset.discountFactor;
                this.epsilonDecay = preset.epsilonDecay;
                
                // Trigger display updates
                this.updateCatLearningRate();
                this.updateMouseLearningRate();
                this.updateCatEpsilon();
                this.updateMouseEpsilon();
                this.updateRewardParameter('discountFactor');
                this.updateRewardParameter('epsilonDecay');
                
                // Regenerate obstacles with new count
                this.generatePersistentObstacles();
                this.originalObstacles = JSON.parse(JSON.stringify(this.obstacles));
                this.initializeGrid();
                
                this.showNotification(`Loaded ${preset.name} preset`, 'success');
            }
            
            
            // UI Enhancement Methods
            showKeyboardShortcuts() {
                const shortcuts = `
                    <div style="font-size: 0.9rem; line-height: 1.4;">
                        <h3 style="color: #7FE9E1; margin-bottom: 1rem;">Keyboard Shortcuts</h3>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin-bottom: 1rem;">
                            <div>
                                <h4 style="color: #7FE9E1; margin-bottom: 0.5rem;">Training Control</h4>
                                <div><strong>Spacebar</strong> - Start/Stop Training</div>
                                <div><strong>P</strong> - Pause/Continue</div>
                                <div><strong>R</strong> - New Round</div>
                                <div><strong>Ctrl + D</strong> - Download Data</div>
                            </div>
                            
                            <div>
                                <h4 style="color: #7FE9E1; margin-bottom: 0.5rem;">Visualization</h4>
                                <div><strong>H</strong> - Toggle Heat Map</div>
                                <div><strong>V</strong> - Toggle Vision</div>
                                <div><strong>Ctrl + M</strong> - Toggle Settings</div>
                                <div><strong>F1</strong> - Show This Help</div>
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem;">
                            <div>
                                <h4 style="color: #7FE9E1; margin-bottom: 0.5rem;">Presets</h4>
                                <div><strong>1</strong> - Beginner Preset</div>
                                <div><strong>2</strong> - Intermediate Preset</div>
                                <div><strong>3</strong> - Expert Preset</div>
                                <div><strong>4</strong> - Chaos Preset</div>
                            </div>
                            
                            <div>
                                <h4 style="color: #7FE9E1; margin-bottom: 0.5rem;">Speed Control</h4>
                                <div><strong>Ctrl + ↑</strong> - Increase Speed</div>
                                <div><strong>Ctrl + ↓</strong> - Decrease Speed</div>
                                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #a0e7e0;">
                                    Note: Lower values = faster simulation
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                
                // Create and show modal
                this.showModal('Keyboard Shortcuts', shortcuts);
            }
            
            showModal(title, content) {
                // Remove existing modal if present
                const existingModal = document.getElementById('shortcutModal');
                if (existingModal) {
                    existingModal.remove();
                }
                
                // Create modal
                const modal = document.createElement('div');
                modal.id = 'shortcutModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0, 0, 0, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10003;
                `;
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background: #101827;
                    border: 2px solid #7FE9E1;
                    border-radius: 8px;
                    padding: 2rem;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    color: #7FE9E1;
                    font-family: 'Space Mono', 'Lucida Console', monospace;
                    position: relative;
                `;
                
                const closeButton = document.createElement('button');
                closeButton.innerHTML = '×';
                closeButton.style.cssText = `
                    position: absolute;
                    top: 1rem;
                    right: 1rem;
                    background: none;
                    border: none;
                    color: #7FE9E1;
                    font-size: 1.5rem;
                    cursor: pointer;
                    width: 30px;
                    height: 30px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                `;
                
                closeButton.addEventListener('click', () => modal.remove());
                modalContent.innerHTML = content;
                modalContent.appendChild(closeButton);
                modal.appendChild(modalContent);
                
                // Close on click outside
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) modal.remove();
                });
                
                // Close on Escape
                const handleEscape = (e) => {
                    if (e.key === 'Escape') {
                        modal.remove();
                        document.removeEventListener('keydown', handleEscape);
                    }
                };
                document.addEventListener('keydown', handleEscape);
                
                document.body.appendChild(modal);
            }
            
            // Add keyboard shortcut indicator
            addKeyboardIndicator() {
                const indicator = document.createElement('div');
                indicator.id = 'keyboardIndicator';
                indicator.innerHTML = 'Press F1 for shortcuts';
                indicator.style.cssText = `
                    position: fixed;
                    bottom: 1rem;
                    right: 1rem;
                    background: rgba(16, 24, 39, 0.9);
                    color: #7FE9E1;
                    border: 1px solid #4B566A;
                    border-radius: 4px;
                    padding: 0.5rem 0.75rem;
                    font-family: 'Space Mono', 'Lucida Console', monospace;
                    font-size: 0.75rem;
                    z-index: 1000;
                    opacity: 0.7;
                    transition: opacity 0.2s ease;
                    cursor: pointer;
                `;
                
                indicator.addEventListener('mouseenter', () => {
                    indicator.style.opacity = '1';
                });
                
                indicator.addEventListener('mouseleave', () => {
                    indicator.style.opacity = '0.7';
                });
                
                indicator.addEventListener('click', () => {
                    this.showKeyboardShortcuts();
                });
                
                document.body.appendChild(indicator);
            }
            
            // Add visual feedback for actions
            showNotification(message, type = 'info') {
                // Remove existing notification
                const existing = document.getElementById('notification');
                if (existing) existing.remove();
                
                const notification = document.createElement('div');
                notification.id = 'notification';
                notification.textContent = message;
                
                const colors = {
                    info: '#7FE9E1',
                    success: '#7FE9E1',
                    warning: '#7FE9E1',
                    error: '#7FE9E1'
                };
                
                notification.style.cssText = `
                    position: fixed;
                    top: 2rem;
                    right: 2rem;
                    background: #101827;
                    color: ${colors[type]};
                    border: 1px solid ${colors[type]};
                    border-radius: 4px;
                    padding: 0.75rem 1rem;
                    font-family: 'Space Mono', 'Lucida Console', monospace;
                    font-size: 0.85rem;
                    z-index: 10002;
                    opacity: 0;
                    transform: translateX(100%);
                    transition: all 0.3s ease;
                `;
                
                document.body.appendChild(notification);
                
                // Animate in
                requestAnimationFrame(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateX(0)';
                });
                
                // Auto remove after 3 seconds
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.style.opacity = '0';
                        notification.style.transform = 'translateX(100%)';
                        setTimeout(() => notification.remove(), 300);
                    }
                }, 3000);
            }
        }

        // Initialize the application when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            // Temporarily disable animations on page load
            document.body.classList.add('no-animations');
            
            const app = new LumonResearch();
            app.initHeaderScrambleEffect(); // Initialize header scramble effect
            app.initWelcomeDecryptedText(); // Initialize welcome screen DecryptedText effects
            
            // Re-enable animations after a short delay
            setTimeout(() => {
                document.body.classList.remove('no-animations');
            }, 100);
        });
        
        // WebGL Shader Effects
        
        // DecryptedText effect class - vanilla JS version of the React component
        class DecryptedText {
            constructor(element, options = {}) {
                this.element = element;
                this.originalText = element.textContent;
                this.options = {
                    speed: options.speed || 50,
                    maxIterations: options.maxIterations || 10,
                    sequential: options.sequential || false,
                    revealDirection: options.revealDirection || 'start', // 'start', 'end', 'center'
                    useOriginalCharsOnly: options.useOriginalCharsOnly || false,
                    characters: options.characters || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+',
                    animateOn: options.animateOn || 'hover', // 'hover', 'view'
                    ...options
                };
                
                this.displayText = this.originalText;
                this.isHovering = false;
                this.isScrambling = false;
                this.revealedIndices = new Set();
                this.hasAnimated = false;
                this.interval = null;
                this.currentIteration = 0;
                
                this.init();
            }
            
            init() {
                // Wrap the element content
                this.element.innerHTML = `<span class="decrypted-text-wrapper">${this.createCharSpans(this.originalText)}</span>`;
                
                // Set up event listeners
                if (this.options.animateOn === 'hover') {
                    this.element.addEventListener('mouseenter', () => this.startAnimation());
                    this.element.addEventListener('mouseleave', () => this.stopAnimation());
                } else if (this.options.animateOn === 'view') {
                    this.setupIntersectionObserver();
                }
            }
            
            createCharSpans(text) {
                return text.split('').map((char, index) => 
                    `<span class="decrypted-char" data-index="${index}">${char === ' ' ? '&nbsp;' : char}</span>`
                ).join('');
            }
            
            setupIntersectionObserver() {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && !this.hasAnimated) {
                            this.startAnimation();
                            this.hasAnimated = true;
                        }
                    });
                }, {
                    root: null,
                    rootMargin: '0px',
                    threshold: 0.1
                });
                
                observer.observe(this.element);
            }
            
            startAnimation() {
                this.isHovering = true;
                this.isScrambling = true;
                this.currentIteration = 0;
                
                this.interval = setInterval(() => {
                    if (this.options.sequential) {
                        this.sequentialReveal();
                    } else {
                        this.scrambleAll();
                    }
                }, this.options.speed);
            }
            
            stopAnimation() {
                this.isHovering = false;
                this.isScrambling = false;
                this.revealedIndices.clear();
                
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
                
                // Reset to original text
                this.updateDisplay(this.originalText, new Set());
            }
            
            sequentialReveal() {
                if (this.revealedIndices.size < this.originalText.length) {
                    const nextIndex = this.getNextIndex();
                    this.revealedIndices.add(nextIndex);
                    
                    const shuffledText = this.shuffleText(this.originalText, this.revealedIndices);
                    this.updateDisplay(shuffledText, this.revealedIndices);
                } else {
                    this.finishAnimation();
                }
            }
            
            scrambleAll() {
                const shuffledText = this.shuffleText(this.originalText, this.revealedIndices);
                this.updateDisplay(shuffledText, this.revealedIndices);
                
                this.currentIteration++;
                if (this.currentIteration >= this.options.maxIterations) {
                    this.finishAnimation();
                }
            }
            
            finishAnimation() {
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
                this.isScrambling = false;
                this.updateDisplay(this.originalText, new Set(Array.from({length: this.originalText.length}, (_, i) => i)));
            }
            
            getNextIndex() {
                const textLength = this.originalText.length;
                
                switch (this.options.revealDirection) {
                    case 'start':
                        return this.revealedIndices.size;
                    case 'end':
                        return textLength - 1 - this.revealedIndices.size;
                    case 'center':
                        const middle = Math.floor(textLength / 2);
                        const offset = Math.floor(this.revealedIndices.size / 2);
                        const nextIndex = this.revealedIndices.size % 2 === 0 
                            ? middle + offset 
                            : middle - offset - 1;
                            
                        if (nextIndex >= 0 && nextIndex < textLength && !this.revealedIndices.has(nextIndex)) {
                            return nextIndex;
                        }
                        
                        // Fallback: find first unrevealed index
                        for (let i = 0; i < textLength; i++) {
                            if (!this.revealedIndices.has(i)) return i;
                        }
                        return 0;
                    default:
                        return this.revealedIndices.size;
                }
            }
            
            shuffleText(originalText, revealedSet) {
                const availableChars = this.options.useOriginalCharsOnly
                    ? Array.from(new Set(originalText.split(''))).filter(char => char !== ' ')
                    : this.options.characters.split('');
                
                if (this.options.useOriginalCharsOnly) {
                    const positions = originalText.split('').map((char, i) => ({
                        char,
                        isSpace: char === ' ',
                        index: i,
                        isRevealed: revealedSet.has(i)
                    }));
                    
                    const nonSpaceChars = positions
                        .filter(p => !p.isSpace && !p.isRevealed)
                        .map(p => p.char);
                    
                    // Shuffle array
                    for (let i = nonSpaceChars.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [nonSpaceChars[i], nonSpaceChars[j]] = [nonSpaceChars[j], nonSpaceChars[i]];
                    }
                    
                    let charIndex = 0;
                    return positions.map(p => {
                        if (p.isSpace) return ' ';
                        if (p.isRevealed) return originalText[p.index];
                        return nonSpaceChars[charIndex++] || p.char;
                    }).join('');
                } else {
                    return originalText.split('').map((char, i) => {
                        if (char === ' ') return ' ';
                        if (revealedSet.has(i)) return originalText[i];
                        return availableChars[Math.floor(Math.random() * availableChars.length)];
                    }).join('');
                }
            }
            
            updateDisplay(text, revealedSet) {
                const wrapper = this.element.querySelector('.decrypted-text-wrapper');
                if (!wrapper) return;
                
                const chars = wrapper.querySelectorAll('.decrypted-char');
                text.split('').forEach((char, index) => {
                    if (chars[index]) {
                        chars[index].innerHTML = char === ' ' ? '&nbsp;' : char;
                        
                        if (revealedSet.has(index) || !this.isScrambling) {
                            chars[index].classList.add('revealed');
                            chars[index].classList.remove('encrypted-char');
                        } else {
                            chars[index].classList.remove('revealed');
                            chars[index].classList.add('encrypted-char');
                        }
                    }
                });
            }
        }
    </script>

    <!-- Help Popup -->
    <div class="help-popup-overlay" id="helpOverlay"></div>
    <div class="help-popup" id="helpPopup">
        <div class="help-popup-content">
            <button class="help-close-btn" id="helpCloseBtn">&times;</button>
            <div style="width: 100%; text-align: left; line-height: 1.4; font-size: 0.9rem;">
                <div style="margin-bottom: 1.5rem;">
                    <h3 style="color: #7FE9E1; margin-bottom: 0.4rem; font-size: 1.1rem;">Learning Parameters Explained</h3>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #7FE9E1; margin-bottom: 0.4rem; font-size: 1.1rem;">Learning Rate</h4>
                    <p style="margin-bottom: 0.3rem; font-size: 0.85rem; color: #a0e7e0; font-style: italic;">Range: 0.01 - 0.5 (Default: 0.1)</p>
                    <p style="margin-bottom: 0.5rem;">Controls how much the AI agents learn from each experience. Higher values make agents adapt quickly to new situations but may cause instability. Lower values create stable, gradual learning but slower adaptation.</p>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #7FE9E1; margin-bottom: 0.4rem; font-size: 1.1rem;">Exploration Rate</h4>
                    <p style="margin-bottom: 0.3rem; font-size: 0.85rem; color: #a0e7e0; font-style: italic;">Range: 0.05 - 0.8 (Default: 0.3)</p>
                    <p style="margin-bottom: 0.5rem;">Determines how often agents try random actions versus using their learned knowledge. High exploration encourages discovering new strategies but reduces efficiency. Low exploration focuses on known good strategies but may miss better solutions.</p>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #7FE9E1; margin-bottom: 0.4rem; font-size: 1.1rem;">Discount Factor</h4>
                    <p style="margin-bottom: 0.3rem; font-size: 0.85rem; color: #a0e7e0; font-style: italic;">Range: 0.1 - 0.99 (Default: 0.95)</p>
                    <p style="margin-bottom: 0.5rem;">Controls how much agents value future rewards versus immediate rewards. Values near 1.0 make agents plan far ahead for long-term success. Lower values focus on immediate gains and short-term thinking.</p>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <h4 style="color: #7FE9E1; margin-bottom: 0.4rem; font-size: 1.1rem;">Exploration Decay</h4>
                    <p style="margin-bottom: 0.3rem; font-size: 0.85rem; color: #a0e7e0; font-style: italic;">Range: 0.990 - 0.999 (Default: 0.995)</p>
                    <p style="margin-bottom: 0.5rem;">Rate at which exploration decreases over time. Agents start curious and gradually become more focused on their learned strategies. Higher values maintain exploration longer, lower values quickly shift to exploitation.</p>
                </div>
            </div>
        </div>
    </div>
</body>
</html>